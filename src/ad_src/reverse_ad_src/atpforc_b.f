C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) - 15 Jan 2021 14:26
C
C  Differentiation of tpforc in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: clff cyff cdff spanef
C   with respect to varying inputs: sref rv1 rv2 rc gam
C***********************************************************************
C    Module:  atpforc.f
C 
C    Copyright (C) 2002 Mark Drela, Harold Youngren
C 
C    This program is free software; you can redistribute it and/or modify
C    it under the terms of the GNU General Public License as published by
C    the Free Software Foundation; either version 2 of the License, or
C    (at your option) any later version.
C
C    This program is distributed in the hope that it will be useful,
C    but WITHOUT ANY WARRANTY; without even the implied warranty of
C    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
C    GNU General Public License for more details.
C
C    You should have received a copy of the GNU General Public License
C    along with this program; if not, write to the Free Software
C    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
C***********************************************************************
C
      SUBROUTINE TPFORC_B()
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
C
      REAL ny, nz
      REAL vy_u(numax), vz_u(numax), vy_d(ndmax), vz_d(ndmax), vy_g(
     +     ngmax), vz_g(ngmax)
      REAL p(3, 3), p_m(3, 3), p_a(3, 3), p_b(3, 3)
      REAL rt1(3, nsmax), rt2(3, nsmax), rtc(3, nsmax)
      REAL rt1_diff(3, nsmax), rt2_diff(3, nsmax), rtc_diff(3, nsmax)
      REAL gams(nsmax), gams_u(nsmax, numax), gams_d(nsmax, ndmax), 
     +     gams_g(nsmax, ngmax)
      REAL gams_diff(nsmax)
      REAL hpi
      REAL alfat
      REAL betat
      REAL yoff
      REAL zoff
      INTEGER n
      INTEGER jc
      INTEGER i1
      INTEGER i
      INTEGER ic
      INTEGER k
      REAL dxt
      REAL dyt
      REAL dyt_diff
      REAL dzt
      REAL dzt_diff
      REAL dst
      INTRINSIC SQRT
      REAL ycntr
      REAL ycntr_diff
      REAL zcntr
      REAL zcntr_diff
      REAL vy
      REAL vy_diff
      REAL vz
      REAL vz_diff
      INTEGER jv
      REAL dsyz
      REAL rcore
      INTRINSIC MAX
      REAL dy1
      REAL dy1_diff
      REAL dy2
      REAL dy2_diff
      REAL dz1
      REAL dz1_diff
      REAL dz2
      REAL dz2_diff
      REAL rsq1
      REAL rsq1_diff
      REAL rsq2
      REAL rsq2_diff
      REAL ar
      REAL ar_diff
      REAL spanef_cl
      REAL spanef_cy
      REAL spanef_cd
      REAL temp_diff
      REAL temp_diff0
      REAL(kind=8) temp
      REAL(kind=8) temp_diff1
      REAL(kind=8) temp_diff2
      INTEGER ad_from
      INTEGER ad_to
      INTEGER branch
      INTEGER ii1
      INTEGER ii2
C
      hpi = 1.0/(2.0*pi)
C
C---- set Prandtl-Glauert transformation matrix
      alfat = 0.
      betat = 0.
      CALL PGMAT(amach, alfat, betat, p, p_m, p_a, p_b)
C
      yoff = 2.0*ysym
      zoff = 2.0*zsym
C
      clff = 0.
      cyff = 0.
      cdff = 0.
C
      DO jc=1,nstrip
        gams(jc) = 0.
C
Ccc        ISURF = NSURFS(JC)
Ccc        IF(LFLOAD(ISURF)) THEN   !Bug 6/13/14 HHY 
C------- add circulation of this strip only if it contributes to total load
        i1 = ijfrst(jc)
        ad_from = i1
        DO i=ad_from,i1+nvstrp(jc)-1
          gams(jc) = gams(jc) + gam(i)
        ENDDO
        CALL PUSHINTEGER4(i - 1)
        CALL PUSHINTEGER4(ad_from)
      ENDDO
Ccc        ENDIF
C
C---- set x,y,z in wind axes (Y,Z are then in Trefftz plane)
      DO jc=1,nstrip
        CALL PUSHINTEGER4(ic)
        ic = ijfrst(jc) + nvstrp(jc) - 1
        DO k=1,3
          rt1(k, jc) = p(k, 1)*rv1(1, ic) + p(k, 2)*rv1(2, ic) + p(k, 3)
     +      *rv1(3, ic)
          rt2(k, jc) = p(k, 1)*rv2(1, ic) + p(k, 2)*rv2(2, ic) + p(k, 3)
     +      *rv2(3, ic)
          rtc(k, jc) = p(k, 1)*rc(1, ic) + p(k, 2)*rc(2, ic) + p(k, 3)*
     +      rc(3, ic)
        ENDDO
      ENDDO
C
C...Find the normal velocity across each strip at the projected control
C   point location
      DO jc=1,nstrip
        dyt = rt2(2, jc) - rt1(2, jc)
        dzt = rt2(3, jc) - rt1(3, jc)
C
        ycntr = rtc(2, jc)
        zcntr = rtc(3, jc)
C
        CALL PUSHREAL8(vy)
        vy = 0.
        CALL PUSHREAL8(vz)
        vz = 0.
C
C...Sum velocity contributions from wake vortices
        DO jv=1,nstrip
C
          rcore = 0.
C
          dy1 = ycntr - rt1(2, jv)
          dy2 = ycntr - rt2(2, jv)
          dz1 = zcntr - rt1(3, jv)
          dz2 = zcntr - rt2(3, jv)
          rsq1 = dy1*dy1 + dz1*dz1 + rcore**2
          rsq2 = dy2*dy2 + dz2*dz2 + rcore**2
          vy = vy + hpi*gams(jv)*(dz1/rsq1-dz2/rsq2)
          vz = vz + hpi*gams(jv)*(-(dy1/rsq1)+dy2/rsq2)
C
          IF (izsym .NE. 0) THEN
            dy1 = ycntr - rt1(2, jv)
            dy2 = ycntr - rt2(2, jv)
            dz1 = zcntr - (zoff-rt1(3, jv))
            dz2 = zcntr - (zoff-rt2(3, jv))
CCC         DZ1 = ZCNTR - (ZOFF-RT1(3,JV)+ALFA*RT1(1,JV))
CCC         DZ2 = ZCNTR - (ZOFF-RT2(3,JV)+ALFA*RT2(1,JV))
            rsq1 = dy1*dy1 + dz1*dz1
            rsq2 = dy2*dy2 + dz2*dz2
            vy = vy - hpi*gams(jv)*(dz1/rsq1-dz2/rsq2)*izsym
            vz = vz - hpi*gams(jv)*(-(dy1/rsq1)+dy2/rsq2)*izsym
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
C
          IF (iysym .NE. 0) THEN
            dy1 = ycntr - (yoff-rt1(2, jv))
            dy2 = ycntr - (yoff-rt2(2, jv))
            dz1 = zcntr - rt1(3, jv)
            dz2 = zcntr - rt2(3, jv)
            rsq1 = dy1*dy1 + dz1*dz1
            rsq2 = dy2*dy2 + dz2*dz2
            vy = vy - hpi*gams(jv)*(dz1/rsq1-dz2/rsq2)*iysym
            vz = vz - hpi*gams(jv)*(-(dy1/rsq1)+dy2/rsq2)*iysym
C
            IF (izsym .NE. 0) THEN
              dy1 = ycntr - (yoff-rt1(2, jv))
              dy2 = ycntr - (yoff-rt2(2, jv))
              dz1 = zcntr - (zoff-rt1(3, jv))
              dz2 = zcntr - (zoff-rt2(3, jv))
CCC           DZ1 = ZCNTR - (ZOFF-RT1(3,JV)+ALFA*RT1(1,JV))
CCC           DZ2 = ZCNTR - (ZOFF-RT2(3,JV)+ALFA*RT2(1,JV))
              rsq1 = dy1*dy1 + dz1*dz1
              rsq2 = dy2*dy2 + dz2*dz2
              vy = vy + hpi*gams(jv)*(dz1/rsq1-dz2/rsq2)*iysym*izsym
              vz = vz + hpi*gams(jv)*(-(dy1/rsq1)+dy2/rsq2)*iysym*izsym
              CALL PUSHCONTROL2B(0)
            ELSE
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE
            CALL PUSHCONTROL2B(2)
          END IF
        ENDDO
C
C
C...Trefftz-plane drag is kinetic energy in crossflow
C
        clff = clff + 2.0*gams(jc)*dyt/sref
        cyff = cyff - 2.0*gams(jc)*dzt/sref
        cdff = cdff + gams(jc)*(dzt*vy-dyt*vz)/sref
      ENDDO
C
C---- Double the X,Z forces, zero Y force for a Y symmetric case
      IF (iysym .EQ. 1) THEN
        clff = 2.0*clff
        cyff = 0.0
        cdff = 2.0*cdff
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
C
C---- aspect ratio
      ar = bref**2/sref
C
C---- span efficiency
      IF (cdff .EQ. 0.0) THEN
        ar_diff = 0.D0
      ELSE
        temp = pi*ar*cdff
        temp_diff2 = spanef_diff/temp
        clff_diff = clff_diff + 2*clff*temp_diff2
        cyff_diff = cyff_diff + 2*cyff*temp_diff2
        temp_diff1 = -((clff**2+cyff**2)*temp_diff2/temp)
        ar_diff = pi*cdff*temp_diff1
        cdff_diff = cdff_diff + pi*ar*temp_diff1
      END IF
      sref_diff = -(bref**2*ar_diff/sref**2)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        cdff_diff = 2.0*cdff_diff
        clff_diff = 2.0*clff_diff
        cyff_diff = 0.D0
      END IF
      DO ii1=1,nsmax
        DO ii2=1,3
          rt2_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nsmax
        DO ii2=1,3
          rtc_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nsmax
        gams_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        DO ii2=1,3
          rt1_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO jc=nstrip,1,-1
        dyt = rt2(2, jc) - rt1(2, jc)
        dzt = rt2(3, jc) - rt1(3, jc)
        temp = gams(jc)/sref
        temp_diff1 = (dzt*vy-dyt*vz)*cdff_diff/sref
        temp_diff0 = temp*cdff_diff
        vy_diff = dzt*temp_diff0
        vz_diff = -(dyt*temp_diff0)
        gams_diff(jc) = gams_diff(jc) + temp_diff1 + dyt*2.0*clff_diff/
     +    sref - dzt*2.0*cyff_diff/sref
        sref_diff = sref_diff - temp*temp_diff1
        temp_diff1 = -(gams(jc)*2.0*cyff_diff/sref)
        dzt_diff = vy*temp_diff0 + temp_diff1
        sref_diff = sref_diff - dzt*temp_diff1/sref
        temp_diff1 = gams(jc)*2.0*clff_diff/sref
        dyt_diff = temp_diff1 - vz*temp_diff0
        sref_diff = sref_diff - dyt*temp_diff1/sref
        ycntr = rtc(2, jc)
        zcntr = rtc(3, jc)
        ycntr_diff = 0.D0
        zcntr_diff = 0.D0
        DO jv=nstrip,1,-1
          CALL POPCONTROL2B(branch)
          IF (branch .EQ. 0) THEN
            dy1 = ycntr - (yoff-rt1(2, jv))
            dy2 = ycntr - (yoff-rt2(2, jv))
            dz1 = zcntr - (zoff-rt1(3, jv))
            dz2 = zcntr - (zoff-rt2(3, jv))
            rsq1 = dy1*dy1 + dz1*dz1
            rsq2 = dy2*dy2 + dz2*dz2
            temp_diff0 = hpi*iysym*izsym*vz_diff
            gams_diff(jv) = gams_diff(jv) + (dy2/rsq2-dy1/rsq1)*
     +        temp_diff0
            temp_diff = gams(jv)*temp_diff0
            dy2_diff = temp_diff/rsq2
            rsq2_diff = -(dy2*temp_diff/rsq2**2)
            dy1_diff = -(temp_diff/rsq1)
            rsq1_diff = dy1*temp_diff/rsq1**2
            temp_diff0 = hpi*iysym*izsym*vy_diff
            gams_diff(jv) = gams_diff(jv) + (dz1/rsq1-dz2/rsq2)*
     +        temp_diff0
            temp_diff = gams(jv)*temp_diff0
            rsq1_diff = rsq1_diff - dz1*temp_diff/rsq1**2
            dz1_diff = temp_diff/rsq1 + 2*dz1*rsq1_diff
            rsq2_diff = rsq2_diff + dz2*temp_diff/rsq2**2
            dz2_diff = 2*dz2*rsq2_diff - temp_diff/rsq2
            dy2_diff = dy2_diff + 2*dy2*rsq2_diff
            dy1_diff = dy1_diff + 2*dy1*rsq1_diff
            zcntr_diff = zcntr_diff + dz2_diff + dz1_diff
            rt2_diff(3, jv) = rt2_diff(3, jv) + dz2_diff
            rt1_diff(3, jv) = rt1_diff(3, jv) + dz1_diff
            ycntr_diff = ycntr_diff + dy2_diff + dy1_diff
            rt2_diff(2, jv) = rt2_diff(2, jv) + dy2_diff
            rt1_diff(2, jv) = rt1_diff(2, jv) + dy1_diff
          ELSE IF (branch .NE. 1) THEN
            GOTO 100
          END IF
          dy1 = ycntr - (yoff-rt1(2, jv))
          dy2 = ycntr - (yoff-rt2(2, jv))
          dz1 = zcntr - rt1(3, jv)
          dz2 = zcntr - rt2(3, jv)
          rsq1 = dy1*dy1 + dz1*dz1
          rsq2 = dy2*dy2 + dz2*dz2
          temp_diff0 = -(hpi*iysym*vz_diff)
          gams_diff(jv) = gams_diff(jv) + (dy2/rsq2-dy1/rsq1)*temp_diff0
          temp_diff = gams(jv)*temp_diff0
          dy2_diff = temp_diff/rsq2
          rsq2_diff = -(dy2*temp_diff/rsq2**2)
          dy1_diff = -(temp_diff/rsq1)
          rsq1_diff = dy1*temp_diff/rsq1**2
          temp_diff0 = -(hpi*iysym*vy_diff)
          gams_diff(jv) = gams_diff(jv) + (dz1/rsq1-dz2/rsq2)*temp_diff0
          temp_diff = gams(jv)*temp_diff0
          rsq1_diff = rsq1_diff - dz1*temp_diff/rsq1**2
          dz1_diff = temp_diff/rsq1 + 2*dz1*rsq1_diff
          rsq2_diff = rsq2_diff + dz2*temp_diff/rsq2**2
          dz2_diff = 2*dz2*rsq2_diff - temp_diff/rsq2
          dy2_diff = dy2_diff + 2*dy2*rsq2_diff
          dy1_diff = dy1_diff + 2*dy1*rsq1_diff
          zcntr_diff = zcntr_diff + dz2_diff + dz1_diff
          rt2_diff(3, jv) = rt2_diff(3, jv) - dz2_diff
          rt1_diff(3, jv) = rt1_diff(3, jv) - dz1_diff
          ycntr_diff = ycntr_diff + dy2_diff + dy1_diff
          rt2_diff(2, jv) = rt2_diff(2, jv) + dy2_diff
          rt1_diff(2, jv) = rt1_diff(2, jv) + dy1_diff
 100      CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            dy1 = ycntr - rt1(2, jv)
            dy2 = ycntr - rt2(2, jv)
            dz1 = zcntr - (zoff-rt1(3, jv))
            dz2 = zcntr - (zoff-rt2(3, jv))
            rsq1 = dy1*dy1 + dz1*dz1
            rsq2 = dy2*dy2 + dz2*dz2
            temp_diff0 = -(hpi*izsym*vz_diff)
            temp_diff = gams(jv)*temp_diff0
            dy2_diff = temp_diff/rsq2
            rsq2_diff = -(dy2*temp_diff/rsq2**2)
            dy1_diff = -(temp_diff/rsq1)
            rsq1_diff = dy1*temp_diff/rsq1**2
            temp_diff = -(hpi*izsym*vy_diff)
            gams_diff(jv) = gams_diff(jv) + (dy2/rsq2-dy1/rsq1)*
     +        temp_diff0 + (dz1/rsq1-dz2/rsq2)*temp_diff
            temp_diff0 = gams(jv)*temp_diff
            rsq1_diff = rsq1_diff - dz1*temp_diff0/rsq1**2
            dz1_diff = temp_diff0/rsq1 + 2*dz1*rsq1_diff
            rsq2_diff = rsq2_diff + dz2*temp_diff0/rsq2**2
            dz2_diff = 2*dz2*rsq2_diff - temp_diff0/rsq2
            dy2_diff = dy2_diff + 2*dy2*rsq2_diff
            dy1_diff = dy1_diff + 2*dy1*rsq1_diff
            zcntr_diff = zcntr_diff + dz2_diff + dz1_diff
            rt2_diff(3, jv) = rt2_diff(3, jv) + dz2_diff
            rt1_diff(3, jv) = rt1_diff(3, jv) + dz1_diff
            ycntr_diff = ycntr_diff + dy2_diff + dy1_diff
            rt2_diff(2, jv) = rt2_diff(2, jv) - dy2_diff
            rt1_diff(2, jv) = rt1_diff(2, jv) - dy1_diff
          END IF
          dy1 = ycntr - rt1(2, jv)
          dy2 = ycntr - rt2(2, jv)
          rcore = 0.
          dz1 = zcntr - rt1(3, jv)
          dz2 = zcntr - rt2(3, jv)
          rsq1 = dy1*dy1 + dz1*dz1 + rcore**2
          rsq2 = dy2*dy2 + dz2*dz2 + rcore**2
          gams_diff(jv) = gams_diff(jv) + (dy2/rsq2-dy1/rsq1)*hpi*
     +      vz_diff + (dz1/rsq1-dz2/rsq2)*hpi*vy_diff
          temp_diff = gams(jv)*hpi*vz_diff
          dy2_diff = temp_diff/rsq2
          rsq2_diff = -(dy2*temp_diff/rsq2**2)
          dy1_diff = -(temp_diff/rsq1)
          rsq1_diff = dy1*temp_diff/rsq1**2
          temp_diff = gams(jv)*hpi*vy_diff
          rsq1_diff = rsq1_diff - dz1*temp_diff/rsq1**2
          dz1_diff = temp_diff/rsq1 + 2*dz1*rsq1_diff
          rsq2_diff = rsq2_diff + dz2*temp_diff/rsq2**2
          dz2_diff = 2*dz2*rsq2_diff - temp_diff/rsq2
          dy2_diff = dy2_diff + 2*dy2*rsq2_diff
          dy1_diff = dy1_diff + 2*dy1*rsq1_diff
          zcntr_diff = zcntr_diff + dz2_diff + dz1_diff
          rt2_diff(3, jv) = rt2_diff(3, jv) - dz2_diff
          rt1_diff(3, jv) = rt1_diff(3, jv) - dz1_diff
          ycntr_diff = ycntr_diff + dy2_diff + dy1_diff
          rt2_diff(2, jv) = rt2_diff(2, jv) - dy2_diff
          rt1_diff(2, jv) = rt1_diff(2, jv) - dy1_diff
        ENDDO
        CALL POPREAL8(vz)
        CALL POPREAL8(vy)
        rtc_diff(3, jc) = rtc_diff(3, jc) + zcntr_diff
        rtc_diff(2, jc) = rtc_diff(2, jc) + ycntr_diff
        rt2_diff(3, jc) = rt2_diff(3, jc) + dzt_diff
        rt1_diff(3, jc) = rt1_diff(3, jc) - dzt_diff
        rt2_diff(2, jc) = rt2_diff(2, jc) + dyt_diff
        rt1_diff(2, jc) = rt1_diff(2, jc) - dyt_diff
      ENDDO
      DO ii1=1,nvmax
        DO ii2=1,3
          rv1_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvmax
        DO ii2=1,3
          rv2_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvmax
        DO ii2=1,3
          rc_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO jc=nstrip,1,-1
        DO k=3,1,-1
          rc_diff(1, ic) = rc_diff(1, ic) + p(k, 1)*rtc_diff(k, jc)
          rc_diff(2, ic) = rc_diff(2, ic) + p(k, 2)*rtc_diff(k, jc)
          rc_diff(3, ic) = rc_diff(3, ic) + p(k, 3)*rtc_diff(k, jc)
          rtc_diff(k, jc) = 0.D0
          rv2_diff(1, ic) = rv2_diff(1, ic) + p(k, 1)*rt2_diff(k, jc)
          rv2_diff(2, ic) = rv2_diff(2, ic) + p(k, 2)*rt2_diff(k, jc)
          rv2_diff(3, ic) = rv2_diff(3, ic) + p(k, 3)*rt2_diff(k, jc)
          rt2_diff(k, jc) = 0.D0
          rv1_diff(1, ic) = rv1_diff(1, ic) + p(k, 1)*rt1_diff(k, jc)
          rv1_diff(2, ic) = rv1_diff(2, ic) + p(k, 2)*rt1_diff(k, jc)
          rv1_diff(3, ic) = rv1_diff(3, ic) + p(k, 3)*rt1_diff(k, jc)
          rt1_diff(k, jc) = 0.D0
        ENDDO
        CALL POPINTEGER4(ic)
      ENDDO
      DO ii1=1,nvmax
        gam_diff(ii1) = 0.D0
      ENDDO
      DO jc=nstrip,1,-1
        CALL POPINTEGER4(ad_from)
        CALL POPINTEGER4(ad_to)
        DO i=ad_to,ad_from,-1
          gam_diff(i) = gam_diff(i) + gams_diff(jc)
        ENDDO
        gams_diff(jc) = 0.D0
      ENDDO
      END

