C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) - 15 Jan 2021 14:26
C
C  Differentiation of update_surfaces in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: rle chord rle1 chord1 rle2
C                chord2 wstrip ess ensy ensz xsref ysref zsref
C                rv1 rv2 rv rc rs dxv chordv enc env enc_d
C   with respect to varying inputs: xyzscal xyztran addinc xyzles
C                chords aincs xasec sasec claf rle chord rle1 chord1
C                rle2 chord2 wstrip ess ensy ensz xsref ysref zsref
C                rv1 rv2 rv rc rs dxv chordv enc env enc_d
C   RW status of diff variables: xyzscal:out xyztran:out addinc:out
C                xyzles:out chords:out aincs:out xasec:out sasec:out
C                claf:out rle:in-out chord:in-out rle1:in-out chord1:in-out
C                rle2:in-out chord2:in-out wstrip:in-out ess:in-out
C                ensy:in-out ensz:in-out xsref:in-out ysref:in-out
C                zsref:in-out rv1:in-out rv2:in-out rv:in-out rc:in-out
C                rs:in-out dxv:in-out chordv:in-out enc:in-out
C                env:in-out enc_d:in-out
C MAKESURF
      SUBROUTINE UPDATE_SURFACES_B()
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
      INTEGER isurf
      INTEGER ii1
      INTEGER branch
      INTEGER ii2
      INTEGER ii3
      nstrip = 0
      nvor = 0
      DO 100 isurf=1,nsurf
        IF (lverbose) WRITE(*, *) 'Updating surface ', isurf
        IF (isurf .NE. 1) THEN
          IF (ldupl(isurf-1)) THEN
            CALL PUSHCONTROL2B(0)
            GOTO 100
          ELSE
C this surface has already been created
            CALL PUSHREAL8ARRAY(chord, nsmax)
            CALL PUSHINTEGER4ARRAY(nvstrp, nsmax)
            CALL PUSHINTEGER4ARRAY(ijfrst, nsmax)
            CALL PUSHINTEGER4ARRAY(nvs, nfmax)
            CALL PUSHINTEGER4ARRAY(nvc, nfmax)
            CALL PUSHINTEGER4ARRAY(jfrst, nfmax)
            CALL PUSHINTEGER4ARRAY(nj, nfmax)
            CALL MAKESURF(isurf)
            CALL PUSHCONTROL1B(0)
          END IF
        ELSE
          CALL PUSHREAL8ARRAY(chord, nsmax)
          CALL PUSHINTEGER4ARRAY(nvstrp, nsmax)
          CALL PUSHINTEGER4ARRAY(ijfrst, nsmax)
          CALL PUSHINTEGER4ARRAY(nvs, nfmax)
          CALL PUSHINTEGER4ARRAY(nvc, nfmax)
          CALL PUSHINTEGER4ARRAY(jfrst, nfmax)
          CALL PUSHINTEGER4ARRAY(nj, nfmax)
          CALL MAKESURF(isurf)
          CALL PUSHCONTROL1B(1)
        END IF
        IF (ldupl(isurf)) THEN
          CALL PUSHREAL8ARRAY(vrefl, nsmax*ndmax)
          CALL PUSHINTEGER4ARRAY(nvstrp, nsmax)
          CALL PUSHINTEGER4ARRAY(ijfrst, nsmax)
          CALL PUSHINTEGER4ARRAY(nvs, nfmax)
          CALL PUSHINTEGER4ARRAY(nvc, nfmax)
          CALL PUSHINTEGER4ARRAY(jfrst, nfmax)
          CALL PUSHINTEGER4ARRAY(nk, nfmax)
          CALL PUSHINTEGER4ARRAY(nj, nfmax)
          DO ii1=1,nfmax
            CALL PUSHCHARACTERARRAY(stitle(ii1), 40)
          ENDDO
          CALL SDUPL(isurf, ydupl(isurf), 'ydup')
          CALL PUSHCONTROL2B(2)
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
 100  CONTINUE
      CALL ENCALC_B()
      DO ii1=1,nfmax
        DO ii2=1,3
          xyzscal_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nfmax
        DO ii2=1,3
          xyztran_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nfmax
        addinc_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nfmax
        DO ii2=1,nsmax
          DO ii3=1,3
            xyzles_diff(ii3, ii2, ii1) = 0.D0
          ENDDO
        ENDDO
      ENDDO
      DO ii1=1,nfmax
        DO ii2=1,nsmax
          chords_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nfmax
        DO ii2=1,nsmax
          aincs_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nfmax
        DO ii2=1,nsmax
          DO ii3=1,ibx
            xasec_diff(ii3, ii2, ii1) = 0.D0
          ENDDO
        ENDDO
      ENDDO
      DO ii1=1,nfmax
        DO ii2=1,nsmax
          DO ii3=1,ibx
            sasec_diff(ii3, ii2, ii1) = 0.D0
          ENDDO
        ENDDO
      ENDDO
      DO ii1=1,nfmax
        DO ii2=1,nsmax
          claf_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO isurf=nsurf,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .NE. 1) THEN
            DO ii1=nfmax,1,-1
              CALL POPCHARACTERARRAY(stitle(ii1), 40)
            ENDDO
            CALL POPINTEGER4ARRAY(nj, nfmax)
            CALL POPINTEGER4ARRAY(nk, nfmax)
            CALL POPINTEGER4ARRAY(jfrst, nfmax)
            CALL POPINTEGER4ARRAY(nvc, nfmax)
            CALL POPINTEGER4ARRAY(nvs, nfmax)
            CALL POPINTEGER4ARRAY(ijfrst, nsmax)
            CALL POPINTEGER4ARRAY(nvstrp, nsmax)
            CALL POPREAL8ARRAY(vrefl, nsmax*ndmax)
            CALL SDUPL_B(isurf, ydupl(isurf), 'ydup')
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPINTEGER4ARRAY(nj, nfmax)
            CALL POPINTEGER4ARRAY(jfrst, nfmax)
            CALL POPINTEGER4ARRAY(nvc, nfmax)
            CALL POPINTEGER4ARRAY(nvs, nfmax)
            CALL POPINTEGER4ARRAY(ijfrst, nsmax)
            CALL POPINTEGER4ARRAY(nvstrp, nsmax)
            CALL POPREAL8ARRAY(chord, nsmax)
            CALL MAKESURF_B(isurf)
          ELSE
            CALL POPINTEGER4ARRAY(nj, nfmax)
            CALL POPINTEGER4ARRAY(jfrst, nfmax)
            CALL POPINTEGER4ARRAY(nvc, nfmax)
            CALL POPINTEGER4ARRAY(nvs, nfmax)
            CALL POPINTEGER4ARRAY(ijfrst, nsmax)
            CALL POPINTEGER4ARRAY(nvstrp, nsmax)
            CALL POPREAL8ARRAY(chord, nsmax)
            CALL MAKESURF_B(isurf)
          END IF
        END IF
      ENDDO
      END

C  Differentiation of makesurf in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: xyzscal xyztran addinc xyzles
C                chords aincs xasec sasec claf rle chord rle1 chord1
C                rle2 chord2 wstrip ainc ainc_g rv1 rv2 rv rc rs
C                dxv chordv slopev slopec dcontrol vhinge
C   with respect to varying inputs: xyzscal xyztran addinc xyzles
C                chords aincs xasec sasec claf rle chord rle1 chord1
C                rle2 chord2 wstrip ainc ainc_g rv1 rv2 rv rc rs
C                dxv chordv slopev slopec dcontrol vhinge
C***********************************************************************
C    Module:  amake.f
C 
C    Copyright (C) 2002 Mark Drela, Harold Youngren
C 
C    This program is free software; you can redistribute it and/or modify
C    it under the terms of the GNU General Public License as published by
C    the Free Software Foundation; either version 2 of the License, or
C    (at your option) any later version.
C
C    This program is distributed in the hope that it will be useful,
C    but WITHOUT ANY WARRANTY; without even the implied warranty of
C    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
C    GNU General Public License for more details.
C
C    You should have received a copy of the GNU General Public License
C    along with this program; if not, write to the Free Software
C    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
C***********************************************************************
C
      SUBROUTINE MAKESURF_B(isurf)
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
C
C
      REAL xyzlel(3), xyzler(3)
      REAL xyzlel_diff(3), xyzler_diff(3)
      INTEGER kcmax
      INTEGER ksmax
      PARAMETER (kcmax=50, ksmax=500)
      REAL xpt0(kcmax), xcp0(kcmax), xvr0(kcmax), xsr0(kcmax), xpt1(
     +     kcmax), xcp1(kcmax), xvr1(kcmax), xsr1(kcmax), xpt2(kcmax), 
     +     xcp2(kcmax), xvr2(kcmax), xsr2(kcmax)
      REAL xpt(kcmax), xcp(kcmax), xvr(kcmax), xsr(kcmax), ypt(ksmax), 
     +     ycp(ksmax)
      REAL xcp_diff(kcmax), xvr_diff(kcmax), ypt_diff(ksmax), ycp_diff(
     +     ksmax)
      REAL yzlen(ksmax)
      REAL yzlen_diff(ksmax)
      INTEGER iptloc(ksmax)
      INTEGER kpmax
      PARAMETER (kpmax=2*kcmax+2*ksmax)
      REAL fspace(kpmax)
C
      REAL chsinl_g(ngmax), chcosl_g(ngmax), chsinr_g(ngmax), chcosr_g(
     +     ngmax)
      REAL chsinl_g_diff(ngmax), chcosl_g_diff(ngmax), chsinr_g_diff(
     +     ngmax), chcosr_g_diff(ngmax)
      INTEGER isconl(ndmax), isconr(ndmax)
      REAL xled(ndmax), xted(ndmax), gainda(ndmax)
      REAL xled_diff(ndmax), xted_diff(ndmax), gainda_diff(ndmax)
      INTEGER idx_vor, idx_strip
      INTEGER isec
      REAL dy
      REAL dy_diff
      REAL dz
      REAL dz_diff
      INTRINSIC SQRT
      REAL dyzlen
      REAL dyzlen_diff
      INTEGER nvint
      INTEGER nspace
      INTEGER n
      INTEGER ivs
      INTEGER npt
      REAL yptloc
      INTEGER ipt
      REAL yptdel
      INTRINSIC ABS
      INTEGER ipt1
      INTEGER ipt2
      REAL ypt1
      REAL ypt1_diff
      REAL yscale
      REAL yscale_diff
      REAL width
      REAL width_diff
      REAL chordl
      REAL chordl_diff
      REAL chordr
      REAL chordr_diff
      REAL clafl
      REAL clafl_diff
      REAL clafr
      REAL clafr_diff
      REAL aincl
      REAL aincl_diff
      REAL aincr
      REAL aincr_diff
      REAL chsinl
      REAL chsinl_diff
      INTRINSIC SIN
      REAL chsinr
      REAL chsinr_diff
      REAL chcosl
      REAL chcosl_diff
      INTRINSIC COS
      REAL chcosr
      REAL chcosr_diff
      INTEGER iscon
      INTEGER isdes
      INTEGER iptl
      INTEGER iptr
      INTEGER nspan
      INTEGER ispan
      REAL f1
      REAL f1_diff
      REAL f2
      REAL f2_diff
      REAL fc
      REAL fc_diff
      REAL chsin
      REAL chsin_diff
      REAL chcos
      REAL chcos_diff
      INTRINSIC ATAN2
      REAL chsin_g
      REAL chsin_g_diff
      REAL chcos_g
      REAL chcos_g_diff
      INTEGER icl
      INTEGER icr
      REAL xhd
      REAL xhd_diff
      REAL vhx
      REAL vhx_diff
      REAL vhy
      REAL vhy_diff
      REAL vhz
      REAL vhz_diff
      REAL vsq
      REAL vsq_diff
      REAL vmod
      REAL vmod_diff
      INTEGER l
      INTEGER nsl
      INTEGER nsr
      REAL chordc
      REAL chordc_diff
      REAL clafc
      REAL clafc_diff
      INTEGER ivc
      REAL slopel
      REAL slopel_diff
      REAL dsdx
      REAL sloper
      REAL sloper_diff
      REAL dxoc
      REAL fracle
      REAL fracle_diff
      REAL fracte
      REAL fracte_diff
      INTRINSIC MAX
      INTRINSIC MIN
      REAL sum
      REAL wtot
      INTEGER jj
      INTEGER j
      REAL astrp
      INTEGER nst
      EXTERNAL STRIP
      REAL y1
      REAL y1_diff
      REAL y2
      REAL y2_diff
      REAL abs0
      REAL abs0_diff
      REAL(kind=avl_real) abs1
      REAL(kind=avl_real) abs1_diff
      REAL(kind=avl_real) abs2
      REAL(kind=avl_real) abs2_diff
      REAL temp_diff
      REAL tmp
      REAL tmp_diff
      REAL temp
      REAL temp_diff0
      REAL temp0
      REAL temp_diff1
      INTEGER ii1
      INTEGER ad_to
      INTEGER ad_to0
      INTEGER ad_count
      INTEGER i
      INTEGER branch
      INTEGER ii3
      INTEGER ii2
      INTEGER ad_to1
      INTEGER ad_to2
      INTEGER ad_to3
      INTEGER ad_from
      INTEGER ad_to4
      INTEGER ad_from0
      INTEGER ad_to5
      INTEGER ad_from1
      INTEGER ad_to6
      INTEGER ad_from2
      INTEGER ad_to7
      INTEGER ad_count0
      INTEGER i0
      INTEGER ad_to8
      INTEGER ad_to9
      INTEGER ad_to10
      INTEGER ad_to11
      INTEGER ad_to12
      INTEGER isurf
C
C
      IF (nsec(isurf) .LT. 2) THEN
        STOP
      ELSE
C
C
        IF (nvc(isurf) .GT. kcmax) nvc(isurf) = kcmax
C
        IF (nvs(isurf) .GT. ksmax) nvs(isurf) = ksmax
        IF (isurf .EQ. 1) THEN
          jfrst(isurf) = 1
        ELSE
          jfrst(isurf) = jfrst(isurf-1) + nj(isurf-1)
        END IF
        idx_strip = jfrst(isurf)
C
C-----------------------------------------------------------------
C---- section arc lengths of wing trace in y-z plane
        yzlen(1) = 0.
        DO isec=2,nsec(isurf)
          dy = xyzles(2, isec, isurf) - xyzles(2, isec-1, isurf)
          dz = xyzles(3, isec, isurf) - xyzles(3, isec-1, isurf)
          yzlen(isec) = yzlen(isec-1) + SQRT(dy*dy + dz*dz)
        ENDDO
        CALL PUSHINTEGER4(isec - 1)
C
C
        ! IF (nvs(isurf) .EQ. 0) THEN
        IF(LSURFSPACING(ISURF) .EQV. .FALSE.) THEN
C----- set spanwise spacing using spacing parameters for each section interval
          DO isec=1,nsec(isurf)-1
            nvs(isurf) = nvs(isurf) + nspans(isec, isurf)
          ENDDO
          IF (nvs(isurf) .GT. ksmax) THEN
            STOP
          ELSE
C
            nvs(isurf) = 0
            ypt(1) = yzlen(1)
            iptloc(1) = 1
            CALL PUSHINTEGER4(isec)
            ad_count = 1
C
            DO isec=1,nsec(isurf)-1
              dyzlen = yzlen(isec+1) - yzlen(isec)
C
              nvint = nspans(isec, isurf)
C
C------- set spanwise spacing array
              nspace = 2*nvint + 1
              IF (nspace .GT. kpmax) THEN
                GOTO 100
              ELSE
                CALL PUSHREAL8ARRAY(fspace, 1100)
                CALL SPACER(nspace, sspaces(isec, isurf), fspace)
C
                DO n=1,nvint
                  ivs = nvs(isurf) + n
                  ycp(ivs) = ypt(nvs(isurf)+1) + dyzlen*fspace(2*n)
                  tmp = ypt(nvs(isurf)+1) + dyzlen*fspace(2*n+1)
                  ypt(ivs+1) = tmp
                ENDDO
                CALL PUSHINTEGER4(n - 1)
                iptloc(isec+1) = nvs(isurf) + nvint + 1
C
                CALL PUSHINTEGER4(nvs(isurf))
                nvs(isurf) = nvs(isurf) + nvint
                CALL PUSHINTEGER4(isec)
                ad_count = ad_count + 1
              END IF
            ENDDO
            CALL PUSHCONTROL1B(0)
            CALL PUSHINTEGER4(ad_count)
            CALL PUSHCONTROL1B(0)
            GOTO 130
 100        CALL PUSHCONTROL1B(1)
            CALL PUSHINTEGER4(ad_count)
            STOP
          END IF
        ELSE
C
C----- set spanwise spacing using overall parameters NVS(ISURF), SSPACE
C
          nspace = 2*nvs(isurf) + 1
          IF (nspace .GT. kpmax) THEN
            STOP
          ELSE
            CALL SPACER(nspace, sspace(isurf), fspace)
C
            ypt(1) = yzlen(1)
            DO ivs=1,nvs(isurf)
              ycp(ivs) = yzlen(1) + (yzlen(nsec(isurf))-yzlen(1))*fspace
     +          (2*ivs)
              ypt(ivs+1) = yzlen(1) + (yzlen(nsec(isurf))-yzlen(1))*
     +          fspace(2*ivs+1)
            ENDDO
            CALL PUSHINTEGER4(ivs - 1)
C
            npt = nvs(isurf) + 1
C
C----- find node nearest each section
            DO isec=2,nsec(isurf)-1
              yptloc = 1.0e9
              iptloc(isec) = 1
              DO ipt=1,npt
                IF (yzlen(isec) - ypt(ipt) .GE. 0.) THEN
                  yptdel = yzlen(isec) - ypt(ipt)
                ELSE
                  yptdel = -(yzlen(isec)-ypt(ipt))
                END IF
                IF (yptdel .LT. yptloc) THEN
                  CALL PUSHCONTROL1B(1)
                  yptloc = yptdel
                  iptloc(isec) = ipt
                ELSE
                  CALL PUSHCONTROL1B(0)
                END IF
              ENDDO
              CALL PUSHINTEGER4(ipt - 1)
            ENDDO
            CALL PUSHINTEGER4(isec - 1)
            iptloc(1) = 1
            iptloc(nsec(isurf)) = npt
            CALL PUSHINTEGER4(isec)
            ad_count0 = 1
C
C----- fudge Glauert angles to make nodes match up exactly with interior sections
            DO isec=2,nsec(isurf)-1
              CALL PUSHINTEGER4(ipt1)
              ipt1 = iptloc(isec-1)
              CALL PUSHINTEGER4(ipt2)
              ipt2 = iptloc(isec)
              IF (ipt1 .EQ. ipt2) THEN
                GOTO 110
              ELSE
C
                CALL PUSHREAL8(ypt1)
                ypt1 = ypt(ipt1)
                CALL PUSHREAL8(yscale)
                yscale = (yzlen(isec)-yzlen(isec-1))/(ypt(ipt2)-ypt(ipt1
     +            ))
                ad_from = ipt1
                DO ipt=ad_from,ipt2-1
                  CALL PUSHREAL8(ypt(ipt))
                  ypt(ipt) = yzlen(isec-1) + yscale*(ypt(ipt)-ypt1)
                ENDDO
                CALL PUSHINTEGER4(ipt - 1)
                CALL PUSHINTEGER4(ad_from)
                ad_from0 = ipt1
                DO ivs=ad_from0,ipt2-1
                  CALL PUSHREAL8(ycp(ivs))
                  ycp(ivs) = yzlen(isec-1) + yscale*(ycp(ivs)-ypt1)
                ENDDO
                CALL PUSHINTEGER4(ivs - 1)
                CALL PUSHINTEGER4(ad_from0)
C
                CALL PUSHINTEGER4(ipt1)
                ipt1 = iptloc(isec)
                CALL PUSHINTEGER4(ipt2)
                ipt2 = iptloc(isec+1)
                IF (ipt1 .EQ. ipt2) THEN
                  GOTO 120
                ELSE
C
                  CALL PUSHREAL8(ypt1)
                  ypt1 = ypt(ipt1)
                  CALL PUSHREAL8(yscale)
                  yscale = (ypt(ipt2)-yzlen(isec))/(ypt(ipt2)-ypt(ipt1))
                  ad_from1 = ipt1
                  DO ipt=ad_from1,ipt2-1
                    CALL PUSHREAL8(ypt(ipt))
                    ypt(ipt) = yzlen(isec) + yscale*(ypt(ipt)-ypt1)
                  ENDDO
                  CALL PUSHINTEGER4(ipt - 1)
                  CALL PUSHINTEGER4(ad_from1)
                  ad_from2 = ipt1
                  DO ivs=ad_from2,ipt2-1
                    CALL PUSHREAL8(ycp(ivs))
                    ycp(ivs) = yzlen(isec) + yscale*(ycp(ivs)-ypt1)
                  ENDDO
                  CALL PUSHINTEGER4(ivs - 1)
                  CALL PUSHINTEGER4(ad_from2)
                  CALL PUSHINTEGER4(isec)
                  ad_count0 = ad_count0 + 1
                END IF
              END IF
            ENDDO
            CALL PUSHCONTROL2B(0)
            CALL PUSHINTEGER4(ad_count0)
            CALL PUSHCONTROL1B(1)
            GOTO 130
 110        CALL PUSHCONTROL2B(1)
            CALL PUSHINTEGER4(ad_count0)
            STOP
 120        CALL PUSHCONTROL2B(2)
            CALL PUSHINTEGER4(ad_count0)
            STOP
          END IF
        END IF
C
C
C
C====================================================
C---- define strips between input sections
C
C
 130    IF (ncontrol .GT. ndmax) THEN
          STOP
        ELSE IF (ndesign .GT. ngmax) THEN
C
          STOP
        ELSE
C
C---- go over section intervals
          DO isec=1,nsec(isurf)-1
            CALL PUSHREAL8(xyzlel(1))
            xyzlel(1) = xyzscal(1, isurf)*xyzles(1, isec, isurf) + 
     +        xyztran(1, isurf)
            CALL PUSHREAL8(xyzlel(2))
            xyzlel(2) = xyzscal(2, isurf)*xyzles(2, isec, isurf) + 
     +        xyztran(2, isurf)
            CALL PUSHREAL8(xyzlel(3))
            xyzlel(3) = xyzscal(3, isurf)*xyzles(3, isec, isurf) + 
     +        xyztran(3, isurf)
            CALL PUSHREAL8(xyzler(1))
            xyzler(1) = xyzscal(1, isurf)*xyzles(1, isec+1, isurf) + 
     +        xyztran(1, isurf)
            CALL PUSHREAL8(xyzler(2))
            xyzler(2) = xyzscal(2, isurf)*xyzles(2, isec+1, isurf) + 
     +        xyztran(2, isurf)
            CALL PUSHREAL8(xyzler(3))
            xyzler(3) = xyzscal(3, isurf)*xyzles(3, isec+1, isurf) + 
     +        xyztran(3, isurf)
C
            CALL PUSHREAL8(width)
            width = SQRT((xyzler(2)-xyzlel(2))**2 + (xyzler(3)-xyzlel(3)
     +        )**2)
C
            chordl = xyzscal(1, isurf)*chords(isec, isurf)
            chordr = xyzscal(1, isurf)*chords(isec+1, isurf)
C
            clafl = claf(isec, isurf)
            clafr = claf(isec+1, isurf)
C
C------ removed CLAF influence on zero-lift angle  (MD  21 Mar 08)
            aincl = aincs(isec, isurf)*dtr + addinc(isurf)*dtr
            aincr = aincs(isec+1, isurf)*dtr + addinc(isurf)*dtr
Cc      AINCL = AINCS(ISEC)   + ADDINC(ISURF) - 4.0*DTR*(CLAFL-1.0)
Cc      AINCR = AINCS(ISEC+1) + ADDINC(ISURF) - 4.0*DTR*(CLAFR-1.0)
C
            CALL PUSHREAL8(chsinl)
            chsinl = chordl*SIN(aincl)
            CALL PUSHREAL8(chsinr)
            chsinr = chordr*SIN(aincr)
            CALL PUSHREAL8(chcosl)
            chcosl = chordl*COS(aincl)
            CALL PUSHREAL8(chcosr)
            chcosr = chordr*COS(aincr)
C
C------ set control-declaration lines for each control variable
            DO n=1,ncontrol
              isconl(n) = 0
              isconr(n) = 0
              DO iscon=1,nscon(isec, isurf)
                IF (icontd(iscon, isec, isurf) .EQ. n) THEN
                  CALL PUSHCONTROL1B(1)
                  isconl(n) = iscon
                ELSE
                  CALL PUSHCONTROL1B(0)
                END IF
              ENDDO
              CALL PUSHINTEGER4(iscon - 1)
              DO iscon=1,nscon(isec+1, isurf)
                IF (icontd(iscon, isec+1, isurf) .EQ. n) THEN
                  CALL PUSHCONTROL1B(1)
                  isconr(n) = iscon
                ELSE
                  CALL PUSHCONTROL1B(0)
                END IF
              ENDDO
              CALL PUSHINTEGER4(iscon - 1)
            ENDDO
C
C------ set design-variable sensitivities of CHSIN and CHCOS
            DO n=1,ndesign
              CALL PUSHREAL8(chsinl_g(n))
              chsinl_g(n) = 0.
              CALL PUSHREAL8(chsinr_g(n))
              chsinr_g(n) = 0.
              CALL PUSHREAL8(chcosl_g(n))
              chcosl_g(n) = 0.
              CALL PUSHREAL8(chcosr_g(n))
              chcosr_g(n) = 0.
C
              DO isdes=1,nsdes(isec, isurf)
                IF (idestd(isdes, isec, isurf) .EQ. n) THEN
                  chsinl_g(n) = chcosl*gaing(isdes, isec, isurf)*dtr
                  chcosl_g(n) = -(chsinl*gaing(isdes, isec, isurf)*dtr)
                  CALL PUSHCONTROL1B(1)
                ELSE
                  CALL PUSHCONTROL1B(0)
                END IF
              ENDDO
              CALL PUSHINTEGER4(isdes - 1)
C
              DO isdes=1,nsdes(isec+1, isurf)
                IF (idestd(isdes, isec+1, isurf) .EQ. n) THEN
                  chsinr_g(n) = chcosr*gaing(isdes, isec+1, isurf)*dtr
                  chcosr_g(n) = -(chsinr*gaing(isdes, isec+1, isurf)*dtr
     +              )
                  CALL PUSHCONTROL1B(1)
                ELSE
                  CALL PUSHCONTROL1B(0)
                END IF
              ENDDO
              CALL PUSHINTEGER4(isdes - 1)
            ENDDO
C
C
C------ go over chord strips
            CALL PUSHINTEGER4(iptl)
            iptl = iptloc(isec)
            CALL PUSHINTEGER4(iptr)
            iptr = iptloc(isec+1)
            nspan = iptr - iptl
C
            DO ispan=1,nspan
C-------- define left and right edges of vortex strip
C-          note that incidence angle is set by ATAN of chord projections,
C-          not by linear interpolation of AINC
              CALL PUSHINTEGER4(ipt1)
              ipt1 = iptl + ispan - 1
              CALL PUSHINTEGER4(ipt2)
              ipt2 = iptl + ispan
              ivs = iptl + ispan - 1
              f1 = (ypt(ipt1)-ypt(iptl))/(ypt(iptr)-ypt(iptl))
              f2 = (ypt(ipt2)-ypt(iptl))/(ypt(iptr)-ypt(iptl))
C     NSTRIP = NSTRIP + 1
C     NJ(ISURF) = NJ(ISURF) + 1
              fc = (ycp(ivs)-ypt(iptl))/(ypt(iptr)-ypt(iptl))
C
C-------- store strip in global data arrays
C
C
C
              chord(idx_strip) = (1.0-fc)*chordl + fc*chordr
              IF (f2 - f1 .GE. 0.) THEN
                CALL PUSHREAL8(abs0)
                abs0 = f2 - f1
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHREAL8(abs0)
                abs0 = -(f2-f1)
                CALL PUSHCONTROL1B(1)
              END IF
C
C
              CALL PUSHREAL8(chsin)
              chsin = chsinl + fc*(chsinr-chsinl)
              CALL PUSHREAL8(chcos)
              chcos = chcosl + fc*(chcosr-chcosl)
C
              DO n=1,ncontrol
                CALL PUSHINTEGER4(icl)
                icl = isconl(n)
                CALL PUSHINTEGER4(icr)
                icr = isconr(n)
C
                IF (icl .EQ. 0 .OR. icr .EQ. 0) THEN
C----------- no control effect here
                  CALL PUSHREAL8(gainda(n))
                  gainda(n) = 0.
                  CALL PUSHREAL8(xled(n))
                  xled(n) = 0.
                  CALL PUSHREAL8(xted(n))
                  xted(n) = 0.
C
C
C
C
                  CALL PUSHCONTROL1B(1)
                ELSE
C----------- control variable # N is active here
                  CALL PUSHREAL8(gainda(n))
                  gainda(n) = gaind(icl, isec, isurf)*(1.0-fc) + gaind(
     +              icr, isec+1, isurf)*fc
C
                  xhd = chordl*xhinged(icl, isec, isurf)*(1.0-fc) + 
     +              chordr*xhinged(icr, isec+1, isurf)*fc
                  IF (xhd .GE. 0.0) THEN
C------------ TE control surface, with hinge at XHD
                    CALL PUSHREAL8(xled(n))
                    xled(n) = xhd
                    CALL PUSHREAL8(xted(n))
                    xted(n) = chord(idx_strip)
                    CALL PUSHCONTROL1B(0)
                  ELSE
C------------ LE control surface, with hinge at -XHD
                    CALL PUSHREAL8(xled(n))
                    xled(n) = 0.0
                    CALL PUSHREAL8(xted(n))
                    xted(n) = -xhd
                    CALL PUSHCONTROL1B(1)
                  END IF
C
                  CALL PUSHREAL8(vhx)
                  vhx = vhinged(1, icl, isec, isurf)*xyzscal(1, isurf)
                  CALL PUSHREAL8(vhy)
                  vhy = vhinged(2, icl, isec, isurf)*xyzscal(2, isurf)
                  CALL PUSHREAL8(vhz)
                  vhz = vhinged(3, icl, isec, isurf)*xyzscal(3, isurf)
                  CALL PUSHREAL8(vsq)
                  vsq = vhx**2 + vhy**2 + vhz**2
                  IF (vsq .EQ. 0.0) THEN
                    IF (chordr*xhinged(icr, isec+1, isurf) .GE. 0.) THEN
                      abs1 = chordr*xhinged(icr, isec+1, isurf)
                      CALL PUSHCONTROL1B(1)
                    ELSE
                      abs1 = -(chordr*xhinged(icr, isec+1, isurf))
                      CALL PUSHCONTROL1B(0)
                    END IF
                    IF (chordl*xhinged(icl, isec, isurf) .GE. 0.) THEN
                      abs2 = chordl*xhinged(icl, isec, isurf)
                      CALL PUSHCONTROL1B(0)
                    ELSE
                      abs2 = -(chordl*xhinged(icl, isec, isurf))
                      CALL PUSHCONTROL1B(1)
                    END IF
C------------ default: set hinge vector along hingeline
                    vhx = xyzles(1, isec+1, isurf) + abs1 - xyzles(1, 
     +                isec, isurf) - abs2
                    vhy = xyzles(2, isec+1, isurf) - xyzles(2, isec, 
     +                isurf)
                    vhz = xyzles(3, isec+1, isurf) - xyzles(3, isec, 
     +                isurf)
                    CALL PUSHREAL8(vhx)
                    vhx = vhx*xyzscal(1, isurf)
                    CALL PUSHREAL8(vhy)
                    vhy = vhy*xyzscal(2, isurf)
                    CALL PUSHREAL8(vhz)
                    vhz = vhz*xyzscal(3, isurf)
                    vsq = vhx**2 + vhy**2 + vhz**2
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    CALL PUSHCONTROL1B(1)
                  END IF
C
                  CALL PUSHREAL8(vmod)
                  vmod = SQRT(vsq)
C
C
                  CALL PUSHCONTROL1B(0)
                END IF
              ENDDO
C--- If the min drag is zero flag the strip as no-viscous data
C     IJFRST(idx_strip) = NVOR + 1
C
C
              IF (idx_strip .EQ. 1) THEN
                ijfrst(idx_strip) = 1
              ELSE
                ijfrst(idx_strip) = ijfrst(idx_strip-1) + nvstrp(
     +            idx_strip-1)
              END IF
              nvstrp(idx_strip) = nvc(isurf)
C           write(*,*) 'IJFRST(idx_strip)', IJFRST(idx_strip),
C      &               'NVSTRP(idx_strip)', IJFRST(idx_strip - 1) + NVC(ISURF)
C
C
              nsl = nasec(isec, isurf)
              nsr = nasec(isec+1, isurf)
C
              CALL PUSHREAL8(chordc)
              chordc = chord(idx_strip)
C
              clafc = (1.-fc)*(chordl/chordc)*clafl + fc*(chordr/chordc)
     +          *clafr
C
C-------- set chordwise spacing fraction arrays
              CALL PUSHREAL8ARRAY(xcp, 50)
              CALL PUSHREAL8ARRAY(xsr, 50)
              CALL PUSHREAL8ARRAY(xvr, 50)
              CALL CSPACER(nvc(isurf), cspace(isurf), clafc, xpt, xvr, 
     +                     xsr, xcp)
C
C-------- go over vortices in this strip
              idx_vor = ijfrst(idx_strip)
C NVOR = NVOR + 1
              DO ivc=1,nvc(isurf)
C
C
C
C
C
C
                CALL PUSHREAL8(slopel)
                CALL AKIMA(xasec(1, isec, isurf), sasec(1, isec, isurf)
     +                     , nsl, xcp(ivc), slopel, dsdx)
                CALL PUSHREAL8(sloper)
                CALL AKIMA(xasec(1, isec+1, isurf), sasec(1, isec+1, 
     +                     isurf), nsr, xcp(ivc), sloper, dsdx)
C
                CALL PUSHREAL8(slopel)
                CALL AKIMA(xasec(1, isec, isurf), sasec(1, isec, isurf)
     +                     , nsl, xvr(ivc), slopel, dsdx)
                CALL PUSHREAL8(sloper)
                CALL AKIMA(xasec(1, isec+1, isurf), sasec(1, isec+1, 
     +                     isurf), nsr, xvr(ivc), sloper, dsdx)
C
                CALL PUSHREAL8(dxoc)
                dxoc = xpt(ivc+1) - xpt(ivc)
C
C
C---------- element inherits alpha,beta flag from surface
C
                DO n=1,ncontrol
C------------ scale control gain by factor 0..1, (fraction of element on control surface)
                  CALL PUSHREAL8(fracle)
                  fracle = (xled(n)/chordc-xpt(ivc))/dxoc
                  CALL PUSHREAL8(fracte)
                  fracte = (xted(n)/chordc-xpt(ivc))/dxoc
                  IF (0.0 .LT. fracle) THEN
                    y1 = fracle
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    y1 = 0.0
                    CALL PUSHCONTROL1B(1)
                  END IF
                  IF (1.0 .GT. y1) THEN
                    fracle = y1
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    fracle = 1.0
                    CALL PUSHCONTROL1B(1)
                  END IF
                  IF (0.0 .LT. fracte) THEN
                    y2 = fracte
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    y2 = 0.0
                    CALL PUSHCONTROL1B(1)
                  END IF
                  IF (1.0 .GT. y2) THEN
                    fracte = y2
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    fracte = 1.0
                    CALL PUSHCONTROL1B(1)
                  END IF
                ENDDO
C
C---------- TE control point used only if surface sheds a wake
                CALL PUSHINTEGER4(idx_vor)
                idx_vor = idx_vor + 1
              ENDDO
C
C           
              CALL PUSHINTEGER4(idx_strip)
              idx_strip = idx_strip + 1
            ENDDO
            CALL PUSHINTEGER4(ispan - 1)
          ENDDO
          DO ii1=1,3
            xyzler_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,kcmax
            xcp_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ngmax
            chcosl_g_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ngmax
            chsinr_g_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ndmax
            xted_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ndmax
            xled_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ngmax
            chsinl_g_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ndmax
            gainda_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ksmax
            ycp_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ksmax
            ypt_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ngmax
            chcosr_g_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,3
            xyzlel_diff(ii1) = 0.D0
          ENDDO
          DO isec=nsec(isurf)-1,1,-1
            clafr = claf(isec+1, isurf)
            chordl = xyzscal(1, isurf)*chords(isec, isurf)
            chordr = xyzscal(1, isurf)*chords(isec+1, isurf)
            clafl = claf(isec, isurf)
            clafr_diff = 0.D0
            chordl_diff = 0.D0
            chordr_diff = 0.D0
            chsinl_diff = 0.D0
            chsinr_diff = 0.D0
            width_diff = 0.D0
            chcosl_diff = 0.D0
            clafl_diff = 0.D0
            chcosr_diff = 0.D0
            CALL POPINTEGER4(ad_to12)
            DO ispan=ad_to12,1,-1
              CALL POPINTEGER4(idx_strip)
              ivs = iptl + ispan - 1
              fc = (ycp(ivs)-ypt(iptl))/(ypt(iptr)-ypt(iptl))
              nsl = nasec(isec, isurf)
              nsr = nasec(isec+1, isurf)
              fc_diff = 0.D0
              chordc_diff = 0.D0
              DO ivc=nvc(isurf),1,-1
                CALL POPINTEGER4(idx_vor)
                DO n=ncontrol,1,-1
                  gainda_diff(n) = gainda_diff(n) + (fracte-fracle)*
     +              dcontrol_diff(idx_vor, n)
                  fracte_diff = gainda(n)*dcontrol_diff(idx_vor, n)
                  fracle_diff = -(gainda(n)*dcontrol_diff(idx_vor, n))
                  dcontrol_diff(idx_vor, n) = 0.D0
                  CALL POPCONTROL1B(branch)
                  IF (branch .EQ. 0) THEN
                    y2_diff = fracte_diff
                  ELSE
                    y2_diff = 0.D0
                  END IF
                  CALL POPCONTROL1B(branch)
                  IF (branch .EQ. 0) THEN
                    fracte_diff = y2_diff
                  ELSE
                    fracte_diff = 0.D0
                  END IF
                  CALL POPCONTROL1B(branch)
                  IF (branch .EQ. 0) THEN
                    y1_diff = fracle_diff
                  ELSE
                    y1_diff = 0.D0
                  END IF
                  CALL POPCONTROL1B(branch)
                  IF (branch .EQ. 0) THEN
                    fracle_diff = y1_diff
                  ELSE
                    fracle_diff = 0.D0
                  END IF
                  CALL POPREAL8(fracte)
                  temp_diff1 = fracte_diff/(chordc*dxoc)
                  xted_diff(n) = xted_diff(n) + temp_diff1
                  chordc_diff = chordc_diff - xted(n)*temp_diff1/chordc
                  CALL POPREAL8(fracle)
                  temp_diff1 = fracle_diff/(chordc*dxoc)
                  xled_diff(n) = xled_diff(n) + temp_diff1
                  chordc_diff = chordc_diff - xled(n)*temp_diff1/chordc
                ENDDO
                temp_diff0 = fc*chordr*slopev_diff(idx_vor)/chordc
                temp_diff1 = chordl*slopel*slopev_diff(idx_vor)/chordc
                temp = sloper/chordc
                temp0 = (-fc+1.)/chordc
                chordc_diff = chordc_diff + chordv_diff(idx_vor) + dxoc*
     +            dxv_diff(idx_vor) - temp*temp_diff0 - temp0*temp_diff1
                chordv_diff(idx_vor) = 0.D0
                dxv_diff(idx_vor) = 0.D0
                CALL POPREAL8(dxoc)
                chordl_diff = chordl_diff + slopel*temp0*slopev_diff(
     +            idx_vor)
                slopel_diff = chordl*temp0*slopev_diff(idx_vor)
                fc_diff = fc_diff + chordr*temp*slopev_diff(idx_vor) - 
     +            temp_diff1
                chordr_diff = chordr_diff + fc*temp*slopev_diff(idx_vor)
                slopev_diff(idx_vor) = 0.D0
                sloper_diff = temp_diff0
                CALL POPREAL8(sloper)
                DO ii1=1,kcmax
                  xvr_diff(ii1) = 0.D0
                ENDDO
                CALL AKIMA_B(xasec(1, isec+1, isurf), xasec_diff(1, isec
     +                       +1, isurf), sasec(1, isec+1, isurf), 
     +                       sasec_diff(1, isec+1, isurf), nsr, xvr(ivc)
     +                       , xvr_diff(ivc), sloper, sloper_diff, dsdx)
                CALL POPREAL8(slopel)
                DO ii1=1,kcmax
                  xvr_diff(ii1) = 0.D0
                ENDDO
                CALL AKIMA_B(xasec(1, isec, isurf), xasec_diff(1, isec, 
     +                       isurf), sasec(1, isec, isurf), sasec_diff(1
     +                       , isec, isurf), nsl, xvr(ivc), xvr_diff(ivc
     +                       ), slopel, slopel_diff, dsdx)
                temp0 = (-fc+1.)/chordc
                temp = sloper/chordc
                temp_diff1 = chordl*slopel*slopec_diff(idx_vor)/chordc
                chordl_diff = chordl_diff + slopel*temp0*slopec_diff(
     +            idx_vor)
                slopel_diff = chordl*temp0*slopec_diff(idx_vor)
                fc_diff = fc_diff + chordr*temp*slopec_diff(idx_vor) - 
     +            temp_diff1
                chordr_diff = chordr_diff + fc*temp*slopec_diff(idx_vor)
                temp_diff0 = fc*chordr*slopec_diff(idx_vor)/chordc
                slopec_diff(idx_vor) = 0.D0
                sloper_diff = temp_diff0
                chordc_diff = chordc_diff + xsr(ivc)*rs_diff(1, idx_vor)
     +            - temp*temp_diff0 - temp0*temp_diff1 + xcp(ivc)*
     +            rc_diff(1, idx_vor) + xvr(ivc)*rv_diff(1, idx_vor)
                CALL POPREAL8(sloper)
                CALL AKIMA_B(xasec(1, isec+1, isurf), xasec_diff(1, isec
     +                       +1, isurf), sasec(1, isec+1, isurf), 
     +                       sasec_diff(1, isec+1, isurf), nsr, xcp(ivc)
     +                       , xcp_diff(ivc), sloper, sloper_diff, dsdx)
                CALL POPREAL8(slopel)
                CALL AKIMA_B(xasec(1, isec, isurf), xasec_diff(1, isec, 
     +                       isurf), sasec(1, isec, isurf), sasec_diff(1
     +                       , isec, isurf), nsl, xcp(ivc), xcp_diff(ivc
     +                       ), slopel, slopel_diff, dsdx)
                rle_diff(3, idx_strip) = rle_diff(3, idx_strip) + 
     +            rs_diff(3, idx_vor) + rc_diff(3, idx_vor) + rv_diff(3
     +            , idx_vor)
                rs_diff(3, idx_vor) = 0.D0
                rle_diff(2, idx_strip) = rle_diff(2, idx_strip) + 
     +            rs_diff(2, idx_vor) + rc_diff(2, idx_vor) + rv_diff(2
     +            , idx_vor)
                rs_diff(2, idx_vor) = 0.D0
                rle_diff(1, idx_strip) = rle_diff(1, idx_strip) + 
     +            rs_diff(1, idx_vor) + rc_diff(1, idx_vor) + rv_diff(1
     +            , idx_vor)
                rs_diff(1, idx_vor) = 0.D0
                rc_diff(3, idx_vor) = 0.D0
                rc_diff(2, idx_vor) = 0.D0
                xcp_diff(ivc) = xcp_diff(ivc) + chordc*rc_diff(1, 
     +            idx_vor)
                rc_diff(1, idx_vor) = 0.D0
                rv_diff(3, idx_vor) = 0.D0
                rv_diff(2, idx_vor) = 0.D0
                rv_diff(1, idx_vor) = 0.D0
                rle2_diff(3, idx_strip) = rle2_diff(3, idx_strip) + 
     +            rv2_diff(3, idx_vor)
                rv2_diff(3, idx_vor) = 0.D0
                rle2_diff(2, idx_strip) = rle2_diff(2, idx_strip) + 
     +            rv2_diff(2, idx_vor)
                rv2_diff(2, idx_vor) = 0.D0
                rle2_diff(1, idx_strip) = rle2_diff(1, idx_strip) + 
     +            rv2_diff(1, idx_vor)
                chord2_diff(idx_strip) = chord2_diff(idx_strip) + xvr(
     +            ivc)*rv2_diff(1, idx_vor)
                rv2_diff(1, idx_vor) = 0.D0
                rle1_diff(3, idx_strip) = rle1_diff(3, idx_strip) + 
     +            rv1_diff(3, idx_vor)
                rv1_diff(3, idx_vor) = 0.D0
                rle1_diff(2, idx_strip) = rle1_diff(2, idx_strip) + 
     +            rv1_diff(2, idx_vor)
                rv1_diff(2, idx_vor) = 0.D0
                rle1_diff(1, idx_strip) = rle1_diff(1, idx_strip) + 
     +            rv1_diff(1, idx_vor)
                chord1_diff(idx_strip) = chord1_diff(idx_strip) + xvr(
     +            ivc)*rv1_diff(1, idx_vor)
                rv1_diff(1, idx_vor) = 0.D0
              ENDDO
              clafc = (1.-fc)*(chordl/chordc)*clafl + fc*(chordr/chordc)
     +          *clafr
              CALL POPREAL8ARRAY(xvr, 50)
              CALL POPREAL8ARRAY(xsr, 50)
              CALL POPREAL8ARRAY(xcp, 50)
              CALL CSPACER_B(nvc(isurf), cspace(isurf), clafc, 
     +                       clafc_diff, xpt, xvr, xsr, xcp, xcp_diff)
              temp0 = (-fc+1.)/chordc
              temp = clafr/chordc
              temp_diff1 = chordl*clafl*clafc_diff/chordc
              chordl_diff = chordl_diff + clafl*temp0*clafc_diff
              clafl_diff = clafl_diff + chordl*temp0*clafc_diff
              fc_diff = fc_diff + chordr*temp*clafc_diff - temp_diff1
              chordr_diff = chordr_diff + fc*temp*clafc_diff
              temp_diff0 = fc*chordr*clafc_diff/chordc
              clafr_diff = clafr_diff + temp_diff0
              chordc_diff = chordc_diff - temp*temp_diff0 - temp0*
     +          temp_diff1
              CALL POPREAL8(chordc)
              chord_diff(idx_strip) = chord_diff(idx_strip) + 
     +          chordc_diff
              DO n=ncontrol,1,-1
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  vhz_diff = vhinge_diff(3, idx_strip, n)/vmod
                  vmod_diff = -(vhz*vhinge_diff(3, idx_strip, n)/vmod**2
     +              ) - vhy*vhinge_diff(2, idx_strip, n)/vmod**2 - vhx*
     +              vhinge_diff(1, idx_strip, n)/vmod**2
                  vhinge_diff(3, idx_strip, n) = 0.D0
                  vhy_diff = vhinge_diff(2, idx_strip, n)/vmod
                  vhinge_diff(2, idx_strip, n) = 0.D0
                  vhx_diff = vhinge_diff(1, idx_strip, n)/vmod
                  vhinge_diff(1, idx_strip, n) = 0.D0
                  CALL POPREAL8(vmod)
                  IF (vsq .EQ. 0.D0) THEN
                    vsq_diff = 0.D0
                  ELSE
                    vsq_diff = vmod_diff/(2.0*SQRT(vsq))
                  END IF
                  CALL POPCONTROL1B(branch)
                  IF (branch .EQ. 0) THEN
                    vhx_diff = vhx_diff + 2*vhx*vsq_diff
                    vhy_diff = vhy_diff + 2*vhy*vsq_diff
                    vhz_diff = vhz_diff + 2*vhz*vsq_diff
                    CALL POPREAL8(vhz)
                    xyzscal_diff(3, isurf) = xyzscal_diff(3, isurf) + 
     +                vhz*vhz_diff
                    vhz_diff = xyzscal(3, isurf)*vhz_diff
                    CALL POPREAL8(vhy)
                    xyzscal_diff(2, isurf) = xyzscal_diff(2, isurf) + 
     +                vhy*vhy_diff
                    vhy_diff = xyzscal(2, isurf)*vhy_diff
                    CALL POPREAL8(vhx)
                    xyzscal_diff(1, isurf) = xyzscal_diff(1, isurf) + 
     +                vhx*vhx_diff
                    vhx_diff = xyzscal(1, isurf)*vhx_diff
                    xyzles_diff(3, isec+1, isurf) = xyzles_diff(3, isec+
     +                1, isurf) + vhz_diff
                    xyzles_diff(3, isec, isurf) = xyzles_diff(3, isec, 
     +                isurf) - vhz_diff
                    xyzles_diff(2, isec+1, isurf) = xyzles_diff(2, isec+
     +                1, isurf) + vhy_diff
                    xyzles_diff(2, isec, isurf) = xyzles_diff(2, isec, 
     +                isurf) - vhy_diff
                    xyzles_diff(1, isec+1, isurf) = xyzles_diff(1, isec+
     +                1, isurf) + vhx_diff
                    abs1_diff = vhx_diff
                    xyzles_diff(1, isec, isurf) = xyzles_diff(1, isec, 
     +                isurf) - vhx_diff
                    abs2_diff = -vhx_diff
                    vhy = vhinged(2, icl, isec, isurf)*xyzscal(2, isurf)
                    vhz = vhinged(3, icl, isec, isurf)*xyzscal(3, isurf)
                    vhx = vhinged(1, icl, isec, isurf)*xyzscal(1, isurf)
                    CALL POPCONTROL1B(branch)
                    IF (branch .EQ. 0) THEN
                      chordl_diff = chordl_diff + xhinged(icl, isec, 
     +                  isurf)*abs2_diff
                    ELSE
                      chordl_diff = chordl_diff - xhinged(icl, isec, 
     +                  isurf)*abs2_diff
                    END IF
                    CALL POPCONTROL1B(branch)
                    IF (branch .EQ. 0) THEN
                      chordr_diff = chordr_diff - xhinged(icr, isec+1, 
     +                  isurf)*abs1_diff
                    ELSE
                      chordr_diff = chordr_diff + xhinged(icr, isec+1, 
     +                  isurf)*abs1_diff
                    END IF
                    vhx_diff = 0.D0
                    vhy_diff = 0.D0
                    vhz_diff = 0.D0
                    vsq_diff = 0.D0
                  END IF
                  CALL POPREAL8(vsq)
                  vhx_diff = vhx_diff + 2*vhx*vsq_diff
                  vhy_diff = vhy_diff + 2*vhy*vsq_diff
                  vhz_diff = vhz_diff + 2*vhz*vsq_diff
                  CALL POPREAL8(vhz)
                  xyzscal_diff(3, isurf) = xyzscal_diff(3, isurf) + 
     +              vhinged(3, icl, isec, isurf)*vhz_diff
                  CALL POPREAL8(vhy)
                  xyzscal_diff(2, isurf) = xyzscal_diff(2, isurf) + 
     +              vhinged(2, icl, isec, isurf)*vhy_diff
                  CALL POPREAL8(vhx)
                  xyzscal_diff(1, isurf) = xyzscal_diff(1, isurf) + 
     +              vhinged(1, icl, isec, isurf)*vhx_diff
                  CALL POPCONTROL1B(branch)
                  IF (branch .EQ. 0) THEN
                    CALL POPREAL8(xted(n))
                    chord_diff(idx_strip) = chord_diff(idx_strip) + 
     +                xted_diff(n)
                    xted_diff(n) = 0.D0
                    CALL POPREAL8(xled(n))
                    xhd_diff = xled_diff(n)
                    xled_diff(n) = 0.D0
                  ELSE
                    CALL POPREAL8(xted(n))
                    xhd_diff = -xted_diff(n)
                    xted_diff(n) = 0.D0
                    CALL POPREAL8(xled(n))
                    xled_diff(n) = 0.D0
                  END IF
                  temp_diff1 = xhinged(icl, isec, isurf)*xhd_diff
                  temp_diff0 = xhinged(icr, isec+1, isurf)*xhd_diff
                  chordr_diff = chordr_diff + fc*temp_diff0
                  fc_diff = fc_diff + chordr*temp_diff0 + (gaind(icr, 
     +              isec+1, isurf)-gaind(icl, isec, isurf))*gainda_diff(
     +              n) - chordl*temp_diff1
                  chordl_diff = chordl_diff + (1.0-fc)*temp_diff1
                  CALL POPREAL8(gainda(n))
                  gainda_diff(n) = 0.D0
                ELSE
                  vhinge_diff(3, idx_strip, n) = 0.D0
                  vhinge_diff(2, idx_strip, n) = 0.D0
                  vhinge_diff(1, idx_strip, n) = 0.D0
                  CALL POPREAL8(xted(n))
                  xted_diff(n) = 0.D0
                  CALL POPREAL8(xled(n))
                  xled_diff(n) = 0.D0
                  CALL POPREAL8(gainda(n))
                  gainda_diff(n) = 0.D0
                END IF
                CALL POPINTEGER4(icr)
                CALL POPINTEGER4(icl)
              ENDDO
              chsin_diff = 0.D0
              chcos_diff = 0.D0
              DO n=ndesign,1,-1
                chsin_g = (1.0-fc)*chsinl_g(n) + fc*chsinr_g(n)
                chcos_g = (1.0-fc)*chcosl_g(n) + fc*chcosr_g(n)
                temp0 = chsin*chsin + chcos*chcos
                temp_diff0 = ainc_g_diff(idx_strip, n)/temp0
                ainc_g_diff(idx_strip, n) = 0.D0
                chsin_g_diff = chcos*temp_diff0
                chcos_g_diff = -(chsin*temp_diff0)
                temp_diff1 = -((chcos*chsin_g-chsin*chcos_g)*temp_diff0/
     +            temp0)
                chcos_diff = chcos_diff + chsin_g*temp_diff0 + 2*chcos*
     +            temp_diff1
                chsin_diff = chsin_diff + 2*chsin*temp_diff1 - chcos_g*
     +            temp_diff0
                fc_diff = fc_diff + (chcosr_g(n)-chcosl_g(n))*
     +            chcos_g_diff + (chsinr_g(n)-chsinl_g(n))*chsin_g_diff
                chcosl_g_diff(n) = chcosl_g_diff(n) + (1.0-fc)*
     +            chcos_g_diff
                chcosr_g_diff(n) = chcosr_g_diff(n) + fc*chcos_g_diff
                chsinl_g_diff(n) = chsinl_g_diff(n) + (1.0-fc)*
     +            chsin_g_diff
                chsinr_g_diff(n) = chsinr_g_diff(n) + fc*chsin_g_diff
              ENDDO
              chsin_diff = chsin_diff + chcos*ainc_diff(idx_strip)/(
     +          chsin**2+chcos**2)
              chcos_diff = chcos_diff - chsin*ainc_diff(idx_strip)/(
     +          chsin**2+chcos**2)
              ainc_diff(idx_strip) = 0.D0
              CALL POPREAL8(chcos)
              chcosl_diff = chcosl_diff + (1.0-fc)*chcos_diff
              fc_diff = fc_diff + (chcosr-chcosl)*chcos_diff + (chsinr-
     +          chsinl)*chsin_diff
              chcosr_diff = chcosr_diff + fc*chcos_diff
              CALL POPREAL8(chsin)
              chsinl_diff = chsinl_diff + (1.0-fc)*chsin_diff
              chsinr_diff = chsinr_diff + fc*chsin_diff
              abs0_diff = width*wstrip_diff(idx_strip)
              width_diff = width_diff + abs0*wstrip_diff(idx_strip)
              wstrip_diff(idx_strip) = 0.D0
              ipt1 = iptl + ispan - 1
              f1 = (ypt(ipt1)-ypt(iptl))/(ypt(iptr)-ypt(iptl))
              ipt2 = iptl + ispan
              f2 = (ypt(ipt2)-ypt(iptl))/(ypt(iptr)-ypt(iptl))
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                CALL POPREAL8(abs0)
                f2_diff = abs0_diff
                f1_diff = -abs0_diff
              ELSE
                CALL POPREAL8(abs0)
                f1_diff = abs0_diff
                f2_diff = -abs0_diff
              END IF
              fc_diff = fc_diff + (chordr-chordl)*chord_diff(idx_strip) 
     +          + (xyzler(3)-xyzlel(3))*rle_diff(3, idx_strip) + (xyzler
     +          (2)-xyzlel(2))*rle_diff(2, idx_strip) + (xyzler(1)-
     +          xyzlel(1))*rle_diff(1, idx_strip)
              chordl_diff = chordl_diff + (1.0-fc)*chord_diff(idx_strip)
     +          + (1.0-f2)*chord2_diff(idx_strip) + (1.0-f1)*chord1_diff
     +          (idx_strip)
              chordr_diff = chordr_diff + fc*chord_diff(idx_strip) + f2*
     +          chord2_diff(idx_strip) + f1*chord1_diff(idx_strip)
              chord_diff(idx_strip) = 0.D0
              xyzlel_diff(3) = xyzlel_diff(3) + (1.0-fc)*rle_diff(3, 
     +          idx_strip) + (1.0-f2)*rle2_diff(3, idx_strip) + (1.0-f1)
     +          *rle1_diff(3, idx_strip)
              xyzler_diff(3) = xyzler_diff(3) + fc*rle_diff(3, idx_strip
     +          ) + f2*rle2_diff(3, idx_strip) + f1*rle1_diff(3, 
     +          idx_strip)
              rle_diff(3, idx_strip) = 0.D0
              xyzlel_diff(2) = xyzlel_diff(2) + (1.0-fc)*rle_diff(2, 
     +          idx_strip) + (1.0-f2)*rle2_diff(2, idx_strip) + (1.0-f1)
     +          *rle1_diff(2, idx_strip)
              xyzler_diff(2) = xyzler_diff(2) + fc*rle_diff(2, idx_strip
     +          ) + f2*rle2_diff(2, idx_strip) + f1*rle1_diff(2, 
     +          idx_strip)
              rle_diff(2, idx_strip) = 0.D0
              xyzlel_diff(1) = xyzlel_diff(1) + (1.0-fc)*rle_diff(1, 
     +          idx_strip) + (1.0-f2)*rle2_diff(1, idx_strip) + (1.0-f1)
     +          *rle1_diff(1, idx_strip)
              xyzler_diff(1) = xyzler_diff(1) + fc*rle_diff(1, idx_strip
     +          ) + f2*rle2_diff(1, idx_strip) + f1*rle1_diff(1, 
     +          idx_strip)
              rle_diff(1, idx_strip) = 0.D0
              f2_diff = f2_diff + (chordr-chordl)*chord2_diff(idx_strip)
     +          + (xyzler(3)-xyzlel(3))*rle2_diff(3, idx_strip) + (
     +          xyzler(2)-xyzlel(2))*rle2_diff(2, idx_strip) + (xyzler(1
     +          )-xyzlel(1))*rle2_diff(1, idx_strip)
              chord2_diff(idx_strip) = 0.D0
              rle2_diff(3, idx_strip) = 0.D0
              rle2_diff(2, idx_strip) = 0.D0
              rle2_diff(1, idx_strip) = 0.D0
              f1_diff = f1_diff + (chordr-chordl)*chord1_diff(idx_strip)
     +          + (xyzler(3)-xyzlel(3))*rle1_diff(3, idx_strip) + (
     +          xyzler(2)-xyzlel(2))*rle1_diff(2, idx_strip) + (xyzler(1
     +          )-xyzlel(1))*rle1_diff(1, idx_strip)
              chord1_diff(idx_strip) = 0.D0
              rle1_diff(3, idx_strip) = 0.D0
              rle1_diff(2, idx_strip) = 0.D0
              rle1_diff(1, idx_strip) = 0.D0
              temp_diff1 = fc_diff/(ypt(iptr)-ypt(iptl))
              ycp_diff(ivs) = ycp_diff(ivs) + temp_diff1
              ypt_diff(iptl) = ypt_diff(iptl) - temp_diff1
              temp_diff0 = -((ycp(ivs)-ypt(iptl))*temp_diff1/(ypt(iptr)-
     +          ypt(iptl)))
              ypt_diff(iptr) = ypt_diff(iptr) + temp_diff0
              ypt_diff(iptl) = ypt_diff(iptl) - temp_diff0
              temp_diff1 = f2_diff/(ypt(iptr)-ypt(iptl))
              ypt_diff(ipt2) = ypt_diff(ipt2) + temp_diff1
              ypt_diff(iptl) = ypt_diff(iptl) - temp_diff1
              temp_diff0 = -((ypt(ipt2)-ypt(iptl))*temp_diff1/(ypt(iptr)
     +          -ypt(iptl)))
              ypt_diff(iptr) = ypt_diff(iptr) + temp_diff0
              ypt_diff(iptl) = ypt_diff(iptl) - temp_diff0
              temp_diff1 = f1_diff/(ypt(iptr)-ypt(iptl))
              ypt_diff(ipt1) = ypt_diff(ipt1) + temp_diff1
              ypt_diff(iptl) = ypt_diff(iptl) - temp_diff1
              temp_diff0 = -((ypt(ipt1)-ypt(iptl))*temp_diff1/(ypt(iptr)
     +          -ypt(iptl)))
              ypt_diff(iptr) = ypt_diff(iptr) + temp_diff0
              ypt_diff(iptl) = ypt_diff(iptl) - temp_diff0
              CALL POPINTEGER4(ipt2)
              CALL POPINTEGER4(ipt1)
            ENDDO
            CALL POPINTEGER4(iptr)
            CALL POPINTEGER4(iptl)
            DO n=ndesign,1,-1
              CALL POPINTEGER4(ad_to11)
              DO isdes=ad_to11,1,-1
                CALL POPCONTROL1B(branch)
                IF (branch .NE. 0) THEN
                  chsinr_diff = chsinr_diff - dtr*gaing(isdes, isec+1, 
     +              isurf)*chcosr_g_diff(n)
                  chcosr_g_diff(n) = 0.D0
                  chcosr_diff = chcosr_diff + dtr*gaing(isdes, isec+1, 
     +              isurf)*chsinr_g_diff(n)
                  chsinr_g_diff(n) = 0.D0
                END IF
              ENDDO
              CALL POPINTEGER4(ad_to10)
              DO isdes=ad_to10,1,-1
                CALL POPCONTROL1B(branch)
                IF (branch .NE. 0) THEN
                  chsinl_diff = chsinl_diff - dtr*gaing(isdes, isec, 
     +              isurf)*chcosl_g_diff(n)
                  chcosl_g_diff(n) = 0.D0
                  chcosl_diff = chcosl_diff + dtr*gaing(isdes, isec, 
     +              isurf)*chsinl_g_diff(n)
                  chsinl_g_diff(n) = 0.D0
                END IF
              ENDDO
              CALL POPREAL8(chcosr_g(n))
              chcosr_g_diff(n) = 0.D0
              CALL POPREAL8(chcosl_g(n))
              chcosl_g_diff(n) = 0.D0
              CALL POPREAL8(chsinr_g(n))
              chsinr_g_diff(n) = 0.D0
              CALL POPREAL8(chsinl_g(n))
              chsinl_g_diff(n) = 0.D0
            ENDDO
            DO n=ncontrol,1,-1
              CALL POPINTEGER4(ad_to9)
              DO iscon=ad_to9,1,-1
                CALL POPCONTROL1B(branch)
              ENDDO
              CALL POPINTEGER4(ad_to8)
              DO iscon=ad_to8,1,-1
                CALL POPCONTROL1B(branch)
              ENDDO
            ENDDO
            aincr = aincs(isec+1, isurf)*dtr + addinc(isurf)*dtr
            CALL POPREAL8(chcosr)
            chordr_diff = chordr_diff + COS(aincr)*chcosr_diff + SIN(
     +        aincr)*chsinr_diff
            aincr_diff = COS(aincr)*chordr*chsinr_diff - SIN(aincr)*
     +        chordr*chcosr_diff
            aincl = aincs(isec, isurf)*dtr + addinc(isurf)*dtr
            CALL POPREAL8(chcosl)
            chordl_diff = chordl_diff + COS(aincl)*chcosl_diff + SIN(
     +        aincl)*chsinl_diff
            aincl_diff = COS(aincl)*chordl*chsinl_diff - SIN(aincl)*
     +        chordl*chcosl_diff
            CALL POPREAL8(chsinr)
            CALL POPREAL8(chsinl)
            aincs_diff(isec+1, isurf) = aincs_diff(isec+1, isurf) + dtr*
     +        aincr_diff
            addinc_diff(isurf) = addinc_diff(isurf) + dtr*aincr_diff + 
     +        dtr*aincl_diff
            aincs_diff(isec, isurf) = aincs_diff(isec, isurf) + dtr*
     +        aincl_diff
            claf_diff(isec+1, isurf) = claf_diff(isec+1, isurf) + 
     +        clafr_diff
            claf_diff(isec, isurf) = claf_diff(isec, isurf) + clafl_diff
            xyzscal_diff(1, isurf) = xyzscal_diff(1, isurf) + chords(
     +        isec+1, isurf)*chordr_diff + chords(isec, isurf)*
     +        chordl_diff + xyzles(1, isec+1, isurf)*xyzler_diff(1) + 
     +        xyzles(1, isec, isurf)*xyzlel_diff(1)
            chords_diff(isec+1, isurf) = chords_diff(isec+1, isurf) + 
     +        xyzscal(1, isurf)*chordr_diff
            chords_diff(isec, isurf) = chords_diff(isec, isurf) + 
     +        xyzscal(1, isurf)*chordl_diff
            CALL POPREAL8(width)
            IF ((xyzler(2)-xyzlel(2))**2 + (xyzler(3)-xyzlel(3))**2 .EQ.
     +          0.D0) THEN
              temp_diff0 = 0.D0
            ELSE
              temp_diff0 = width_diff/(2.0*SQRT((xyzler(2)-xyzlel(2))**2
     +          +(xyzler(3)-xyzlel(3))**2))
            END IF
            temp_diff = 2*(xyzler(2)-xyzlel(2))*temp_diff0
            temp_diff1 = 2*(xyzler(3)-xyzlel(3))*temp_diff0
            xyzler_diff(3) = xyzler_diff(3) + temp_diff1
            xyzlel_diff(3) = xyzlel_diff(3) - temp_diff1
            xyzler_diff(2) = xyzler_diff(2) + temp_diff
            xyzlel_diff(2) = xyzlel_diff(2) - temp_diff
            CALL POPREAL8(xyzler(3))
            xyzscal_diff(3, isurf) = xyzscal_diff(3, isurf) + xyzles(3, 
     +        isec+1, isurf)*xyzler_diff(3) + xyzles(3, isec, isurf)*
     +        xyzlel_diff(3)
            xyzles_diff(3, isec+1, isurf) = xyzles_diff(3, isec+1, isurf
     +        ) + xyzscal(3, isurf)*xyzler_diff(3)
            xyztran_diff(3, isurf) = xyztran_diff(3, isurf) + 
     +        xyzler_diff(3) + xyzlel_diff(3)
            xyzler_diff(3) = 0.D0
            CALL POPREAL8(xyzler(2))
            xyzscal_diff(2, isurf) = xyzscal_diff(2, isurf) + xyzles(2, 
     +        isec+1, isurf)*xyzler_diff(2) + xyzles(2, isec, isurf)*
     +        xyzlel_diff(2)
            xyzles_diff(2, isec+1, isurf) = xyzles_diff(2, isec+1, isurf
     +        ) + xyzscal(2, isurf)*xyzler_diff(2)
            xyztran_diff(2, isurf) = xyztran_diff(2, isurf) + 
     +        xyzler_diff(2) + xyzlel_diff(2)
            xyzler_diff(2) = 0.D0
            CALL POPREAL8(xyzler(1))
            xyzles_diff(1, isec+1, isurf) = xyzles_diff(1, isec+1, isurf
     +        ) + xyzscal(1, isurf)*xyzler_diff(1)
            xyztran_diff(1, isurf) = xyztran_diff(1, isurf) + 
     +        xyzler_diff(1) + xyzlel_diff(1)
            xyzler_diff(1) = 0.D0
            CALL POPREAL8(xyzlel(3))
            xyzles_diff(3, isec, isurf) = xyzles_diff(3, isec, isurf) + 
     +        xyzscal(3, isurf)*xyzlel_diff(3)
            xyzlel_diff(3) = 0.D0
            CALL POPREAL8(xyzlel(2))
            xyzles_diff(2, isec, isurf) = xyzles_diff(2, isec, isurf) + 
     +        xyzscal(2, isurf)*xyzlel_diff(2)
            xyzlel_diff(2) = 0.D0
            CALL POPREAL8(xyzlel(1))
            xyzles_diff(1, isec, isurf) = xyzles_diff(1, isec, isurf) + 
     +        xyzscal(1, isurf)*xyzlel_diff(1)
            xyzlel_diff(1) = 0.D0
          ENDDO
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPINTEGER4(ad_count)
            DO i=1,ad_count
              IF (i .EQ. 1) THEN
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  DO ii1=1,ksmax
                    yzlen_diff(ii1) = 0.D0
                  ENDDO
                  GOTO 140
                ELSE
                  DO ii1=1,nfmax
                    DO ii2=1,3
                      xyzscal_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nfmax
                    DO ii2=1,3
                      xyztran_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nfmax
                    addinc_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nfmax
                    DO ii2=1,nsmax
                      DO ii3=1,3
                        xyzles_diff(ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                  DO ii1=1,nfmax
                    DO ii2=1,nsmax
                      chords_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nfmax
                    DO ii2=1,nsmax
                      aincs_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nfmax
                    DO ii2=1,nsmax
                      DO ii3=1,ibx
                        xasec_diff(ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                  DO ii1=1,nfmax
                    DO ii2=1,nsmax
                      DO ii3=1,ibx
                        sasec_diff(ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                  DO ii1=1,nfmax
                    DO ii2=1,nsmax
                      claf_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nsmax
                    DO ii2=1,3
                      rle_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nsmax
                    chord_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nsmax
                    DO ii2=1,3
                      rle1_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nsmax
                    chord1_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nsmax
                    DO ii2=1,3
                      rle2_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nsmax
                    chord2_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nsmax
                    wstrip_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nsmax
                    ainc_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,ngmax
                    DO ii2=1,nsmax
                      ainc_g_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nvmax
                    DO ii2=1,3
                      rv1_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nvmax
                    DO ii2=1,3
                      rv2_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nvmax
                    DO ii2=1,3
                      rv_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nvmax
                    DO ii2=1,3
                      rc_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nvmax
                    DO ii2=1,3
                      rs_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nvmax
                    dxv_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nvmax
                    chordv_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nvmax
                    slopev_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nvmax
                    slopec_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,ndmax
                    DO ii2=1,nvmax
                      dcontrol_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,ndmax
                    DO ii2=1,nsmax
                      DO ii3=1,3
                        vhinge_diff(ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                  DO ii1=1,ksmax
                    ycp_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,ksmax
                    ypt_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,ksmax
                    yzlen_diff(ii1) = 0.D0
                  ENDDO
                  dyzlen_diff = 0.D0
                END IF
              ELSE
                CALL POPINTEGER4(nvs(isurf))
                dyzlen_diff = 0.D0
                CALL POPINTEGER4(ad_to0)
                DO n=ad_to0,1,-1
                  ivs = nvs(isurf) + n
                  tmp_diff = ypt_diff(ivs+1)
                  ypt_diff(ivs+1) = 0.D0
                  ypt_diff(nvs(isurf)+1) = ypt_diff(nvs(isurf)+1) + 
     +              tmp_diff + ycp_diff(ivs)
                  dyzlen_diff = dyzlen_diff + fspace(2*n+1)*tmp_diff + 
     +              fspace(2*n)*ycp_diff(ivs)
                  ycp_diff(ivs) = 0.D0
                ENDDO
                CALL POPREAL8ARRAY(fspace, 1100)
              END IF
              yzlen_diff(isec+1) = yzlen_diff(isec+1) + dyzlen_diff
              yzlen_diff(isec) = yzlen_diff(isec) - dyzlen_diff
 140          CALL POPINTEGER4(isec)
            ENDDO
            yzlen_diff(1) = yzlen_diff(1) + ypt_diff(1)
          ELSE
            CALL POPINTEGER4(ad_count0)
            DO i0=1,ad_count0
              IF (i0 .EQ. 1) THEN
                CALL POPCONTROL2B(branch)
                IF (branch .EQ. 0) THEN
                  DO ii1=1,ksmax
                    yzlen_diff(ii1) = 0.D0
                  ENDDO
                  GOTO 160
                ELSE IF (branch .EQ. 1) THEN
                  DO ii1=1,nfmax
                    DO ii2=1,3
                      xyzscal_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nfmax
                    DO ii2=1,3
                      xyztran_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nfmax
                    addinc_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nfmax
                    DO ii2=1,nsmax
                      DO ii3=1,3
                        xyzles_diff(ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                  DO ii1=1,nfmax
                    DO ii2=1,nsmax
                      chords_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nfmax
                    DO ii2=1,nsmax
                      aincs_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nfmax
                    DO ii2=1,nsmax
                      DO ii3=1,ibx
                        xasec_diff(ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                  DO ii1=1,nfmax
                    DO ii2=1,nsmax
                      DO ii3=1,ibx
                        sasec_diff(ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                  DO ii1=1,nfmax
                    DO ii2=1,nsmax
                      claf_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nsmax
                    DO ii2=1,3
                      rle_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nsmax
                    chord_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nsmax
                    DO ii2=1,3
                      rle1_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nsmax
                    chord1_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nsmax
                    DO ii2=1,3
                      rle2_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nsmax
                    chord2_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nsmax
                    wstrip_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nsmax
                    ainc_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,ngmax
                    DO ii2=1,nsmax
                      ainc_g_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nvmax
                    DO ii2=1,3
                      rv1_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nvmax
                    DO ii2=1,3
                      rv2_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nvmax
                    DO ii2=1,3
                      rv_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nvmax
                    DO ii2=1,3
                      rc_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nvmax
                    DO ii2=1,3
                      rs_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nvmax
                    dxv_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nvmax
                    chordv_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nvmax
                    slopev_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nvmax
                    slopec_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,ndmax
                    DO ii2=1,nvmax
                      dcontrol_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,ndmax
                    DO ii2=1,nsmax
                      DO ii3=1,3
                        vhinge_diff(ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                  DO ii1=1,ksmax
                    ycp_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,ksmax
                    ypt_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,ksmax
                    yzlen_diff(ii1) = 0.D0
                  ENDDO
                  GOTO 150
                ELSE
                  DO ii1=1,nfmax
                    DO ii2=1,3
                      xyzscal_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nfmax
                    DO ii2=1,3
                      xyztran_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nfmax
                    addinc_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nfmax
                    DO ii2=1,nsmax
                      DO ii3=1,3
                        xyzles_diff(ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                  DO ii1=1,nfmax
                    DO ii2=1,nsmax
                      chords_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nfmax
                    DO ii2=1,nsmax
                      aincs_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nfmax
                    DO ii2=1,nsmax
                      DO ii3=1,ibx
                        xasec_diff(ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                  DO ii1=1,nfmax
                    DO ii2=1,nsmax
                      DO ii3=1,ibx
                        sasec_diff(ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                  DO ii1=1,nfmax
                    DO ii2=1,nsmax
                      claf_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nsmax
                    DO ii2=1,3
                      rle_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nsmax
                    chord_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nsmax
                    DO ii2=1,3
                      rle1_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nsmax
                    chord1_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nsmax
                    DO ii2=1,3
                      rle2_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nsmax
                    chord2_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nsmax
                    wstrip_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nsmax
                    ainc_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,ngmax
                    DO ii2=1,nsmax
                      ainc_g_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nvmax
                    DO ii2=1,3
                      rv1_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nvmax
                    DO ii2=1,3
                      rv2_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nvmax
                    DO ii2=1,3
                      rv_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nvmax
                    DO ii2=1,3
                      rc_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nvmax
                    DO ii2=1,3
                      rs_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,nvmax
                    dxv_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nvmax
                    chordv_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nvmax
                    slopev_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,nvmax
                    slopec_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,ndmax
                    DO ii2=1,nvmax
                      dcontrol_diff(ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                  DO ii1=1,ndmax
                    DO ii2=1,nsmax
                      DO ii3=1,3
                        vhinge_diff(ii3, ii2, ii1) = 0.D0
                      ENDDO
                    ENDDO
                  ENDDO
                  DO ii1=1,ksmax
                    ycp_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,ksmax
                    ypt_diff(ii1) = 0.D0
                  ENDDO
                  DO ii1=1,ksmax
                    yzlen_diff(ii1) = 0.D0
                  ENDDO
                END IF
              ELSE
                yscale_diff = 0.D0
                ypt1_diff = 0.D0
                CALL POPINTEGER4(ad_from2)
                CALL POPINTEGER4(ad_to7)
                DO ivs=ad_to7,ad_from2,-1
                  CALL POPREAL8(ycp(ivs))
                  yzlen_diff(isec) = yzlen_diff(isec) + ycp_diff(ivs)
                  yscale_diff = yscale_diff + (ycp(ivs)-ypt1)*ycp_diff(
     +              ivs)
                  ypt1_diff = ypt1_diff - yscale*ycp_diff(ivs)
                  ycp_diff(ivs) = yscale*ycp_diff(ivs)
                ENDDO
                CALL POPINTEGER4(ad_from1)
                CALL POPINTEGER4(ad_to6)
                DO ipt=ad_to6,ad_from1,-1
                  CALL POPREAL8(ypt(ipt))
                  yzlen_diff(isec) = yzlen_diff(isec) + ypt_diff(ipt)
                  yscale_diff = yscale_diff + (ypt(ipt)-ypt1)*ypt_diff(
     +              ipt)
                  ypt1_diff = ypt1_diff - yscale*ypt_diff(ipt)
                  ypt_diff(ipt) = yscale*ypt_diff(ipt)
                ENDDO
                CALL POPREAL8(yscale)
                temp_diff0 = yscale_diff/(ypt(ipt2)-ypt(ipt1))
                yzlen_diff(isec) = yzlen_diff(isec) - temp_diff0
                temp_diff = -((ypt(ipt2)-yzlen(isec))*temp_diff0/(ypt(
     +            ipt2)-ypt(ipt1)))
                ypt_diff(ipt2) = ypt_diff(ipt2) + temp_diff0 + temp_diff
                ypt_diff(ipt1) = ypt_diff(ipt1) + ypt1_diff - temp_diff
                CALL POPREAL8(ypt1)
              END IF
              CALL POPINTEGER4(ipt2)
              CALL POPINTEGER4(ipt1)
              yscale_diff = 0.D0
              ypt1_diff = 0.D0
              CALL POPINTEGER4(ad_from0)
              CALL POPINTEGER4(ad_to5)
              DO ivs=ad_to5,ad_from0,-1
                CALL POPREAL8(ycp(ivs))
                yzlen_diff(isec-1) = yzlen_diff(isec-1) + ycp_diff(ivs)
                yscale_diff = yscale_diff + (ycp(ivs)-ypt1)*ycp_diff(ivs
     +            )
                ypt1_diff = ypt1_diff - yscale*ycp_diff(ivs)
                ycp_diff(ivs) = yscale*ycp_diff(ivs)
              ENDDO
              CALL POPINTEGER4(ad_from)
              CALL POPINTEGER4(ad_to4)
              DO ipt=ad_to4,ad_from,-1
                CALL POPREAL8(ypt(ipt))
                yzlen_diff(isec-1) = yzlen_diff(isec-1) + ypt_diff(ipt)
                yscale_diff = yscale_diff + (ypt(ipt)-ypt1)*ypt_diff(ipt
     +            )
                ypt1_diff = ypt1_diff - yscale*ypt_diff(ipt)
                ypt_diff(ipt) = yscale*ypt_diff(ipt)
              ENDDO
              CALL POPREAL8(yscale)
              temp_diff = yscale_diff/(ypt(ipt2)-ypt(ipt1))
              yzlen_diff(isec) = yzlen_diff(isec) + temp_diff
              yzlen_diff(isec-1) = yzlen_diff(isec-1) - temp_diff
              temp_diff0 = -((yzlen(isec)-yzlen(isec-1))*temp_diff/(ypt(
     +          ipt2)-ypt(ipt1)))
              ypt_diff(ipt2) = ypt_diff(ipt2) + temp_diff0
              ypt_diff(ipt1) = ypt_diff(ipt1) + ypt1_diff - temp_diff0
              CALL POPREAL8(ypt1)
 150          CALL POPINTEGER4(ipt2)
              CALL POPINTEGER4(ipt1)
 160          CALL POPINTEGER4(isec)
            ENDDO
            CALL POPINTEGER4(ad_to3)
            DO isec=ad_to3,2,-1
              CALL POPINTEGER4(ad_to2)
              DO ipt=ad_to2,1,-1
                CALL POPCONTROL1B(branch)
              ENDDO
            ENDDO
            CALL POPINTEGER4(ad_to1)
            DO ivs=ad_to1,1,-1
              yzlen_diff(1) = yzlen_diff(1) + ypt_diff(ivs+1)
              temp_diff = fspace(2*ivs+1)*ypt_diff(ivs+1)
              ypt_diff(ivs+1) = 0.D0
              yzlen_diff(nsec(isurf)) = yzlen_diff(nsec(isurf)) + 
     +          temp_diff
              yzlen_diff(1) = yzlen_diff(1) + ycp_diff(ivs) - temp_diff
              temp_diff = fspace(2*ivs)*ycp_diff(ivs)
              ycp_diff(ivs) = 0.D0
              yzlen_diff(nsec(isurf)) = yzlen_diff(nsec(isurf)) + 
     +          temp_diff
              yzlen_diff(1) = yzlen_diff(1) - temp_diff
            ENDDO
            yzlen_diff(1) = yzlen_diff(1) + ypt_diff(1)
          END IF
          CALL POPINTEGER4(ad_to)
          DO isec=ad_to,2,-1
            dy = xyzles(2, isec, isurf) - xyzles(2, isec-1, isurf)
            dz = xyzles(3, isec, isurf) - xyzles(3, isec-1, isurf)
            yzlen_diff(isec-1) = yzlen_diff(isec-1) + yzlen_diff(isec)
            IF (dy**2 + dz**2 .EQ. 0.D0) THEN
              temp_diff = 0.D0
            ELSE
              temp_diff = yzlen_diff(isec)/(2.0*SQRT(dy**2+dz**2))
            END IF
            yzlen_diff(isec) = 0.D0
            dy_diff = 2*dy*temp_diff
            dz_diff = 2*dz*temp_diff
            xyzles_diff(3, isec, isurf) = xyzles_diff(3, isec, isurf) + 
     +        dz_diff
            xyzles_diff(3, isec-1, isurf) = xyzles_diff(3, isec-1, isurf
     +        ) - dz_diff
            xyzles_diff(2, isec, isurf) = xyzles_diff(2, isec, isurf) + 
     +        dy_diff
            xyzles_diff(2, isec-1, isurf) = xyzles_diff(2, isec-1, isurf
     +        ) - dy_diff
          ENDDO
        END IF
      END IF
C
 7000 FORMAT(/' *** Cannot adjust spanwise spacing at section',i3,
     +       ', on surface ',a/
     +      ' *** Insufficient number of spanwise vortices to work with'
     +      )
      END

C  Differentiation of sdupl in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: rle chord rle1 chord1 rle2
C                chord2 wstrip ainc ainc_g rv1 rv2 rv rc dxv chordv
C                slopev slopec dcontrol vhinge
C   with respect to varying inputs: rle chord rle1 chord1 rle2
C                chord2 wstrip ainc ainc_g rv1 rv2 rv rc dxv chordv
C                slopev slopec dcontrol vhinge
C MAKEBODY
C
C
C
C
      SUBROUTINE SDUPL_B(nn, ypt, msg)
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
      CHARACTER*(*) msg
      INTEGER idx_vor
      INTEGER nni
      INTEGER klen
      INTRINSIC LEN
      INTEGER k
      REAL yoff
      INTEGER idx_strip
      INTEGER ivs
      INTEGER jji
      INTEGER jj
      INTEGER n
      INTEGER l
      INTEGER ivc
      INTEGER iii
      INTEGER ii
      REAL rsgn
      REAL(kind=avl_real) tmp
      REAL(kind=avl_real) tmp0
      REAL(kind=avl_real) tmp1
      REAL(kind=avl_real) tmp_diff
      REAL(kind=avl_real) tmp2
      REAL(kind=avl_real) tmp_diff0
      REAL(kind=avl_real) tmp3
      REAL(kind=avl_real) tmp_diff1
      REAL(kind=avl_real) tmp4
      REAL(kind=avl_real) tmp_diff2
      REAL(kind=avl_real) tmp5
      REAL(kind=avl_real) tmp_diff3
      REAL(kind=avl_real) tmp6
      REAL(kind=avl_real) tmp7
      REAL(kind=avl_real) tmp_diff4
      REAL(kind=avl_real) tmp8
      REAL(kind=avl_real) tmp_diff5
      REAL(kind=avl_real) tmp9
      REAL(kind=avl_real) tmp10
      REAL(kind=avl_real) tmp_diff6
      REAL(kind=avl_real) tmp11
      REAL(kind=avl_real) tmp_diff7
      REAL(kind=avl_real) tmp12
      REAL(kind=avl_real) tmp_diff8
      REAL(kind=avl_real) tmp13
      REAL(kind=avl_real) tmp14
      REAL(kind=avl_real) tmp15
      REAL(kind=avl_real) tmp16
      REAL(kind=avl_real) tmp17
      REAL(kind=avl_real) tmp_diff9
      REAL(kind=avl_real) tmp18
      REAL(kind=avl_real) tmp_diff10
      REAL(kind=avl_real) tmp19
      REAL(kind=avl_real) tmp_diff11
      REAL(kind=avl_real) tmp20
      REAL(kind=avl_real) tmp_diff12
      REAL(kind=avl_real) tmp21
      REAL(kind=avl_real) tmp_diff13
      REAL(kind=avl_real) tmp22
      REAL(kind=avl_real) tmp_diff14
      REAL(kind=avl_real) tmp23
      REAL(kind=avl_real) tmp_diff15
      REAL(kind=avl_real) tmp24
      REAL(kind=avl_real) tmp_diff16
      REAL(kind=avl_real) tmp25
      REAL(kind=avl_real) tmp_diff17
      REAL(kind=avl_real) tmp26
      REAL(kind=avl_real) tmp_diff18
      REAL(kind=avl_real) tmp27
      REAL(kind=avl_real) tmp_diff19
      INTEGER ad_count
      INTEGER i
      INTEGER branch
      INTEGER ad_to
      INTEGER ad_to0
      INTEGER ad_to1
      INTEGER ad_count0
      INTEGER i0
      INTEGER ii3
      INTEGER ii2
      INTEGER ii1
      INTEGER nn
      REAL ypt
C
      nni = nn + 1
      IF (nni .GT. nfmax) THEN
        STOP
      ELSE
C
        klen = LEN(stitle(nn))
        ad_count = 1
        DO k=klen,1,-1
          IF (stitle(nn)(k:k) .NE. ' ') THEN
            GOTO 100
          ELSE
            ad_count = ad_count + 1
          END IF
        ENDDO
        CALL PUSHCONTROL1B(0)
        CALL PUSHINTEGER4(ad_count)
        CALL PUSHINTEGER4(ivs)
        CALL PUSHCONTROL1B(0)
        GOTO 110
 100    CALL PUSHCONTROL1B(1)
        CALL PUSHINTEGER4(ad_count)
        CALL PUSHINTEGER4(ivs)
        CALL PUSHCONTROL1B(0)
C
C---- duplicate surface is assumed to be the same logical component surface
C
C---- same various logical flags
C IFRST(NNI) = NVOR   + 1
C
C---- accumulate stuff for new image surface 
C JFRST(NNI) = NSTRIP + 1
 110    jfrst(nni) = jfrst(nni-1) + nj(nni-1)
        nj(nni) = nj(nn)
        nk(nni) = nk(nn)
C
        nvc(nni) = nk(nni)
        nvs(nni) = nj(nni)
C
C--- Note hinge axis is flipped to reverse the Y component of the hinge
C    vector.   This means that deflections need to be reversed for image
C    surfaces.
C
C--- Image flag reversed (set to -IMAGS) for imaged surfaces
C
C
C--- Create image strips, to maintain the same sense of positive GAMMA
C    these have the 1 and 2 strip edges reversed (i.e. root is edge 2, 
C    not edge 1 as for a strip with IMAGS=1
        idx_strip = jfrst(nni)
C   NSTRIP = NSTRIP + 1
        DO ivs=1,nvs(nni)
          IF (idx_strip .GT. nsmax) THEN
            GOTO 130
          ELSE
C
            jji = jfrst(nni) + ivs - 1
            jj = jfrst(nn) + ivs - 1
C
C
            n = ndesign + 1
            CALL PUSHINTEGER4(n - 1)
C
            DO n=1,ncontrol
              tmp9 = vrefl(jj, n)
              vrefl(jji, n) = tmp9
C
C
            ENDDO
            CALL PUSHINTEGER4(n - 1)
C   IJFRST(JJI)  = NVOR + 1
C   IJFRST(JJI) = IJFRST(NSTRIP - 1) + NVC(NNI)
C
C--- The defined section for image strip is flagged with (-)
            ijfrst(jji) = ijfrst(jji-1) + nvstrp(jji-1)
C
            nvstrp(jji) = nvc(nni)
C
            idx_vor = ijfrst(jji)
            ad_count0 = 1
C
C     NVOR = NVOR + 1
            DO ivc=1,nvc(nni)
              IF (idx_vor .GT. nvmax) THEN
                GOTO 140
              ELSE
C
                CALL PUSHINTEGER4(iii)
                iii = ijfrst(jji) + ivc - 1
                CALL PUSHINTEGER4(ii)
                ii = ijfrst(jj) + ivc - 1
C
                DO n=1,ncontrol
Ccc         RSGN = SIGN( 1.0 , VREFL(JJ,N) )
                  CALL PUSHREAL8(rsgn)
                  rsgn = vrefl(jj, n)
                ENDDO
                CALL PUSHINTEGER4(n - 1)
                idx_vor = idx_vor + 1
                ad_count0 = ad_count0 + 1
              END IF
            ENDDO
            CALL PUSHCONTROL1B(0)
            CALL PUSHINTEGER4(ad_count0)
            CALL PUSHINTEGER4(ivs)
            CALL PUSHCONTROL1B(1)
          END IF
        ENDDO
 120    CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          CALL POPINTEGER4(ivs)
          jji = jfrst(nni) + ivs - 1
          jj = jfrst(nn) + ivs - 1
          CALL POPINTEGER4(ad_count0)
          DO i0=1,ad_count0
            IF (i0 .EQ. 1) THEN
              CALL POPCONTROL1B(branch)
              IF (branch .NE. 0) THEN
                DO ii1=1,nsmax
                  DO ii2=1,3
                    rle_diff(ii2, ii1) = 0.D0
                  ENDDO
                ENDDO
                DO ii1=1,nsmax
                  chord_diff(ii1) = 0.D0
                ENDDO
                DO ii1=1,nsmax
                  DO ii2=1,3
                    rle1_diff(ii2, ii1) = 0.D0
                  ENDDO
                ENDDO
                DO ii1=1,nsmax
                  chord1_diff(ii1) = 0.D0
                ENDDO
                DO ii1=1,nsmax
                  DO ii2=1,3
                    rle2_diff(ii2, ii1) = 0.D0
                  ENDDO
                ENDDO
                DO ii1=1,nsmax
                  chord2_diff(ii1) = 0.D0
                ENDDO
                DO ii1=1,nsmax
                  wstrip_diff(ii1) = 0.D0
                ENDDO
                DO ii1=1,nsmax
                  ainc_diff(ii1) = 0.D0
                ENDDO
                DO ii1=1,ngmax
                  DO ii2=1,nsmax
                    ainc_g_diff(ii2, ii1) = 0.D0
                  ENDDO
                ENDDO
                DO ii1=1,nvmax
                  DO ii2=1,3
                    rv1_diff(ii2, ii1) = 0.D0
                  ENDDO
                ENDDO
                DO ii1=1,nvmax
                  DO ii2=1,3
                    rv2_diff(ii2, ii1) = 0.D0
                  ENDDO
                ENDDO
                DO ii1=1,nvmax
                  DO ii2=1,3
                    rv_diff(ii2, ii1) = 0.D0
                  ENDDO
                ENDDO
                DO ii1=1,nvmax
                  DO ii2=1,3
                    rc_diff(ii2, ii1) = 0.D0
                  ENDDO
                ENDDO
                DO ii1=1,nvmax
                  dxv_diff(ii1) = 0.D0
                ENDDO
                DO ii1=1,nvmax
                  chordv_diff(ii1) = 0.D0
                ENDDO
                DO ii1=1,nvmax
                  slopev_diff(ii1) = 0.D0
                ENDDO
                DO ii1=1,nvmax
                  slopec_diff(ii1) = 0.D0
                ENDDO
                DO ii1=1,ndmax
                  DO ii2=1,nvmax
                    dcontrol_diff(ii2, ii1) = 0.D0
                  ENDDO
                ENDDO
                DO ii1=1,ndmax
                  DO ii2=1,nsmax
                    DO ii3=1,3
                      vhinge_diff(ii3, ii2, ii1) = 0.D0
                    ENDDO
                  ENDDO
                ENDDO
              END IF
            ELSE
              CALL POPINTEGER4(ad_to1)
              DO n=ad_to1,1,-1
                tmp_diff19 = dcontrol_diff(iii, n)
                dcontrol_diff(iii, n) = 0.D0
                dcontrol_diff(ii, n) = dcontrol_diff(ii, n) - rsgn*
     +            tmp_diff19
                CALL POPREAL8(rsgn)
              ENDDO
              tmp_diff18 = chordv_diff(iii)
              chordv_diff(iii) = 0.D0
              chordv_diff(ii) = chordv_diff(ii) + tmp_diff18
              tmp_diff17 = dxv_diff(iii)
              dxv_diff(iii) = 0.D0
              dxv_diff(ii) = dxv_diff(ii) + tmp_diff17
              tmp_diff16 = slopev_diff(iii)
              slopev_diff(iii) = 0.D0
              slopev_diff(ii) = slopev_diff(ii) + tmp_diff16
              tmp_diff15 = slopec_diff(iii)
              slopec_diff(iii) = 0.D0
              slopec_diff(ii) = slopec_diff(ii) + tmp_diff15
              tmp_diff14 = rc_diff(3, iii)
              rc_diff(3, iii) = 0.D0
              rc_diff(3, ii) = rc_diff(3, ii) + tmp_diff14
              tmp_diff13 = rc_diff(2, iii)
              rc_diff(2, iii) = 0.D0
              rc_diff(2, ii) = rc_diff(2, ii) - tmp_diff13
              tmp_diff12 = rc_diff(1, iii)
              rc_diff(1, iii) = 0.D0
              rc_diff(1, ii) = rc_diff(1, ii) + tmp_diff12
              tmp_diff11 = rv_diff(3, iii)
              rv_diff(3, iii) = 0.D0
              rv_diff(3, ii) = rv_diff(3, ii) + tmp_diff11
              tmp_diff10 = rv_diff(2, iii)
              rv_diff(2, iii) = 0.D0
              rv_diff(2, ii) = rv_diff(2, ii) - tmp_diff10
              tmp_diff9 = rv_diff(1, iii)
              rv_diff(1, iii) = 0.D0
              rv_diff(1, ii) = rv_diff(1, ii) + tmp_diff9
              rv1_diff(3, ii) = rv1_diff(3, ii) + rv2_diff(3, iii)
              rv2_diff(3, iii) = 0.D0
              rv1_diff(2, ii) = rv1_diff(2, ii) - rv2_diff(2, iii)
              rv2_diff(2, iii) = 0.D0
              rv1_diff(1, ii) = rv1_diff(1, ii) + rv2_diff(1, iii)
              rv2_diff(1, iii) = 0.D0
              rv2_diff(3, ii) = rv2_diff(3, ii) + rv1_diff(3, iii)
              rv1_diff(3, iii) = 0.D0
              rv2_diff(2, ii) = rv2_diff(2, ii) - rv1_diff(2, iii)
              rv1_diff(2, iii) = 0.D0
              rv2_diff(1, ii) = rv2_diff(1, ii) + rv1_diff(1, iii)
              rv1_diff(1, iii) = 0.D0
              CALL POPINTEGER4(ii)
              CALL POPINTEGER4(iii)
            END IF
          ENDDO
          CALL POPINTEGER4(ad_to0)
          DO n=ad_to0,1,-1
            tmp_diff8 = vhinge_diff(3, jji, n)
            vhinge_diff(3, jji, n) = 0.D0
            vhinge_diff(3, jj, n) = vhinge_diff(3, jj, n) + tmp_diff8
            tmp_diff7 = vhinge_diff(2, jji, n)
            vhinge_diff(2, jji, n) = 0.D0
            vhinge_diff(2, jj, n) = vhinge_diff(2, jj, n) - tmp_diff7
            tmp_diff6 = vhinge_diff(1, jji, n)
            vhinge_diff(1, jji, n) = 0.D0
            vhinge_diff(1, jj, n) = vhinge_diff(1, jj, n) + tmp_diff6
          ENDDO
          CALL POPINTEGER4(ad_to)
          DO n=ad_to,1,-1
            tmp_diff5 = ainc_g_diff(jji, n)
            ainc_g_diff(jji, n) = 0.D0
            ainc_g_diff(jj, n) = ainc_g_diff(jj, n) + tmp_diff5
          ENDDO
          tmp_diff4 = ainc_diff(jji)
          ainc_diff(jji) = 0.D0
          ainc_diff(jj) = ainc_diff(jj) + tmp_diff4
          tmp_diff3 = wstrip_diff(jji)
          wstrip_diff(jji) = 0.D0
          wstrip_diff(jj) = wstrip_diff(jj) + tmp_diff3
          tmp_diff2 = chord_diff(jji)
          chord_diff(jji) = 0.D0
          chord_diff(jj) = chord_diff(jj) + tmp_diff2
          tmp_diff1 = rle_diff(3, jji)
          rle_diff(3, jji) = 0.D0
          rle_diff(3, jj) = rle_diff(3, jj) + tmp_diff1
          tmp_diff0 = rle_diff(2, jji)
          rle_diff(2, jji) = 0.D0
          rle_diff(2, jj) = rle_diff(2, jj) - tmp_diff0
          tmp_diff = rle_diff(1, jji)
          rle_diff(1, jji) = 0.D0
          rle_diff(1, jj) = rle_diff(1, jj) + tmp_diff
          chord1_diff(jj) = chord1_diff(jj) + chord2_diff(jji)
          chord2_diff(jji) = 0.D0
          rle1_diff(3, jj) = rle1_diff(3, jj) + rle2_diff(3, jji)
          rle2_diff(3, jji) = 0.D0
          rle1_diff(2, jj) = rle1_diff(2, jj) - rle2_diff(2, jji)
          rle2_diff(2, jji) = 0.D0
          rle1_diff(1, jj) = rle1_diff(1, jj) + rle2_diff(1, jji)
          rle2_diff(1, jji) = 0.D0
          chord2_diff(jj) = chord2_diff(jj) + chord1_diff(jji)
          chord1_diff(jji) = 0.D0
          rle2_diff(3, jj) = rle2_diff(3, jj) + rle1_diff(3, jji)
          rle1_diff(3, jji) = 0.D0
          rle2_diff(2, jj) = rle2_diff(2, jj) - rle1_diff(2, jji)
          rle1_diff(2, jji) = 0.D0
          rle2_diff(1, jj) = rle2_diff(1, jj) + rle1_diff(1, jji)
          rle1_diff(1, jji) = 0.D0
          GOTO 120
        END IF
        CALL POPINTEGER4(ivs)
        CALL POPINTEGER4(ad_count)
        DO i=1,ad_count
          IF (i .EQ. 1) CALL POPCONTROL1B(branch)
        ENDDO
        GOTO 150
 130    STOP
 140    CALL PUSHCONTROL1B(1)
        CALL PUSHINTEGER4(ad_count0)
        STOP
      END IF
 150  CONTINUE
      END

C  Differentiation of encalc in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: ess ensy ensz xsref ysref zsref
C                rv1 rv2 rv enc env enc_d
C   with respect to varying inputs: ess ensy ensz xsref ysref zsref
C                ainc ainc_g rv1 rv2 rv slopev slopec dcontrol
C                vhinge enc env enc_d
C BDUPL
C
C
C
C
      SUBROUTINE ENCALC_B()
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
C
      REAL ep(3), eq(3), es(3), eb(3), ec(3), ecxb(3)
      REAL ep_diff(3), eq_diff(3), es_diff(3), eb_diff(3), ec_diff(3), 
     +     ecxb_diff(3)
      REAL ec_g(3, ndmax), ecxb_g(3)
      INTEGER j
      INTEGER i
      REAL dxle
      REAL dxle_diff
      REAL dyle
      REAL dyle_diff
      REAL dzle
      REAL dzle_diff
      REAL axle
      REAL axle_diff
      REAL ayle
      REAL ayle_diff
      REAL azle
      REAL azle_diff
      REAL dxte
      REAL dxte_diff
      REAL dyte
      REAL dyte_diff
      REAL dzte
      REAL dzte_diff
      REAL axte
      REAL axte_diff
      REAL ayte
      REAL ayte_diff
      REAL azte
      REAL azte_diff
      REAL dxt
      REAL dxt_diff
      REAL dyt
      REAL dyt_diff
      REAL dzt
      REAL dzt_diff
      INTRINSIC SQRT
      INTEGER nv
      INTEGER ii
      INTEGER n
      REAL dxb
      REAL dxb_diff
      REAL dyb
      REAL dyb_diff
      REAL dzb
      REAL dzb_diff
      REAL emag
      REAL emag_diff
      REAL ang
      REAL ang_diff
      INTRINSIC ATAN
      REAL sinc
      REAL sinc_diff
      INTRINSIC SIN
      REAL cosc
      REAL cosc_diff
      INTRINSIC COS
      REAL emag_g
      REAL ang_ddc
      REAL ang_ddc_diff
      REAL cosd
      REAL sind
      REAL endot
      REAL endot_diff
      REAL DOT
      REAL temp
      REAL temp0
      REAL temp_diff
      REAL temp_diff0
      INTEGER branch
      INTEGER ad_to
      INTEGER ii1
      INTEGER ii3
      INTEGER ii2
C
C...Calculate the normal vector at control points and bound vortex midpoints
C
      DO j=1,nstrip
C
C...Calculate normal vector for the strip (normal to X axis)
        CALL PUSHINTEGER4(i)
        i = ijfrst(j)
        dxle = rv2(1, i) - rv1(1, i)
        dyle = rv2(2, i) - rv1(2, i)
        dzle = rv2(3, i) - rv1(3, i)
C       AXLE = (RV2(1,I)+RV1(1,I))*0.5
C       AYLE = (RV2(2,I)+RV1(2,I))*0.5
C       AZLE = (RV2(3,I)+RV1(3,I))*0.5
C
        i = ijfrst(j) + (nvstrp(j)-1)
        dxte = rv2(1, i) - rv1(1, i)
        dyte = rv2(2, i) - rv1(2, i)
        dzte = rv2(3, i) - rv1(3, i)
C       AXTE = (RV2(1,I)+RV1(1,I))*0.5
C       AYTE = (RV2(2,I)+RV1(2,I))*0.5
C       AZTE = (RV2(3,I)+RV1(3,I))*0.5
C
        CALL PUSHREAL8(dxt)
        dxt = (1.0-saxfr)*dxle + saxfr*dxte
        CALL PUSHREAL8(dyt)
        dyt = (1.0-saxfr)*dyle + saxfr*dyte
        CALL PUSHREAL8(dzt)
        dzt = (1.0-saxfr)*dzle + saxfr*dzte
C
C
        ensy(j) = -(dzt/SQRT(dyt*dyt+dzt*dzt))
        ensz(j) = dyt/SQRT(dyt*dyt+dzt*dzt)
C
C
C
        CALL PUSHREAL8(es(1))
        es(1) = 0.
        CALL PUSHREAL8(es(2))
        es(2) = ensy(j)
        CALL PUSHREAL8(es(3))
        es(3) = ensz(j)
C
C
        nv = nvstrp(j)
        DO ii=1,nv
C
          CALL PUSHINTEGER4(i)
          i = ijfrst(j) + (ii-1)
C
C...Define unit vector along bound leg
C right h.v. pt - left h.v. pt 
          dxb = rv2(1, i) - rv1(1, i)
          dyb = rv2(2, i) - rv1(2, i)
          dzb = rv2(3, i) - rv1(3, i)
          CALL PUSHREAL8(emag)
          emag = SQRT(dxb**2 + dyb**2 + dzb**2)
          CALL PUSHREAL8(eb(1))
          eb(1) = dxb/emag
          CALL PUSHREAL8(eb(2))
          eb(2) = dyb/emag
          CALL PUSHREAL8(eb(3))
          eb(3) = dzb/emag
C
C...Define direction of normal vector at control point 
C   The YZ projection of the normal vector matches the camber slope
C   + section local incidence in the YZ defining plane for the section
          CALL PUSHREAL8(ang)
          ang = ainc(j) - ATAN(slopec(i))
Cc          IF(LDES) THEN
C--------- add design-variable contribution to angle
          DO n=1,ndesign
            ang = ang + ainc_g(j, n)*deldes(n)
          ENDDO
Cc          ENDIF
C
          CALL PUSHREAL8(sinc)
          sinc = SIN(ang)
          cosc = COS(ang)
          CALL PUSHREAL8(ec(1))
          ec(1) = cosc
          CALL PUSHREAL8(ec(2))
          ec(2) = -(sinc*es(2))
C     EC  = rotation of strip normal vector? or along chord?
          CALL PUSHREAL8(ec(3))
          ec(3) = -(sinc*es(3))
C
C...Normal vector is perpendicular to camberline vector and to the bound leg
          CALL PUSHREAL8ARRAY(ecxb, 3)
          CALL CROSS(ec, eb, ecxb)
          CALL PUSHREAL8(emag)
          emag = SQRT(ecxb(1)**2 + ecxb(2)**2 + ecxb(3)**2)
          IF (emag .NE. 0.0) THEN
            CALL PUSHREAL8(enc(1, i))
            enc(1, i) = ecxb(1)/emag
            CALL PUSHREAL8(enc(2, i))
            enc(2, i) = ecxb(2)/emag
            CALL PUSHREAL8(enc(3, i))
            enc(3, i) = ecxb(3)/emag
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHREAL8(enc(1, i))
            enc(1, i) = es(1)
            CALL PUSHREAL8(enc(2, i))
            enc(2, i) = es(2)
            CALL PUSHREAL8(enc(3, i))
            enc(3, i) = es(3)
            CALL PUSHCONTROL1B(1)
          END IF
C
C
C...Define direction of normal vector at vortex mid-point. 
C   The YZ projection of the normal vector matches the camber slope
C   + section local incidence in the YZ defining plane for the section
          CALL PUSHREAL8(ang)
          ang = ainc(j) - ATAN(slopev(i))
Cc          IF(LDES) THEN
C--------- add design-variable contribution to angle
          DO n=1,ndesign
            ang = ang + ainc_g(j, n)*deldes(n)
          ENDDO
Cc          ENDIF
C
          CALL PUSHREAL8(sinc)
          sinc = SIN(ang)
          cosc = COS(ang)
          CALL PUSHREAL8(ec(1))
          ec(1) = cosc
          CALL PUSHREAL8(ec(2))
          ec(2) = -(sinc*es(2))
          CALL PUSHREAL8(ec(3))
          ec(3) = -(sinc*es(3))
C
C...Normal vector is perpendicular to camberline vector and to the bound leg
          CALL PUSHREAL8ARRAY(ecxb, 3)
          CALL CROSS(ec, eb, ecxb)
          CALL PUSHREAL8(emag)
          emag = SQRT(ecxb(1)**2 + ecxb(2)**2 + ecxb(3)**2)
          IF (emag .NE. 0.0) THEN
            CALL PUSHREAL8(env(1, i))
            env(1, i) = ecxb(1)/emag
            CALL PUSHREAL8(env(2, i))
            env(2, i) = ecxb(2)/emag
            CALL PUSHREAL8(env(3, i))
            env(3, i) = ecxb(3)/emag
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHREAL8(env(1, i))
            env(1, i) = es(1)
            CALL PUSHREAL8(env(2, i))
            env(2, i) = es(2)
            CALL PUSHREAL8(env(3, i))
            env(3, i) = es(3)
            CALL PUSHCONTROL1B(0)
          END IF
C
C
Ccc       write(*,*) i, dcontrol(i,1), dcontrol(i,2)
C
C=======================================================
C-------- rotate normal vectors for control surface
          DO n=1,ncontrol
C
C---------- skip everything if this element is unaffected by control variable N
            IF (dcontrol(i, n) .EQ. 0.0) THEN
              CALL PUSHCONTROL1B(0)
            ELSE
C
C
C
C---------- EP = normal-vector component perpendicular to hinge line
              CALL PUSHREAL8(endot)
              endot = DOT(enc(1, i), vhinge(1, j, n))
              CALL PUSHREAL8(ep(1))
              ep(1) = enc(1, i) - endot*vhinge(1, j, n)
              CALL PUSHREAL8(ep(2))
              ep(2) = enc(2, i) - endot*vhinge(2, j, n)
              CALL PUSHREAL8(ep(3))
              ep(3) = enc(3, i) - endot*vhinge(3, j, n)
C---------- EQ = unit vector perpendicular to both EP and hinge line
              CALL CROSS(vhinge(1, j, n), ep, eq)
C
C---------- rotated vector would consist of sin,cos parts from EP and EQ,
C-          with hinge-parallel component ENDOT restored 
Cc          ENC(1,I) = EP(1)*COSD + EQ(1)*SIND + ENDOT*VHINGE(1,J,N)
Cc          ENC(2,I) = EP(2)*COSD + EQ(2)*SIND + ENDOT*VHINGE(2,J,N)
Cc          ENC(3,I) = EP(3)*COSD + EQ(3)*SIND + ENDOT*VHINGE(3,J,N)
C
C---------- linearize about zero deflection (COSD=1, SIND=0)
C
C
C---------- repeat for ENV vector
C
C---------- EP = normal-vector component perpendicular to hinge line
              CALL PUSHREAL8(endot)
              endot = DOT(env(1, i), vhinge(1, j, n))
              CALL PUSHREAL8(ep(1))
              ep(1) = env(1, i) - endot*vhinge(1, j, n)
              CALL PUSHREAL8(ep(2))
              ep(2) = env(2, i) - endot*vhinge(2, j, n)
              CALL PUSHREAL8(ep(3))
              ep(3) = env(3, i) - endot*vhinge(3, j, n)
C---------- EQ = unit vector perpendicular to both EP and hinge line
              CALL PUSHREAL8ARRAY(eq, 3)
              CALL CROSS(vhinge(1, j, n), ep, eq)
C
C---------- rotated vector would consist of sin,cos parts from EP and EQ,
C-          with hinge-parallel component ENDOT restored 
Cc          ENV(1,I) = EP(1)*COSD + EQ(1)*SIND + ENDOT*VHINGE(1,J,N)
Cc          ENV(2,I) = EP(2)*COSD + EQ(2)*SIND + ENDOT*VHINGE(2,J,N)
Cc          ENV(3,I) = EP(3)*COSD + EQ(3)*SIND + ENDOT*VHINGE(3,J,N)
C
C---------- linearize about zero deflection (COSD=1, SIND=0)
              CALL PUSHCONTROL1B(1)
            END IF
          ENDDO
        ENDDO
        CALL PUSHINTEGER4(ii - 1)
      ENDDO
      DO ii1=1,nsmax
        ainc_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,ngmax
        DO ii2=1,nsmax
          ainc_g_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvmax
        slopev_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nvmax
        slopec_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nvmax
          dcontrol_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nsmax
          DO ii3=1,3
            vhinge_diff(ii3, ii2, ii1) = 0.D0
          ENDDO
        ENDDO
      ENDDO
      DO ii1=1,3
        eb_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        ec_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        ep_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        eq_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        es_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        ecxb_diff(ii1) = 0.D0
      ENDDO
      DO j=nstrip,1,-1
        CALL POPINTEGER4(ad_to)
        DO ii=ad_to,1,-1
          i = ijfrst(j) + (ii-1)
          DO n=ncontrol,1,-1
            CALL POPCONTROL1B(branch)
            IF (branch .NE. 0) THEN
              CALL POPREAL8ARRAY(eq, 3)
              CALL CROSS_B(vhinge(1, j, n), vhinge_diff(1, j, n), ep, 
     +                     ep_diff, eq, eq_diff)
              CALL POPREAL8(ep(3))
              env_diff(3, i) = env_diff(3, i) + ep_diff(3)
              endot_diff = -(vhinge(3, j, n)*ep_diff(3)) - vhinge(2, j, 
     +          n)*ep_diff(2) - vhinge(1, j, n)*ep_diff(1)
              vhinge_diff(3, j, n) = vhinge_diff(3, j, n) - endot*
     +          ep_diff(3)
              ep_diff(3) = 0.D0
              CALL POPREAL8(ep(2))
              env_diff(2, i) = env_diff(2, i) + ep_diff(2)
              vhinge_diff(2, j, n) = vhinge_diff(2, j, n) - endot*
     +          ep_diff(2)
              ep_diff(2) = 0.D0
              CALL POPREAL8(ep(1))
              env_diff(1, i) = env_diff(1, i) + ep_diff(1)
              vhinge_diff(1, j, n) = vhinge_diff(1, j, n) - endot*
     +          ep_diff(1)
              ep_diff(1) = 0.D0
              CALL POPREAL8(endot)
              CALL DOT_B(env(1, i), env_diff(1, i), vhinge(1, j, n), 
     +                   vhinge_diff(1, j, n), endot_diff)
              ang_ddc = dtr*dcontrol(i, n)
              eq_diff(3) = eq_diff(3) + ang_ddc*enc_d_diff(3, i, n)
              ang_ddc_diff = eq(3)*enc_d_diff(3, i, n) + eq(2)*
     +          enc_d_diff(2, i, n) + eq(1)*enc_d_diff(1, i, n)
              eq_diff(2) = eq_diff(2) + ang_ddc*enc_d_diff(2, i, n)
              eq_diff(1) = eq_diff(1) + ang_ddc*enc_d_diff(1, i, n)
              CALL CROSS_B(vhinge(1, j, n), vhinge_diff(1, j, n), ep, 
     +                     ep_diff, eq, eq_diff)
              CALL POPREAL8(ep(3))
              enc_diff(3, i) = enc_diff(3, i) + ep_diff(3)
              endot_diff = -(vhinge(3, j, n)*ep_diff(3)) - vhinge(2, j, 
     +          n)*ep_diff(2) - vhinge(1, j, n)*ep_diff(1)
              vhinge_diff(3, j, n) = vhinge_diff(3, j, n) - endot*
     +          ep_diff(3)
              ep_diff(3) = 0.D0
              CALL POPREAL8(ep(2))
              enc_diff(2, i) = enc_diff(2, i) + ep_diff(2)
              vhinge_diff(2, j, n) = vhinge_diff(2, j, n) - endot*
     +          ep_diff(2)
              ep_diff(2) = 0.D0
              CALL POPREAL8(ep(1))
              enc_diff(1, i) = enc_diff(1, i) + ep_diff(1)
              vhinge_diff(1, j, n) = vhinge_diff(1, j, n) - endot*
     +          ep_diff(1)
              ep_diff(1) = 0.D0
              CALL POPREAL8(endot)
              CALL DOT_B(enc(1, i), enc_diff(1, i), vhinge(1, j, n), 
     +                   vhinge_diff(1, j, n), endot_diff)
              dcontrol_diff(i, n) = dcontrol_diff(i, n) + dtr*
     +          ang_ddc_diff
            END IF
          ENDDO
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(env(3, i))
            es_diff(3) = es_diff(3) + env_diff(3, i)
            env_diff(3, i) = 0.D0
            CALL POPREAL8(env(2, i))
            es_diff(2) = es_diff(2) + env_diff(2, i)
            env_diff(2, i) = 0.D0
            CALL POPREAL8(env(1, i))
            es_diff(1) = es_diff(1) + env_diff(1, i)
            env_diff(1, i) = 0.D0
            emag_diff = 0.D0
          ELSE
            CALL POPREAL8(env(3, i))
            ecxb_diff(3) = ecxb_diff(3) + env_diff(3, i)/emag
            emag_diff = -(ecxb(3)*env_diff(3, i)/emag**2) - ecxb(2)*
     +        env_diff(2, i)/emag**2 - ecxb(1)*env_diff(1, i)/emag**2
            env_diff(3, i) = 0.D0
            CALL POPREAL8(env(2, i))
            ecxb_diff(2) = ecxb_diff(2) + env_diff(2, i)/emag
            env_diff(2, i) = 0.D0
            CALL POPREAL8(env(1, i))
            ecxb_diff(1) = ecxb_diff(1) + env_diff(1, i)/emag
            env_diff(1, i) = 0.D0
          END IF
          CALL POPREAL8(emag)
          IF (ecxb(1)**2 + ecxb(2)**2 + ecxb(3)**2 .EQ. 0.D0) THEN
            temp_diff0 = 0.D0
          ELSE
            temp_diff0 = emag_diff/(2.0*SQRT(ecxb(1)**2+ecxb(2)**2+ecxb(
     +        3)**2))
          END IF
          ecxb_diff(1) = ecxb_diff(1) + 2*ecxb(1)*temp_diff0
          ecxb_diff(2) = ecxb_diff(2) + 2*ecxb(2)*temp_diff0
          ecxb_diff(3) = ecxb_diff(3) + 2*ecxb(3)*temp_diff0
          CALL POPREAL8ARRAY(ecxb, 3)
          CALL CROSS_B(ec, ec_diff, eb, eb_diff, ecxb, ecxb_diff)
          CALL POPREAL8(ec(3))
          sinc_diff = -(es(3)*ec_diff(3)) - es(2)*ec_diff(2)
          es_diff(3) = es_diff(3) - sinc*ec_diff(3)
          ec_diff(3) = 0.D0
          CALL POPREAL8(ec(2))
          es_diff(2) = es_diff(2) - sinc*ec_diff(2)
          ec_diff(2) = 0.D0
          CALL POPREAL8(ec(1))
          cosc_diff = ec_diff(1)
          ec_diff(1) = 0.D0
          ang_diff = COS(ang)*sinc_diff - SIN(ang)*cosc_diff
          CALL POPREAL8(sinc)
          DO n=ndesign,1,-1
            ainc_g_diff(j, n) = ainc_g_diff(j, n) + deldes(n)*ang_diff
          ENDDO
          CALL POPREAL8(ang)
          ainc_diff(j) = ainc_diff(j) + ang_diff
          slopev_diff(i) = slopev_diff(i) - ang_diff/(1.0+slopev(i)**2)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(enc(3, i))
            ecxb_diff(3) = ecxb_diff(3) + enc_diff(3, i)/emag
            emag_diff = -(ecxb(3)*enc_diff(3, i)/emag**2) - ecxb(2)*
     +        enc_diff(2, i)/emag**2 - ecxb(1)*enc_diff(1, i)/emag**2
            enc_diff(3, i) = 0.D0
            CALL POPREAL8(enc(2, i))
            ecxb_diff(2) = ecxb_diff(2) + enc_diff(2, i)/emag
            enc_diff(2, i) = 0.D0
            CALL POPREAL8(enc(1, i))
            ecxb_diff(1) = ecxb_diff(1) + enc_diff(1, i)/emag
            enc_diff(1, i) = 0.D0
          ELSE
            CALL POPREAL8(enc(3, i))
            es_diff(3) = es_diff(3) + enc_diff(3, i)
            enc_diff(3, i) = 0.D0
            CALL POPREAL8(enc(2, i))
            es_diff(2) = es_diff(2) + enc_diff(2, i)
            enc_diff(2, i) = 0.D0
            CALL POPREAL8(enc(1, i))
            es_diff(1) = es_diff(1) + enc_diff(1, i)
            enc_diff(1, i) = 0.D0
            emag_diff = 0.D0
          END IF
          CALL POPREAL8(emag)
          IF (ecxb(1)**2 + ecxb(2)**2 + ecxb(3)**2 .EQ. 0.D0) THEN
            temp_diff0 = 0.D0
          ELSE
            temp_diff0 = emag_diff/(2.0*SQRT(ecxb(1)**2+ecxb(2)**2+ecxb(
     +        3)**2))
          END IF
          ecxb_diff(1) = ecxb_diff(1) + 2*ecxb(1)*temp_diff0
          ecxb_diff(2) = ecxb_diff(2) + 2*ecxb(2)*temp_diff0
          ecxb_diff(3) = ecxb_diff(3) + 2*ecxb(3)*temp_diff0
          CALL POPREAL8ARRAY(ecxb, 3)
          CALL CROSS_B(ec, ec_diff, eb, eb_diff, ecxb, ecxb_diff)
          CALL POPREAL8(ec(3))
          sinc_diff = -(es(3)*ec_diff(3)) - es(2)*ec_diff(2)
          es_diff(3) = es_diff(3) - sinc*ec_diff(3)
          ec_diff(3) = 0.D0
          CALL POPREAL8(ec(2))
          es_diff(2) = es_diff(2) - sinc*ec_diff(2)
          ec_diff(2) = 0.D0
          CALL POPREAL8(ec(1))
          cosc_diff = ec_diff(1)
          ec_diff(1) = 0.D0
          ang_diff = COS(ang)*sinc_diff - SIN(ang)*cosc_diff
          CALL POPREAL8(sinc)
          DO n=ndesign,1,-1
            ainc_g_diff(j, n) = ainc_g_diff(j, n) + deldes(n)*ang_diff
          ENDDO
          dxb = rv2(1, i) - rv1(1, i)
          dyb = rv2(2, i) - rv1(2, i)
          CALL POPREAL8(ang)
          ainc_diff(j) = ainc_diff(j) + ang_diff
          slopec_diff(i) = slopec_diff(i) - ang_diff/(1.0+slopec(i)**2)
          dzb = rv2(3, i) - rv1(3, i)
          CALL POPREAL8(eb(3))
          emag_diff = -(dzb*eb_diff(3)/emag**2) - dyb*eb_diff(2)/emag**2
     +      - dxb*eb_diff(1)/emag**2
          CALL POPREAL8(eb(2))
          CALL POPREAL8(eb(1))
          IF (dxb**2 + dyb**2 + dzb**2 .EQ. 0.D0) THEN
            temp_diff0 = 0.D0
          ELSE
            temp_diff0 = emag_diff/(2.0*SQRT(dxb**2+dyb**2+dzb**2))
          END IF
          dzb_diff = eb_diff(3)/emag + 2*dzb*temp_diff0
          eb_diff(3) = 0.D0
          dyb_diff = eb_diff(2)/emag + 2*dyb*temp_diff0
          eb_diff(2) = 0.D0
          dxb_diff = eb_diff(1)/emag + 2*dxb*temp_diff0
          eb_diff(1) = 0.D0
          CALL POPREAL8(emag)
          rv2_diff(3, i) = rv2_diff(3, i) + dzb_diff
          rv1_diff(3, i) = rv1_diff(3, i) - dzb_diff
          rv2_diff(2, i) = rv2_diff(2, i) + dyb_diff
          rv1_diff(2, i) = rv1_diff(2, i) - dyb_diff
          rv2_diff(1, i) = rv2_diff(1, i) + dxb_diff
          rv1_diff(1, i) = rv1_diff(1, i) - dxb_diff
          DO n=ncontrol,1,-1
            enc_d_diff(3, i, n) = 0.D0
            enc_d_diff(2, i, n) = 0.D0
            enc_d_diff(1, i, n) = 0.D0
          ENDDO
          CALL POPINTEGER4(i)
        ENDDO
        CALL POPREAL8(es(3))
        ensz_diff(j) = ensz_diff(j) + es_diff(3)
        es_diff(3) = 0.D0
        CALL POPREAL8(es(2))
        ensy_diff(j) = ensy_diff(j) + es_diff(2)
        es_diff(2) = 0.D0
        CALL POPREAL8(es(1))
        es_diff(1) = 0.D0
        azle_diff = (1.0-saxfr)*zsref_diff(j)
        azte_diff = saxfr*zsref_diff(j)
        zsref_diff(j) = 0.D0
        ayle_diff = (1.0-saxfr)*ysref_diff(j)
        ayte_diff = saxfr*ysref_diff(j)
        ysref_diff(j) = 0.D0
        axle_diff = (1.0-saxfr)*xsref_diff(j)
        axte_diff = saxfr*xsref_diff(j)
        xsref_diff(j) = 0.D0
        temp0 = dyt*dyt + dzt*dzt
        temp = SQRT(temp0)
        IF (temp0 .EQ. 0.D0) THEN
          temp_diff0 = 0.D0
        ELSE
          temp_diff0 = -(dyt*ensz_diff(j)/(2.0*temp**3))
        END IF
        dyt_diff = ensz_diff(j)/temp + 2*dyt*temp_diff0
        ensz_diff(j) = 0.D0
        dzt_diff = 2*dzt*temp_diff0
        temp0 = dyt*dyt + dzt*dzt
        temp = SQRT(temp0)
        IF (temp0 .EQ. 0.D0) THEN
          temp_diff0 = 0.D0
        ELSE
          temp_diff0 = dzt*ensy_diff(j)/(2.0*temp**3)
        END IF
        dzt_diff = dzt_diff + 2*dzt*temp_diff0 - ensy_diff(j)/temp
        ensy_diff(j) = 0.D0
        dyt_diff = dyt_diff + 2*dyt*temp_diff0
        temp0 = dxt*dxt + dyt*dyt + dzt*dzt
        temp = SQRT(temp0)
        IF (temp0 .EQ. 0.D0) THEN
          temp_diff0 = 0.D0
        ELSE
          temp_diff0 = -(dzt*ess_diff(3, j)/(2.0*temp**3))
        END IF
        dzt_diff = dzt_diff + ess_diff(3, j)/temp + 2*dzt*temp_diff0
        ess_diff(3, j) = 0.D0
        dxt_diff = 2*dxt*temp_diff0
        temp0 = dxt*dxt + dyt*dyt + dzt*dzt
        temp = SQRT(temp0)
        dyt_diff = dyt_diff + 2*dyt*temp_diff0 + ess_diff(2, j)/temp
        IF (temp0 .EQ. 0.D0) THEN
          temp_diff0 = 0.D0
        ELSE
          temp_diff0 = -(dyt*ess_diff(2, j)/(2.0*temp**3))
        END IF
        ess_diff(2, j) = 0.D0
        temp = dxt*dxt + dyt*dyt + dzt*dzt
        temp0 = SQRT(temp)
        IF (temp .EQ. 0.D0) THEN
          temp_diff = 0.D0
        ELSE
          temp_diff = -(dxt*ess_diff(1, j)/(2.0*temp0**3))
        END IF
        dxt_diff = dxt_diff + 2*dxt*temp_diff0 + ess_diff(1, j)/temp0 + 
     +    2*dxt*temp_diff
        dyt_diff = dyt_diff + 2*dyt*temp_diff0 + 2*dyt*temp_diff
        dzt_diff = dzt_diff + 2*dzt*temp_diff0 + 2*dzt*temp_diff
        ess_diff(1, j) = 0.D0
        CALL POPREAL8(dzt)
        dzle_diff = (1.0-saxfr)*dzt_diff
        dzte_diff = saxfr*dzt_diff
        CALL POPREAL8(dyt)
        dyle_diff = (1.0-saxfr)*dyt_diff
        dyte_diff = saxfr*dyt_diff
        CALL POPREAL8(dxt)
        dxle_diff = (1.0-saxfr)*dxt_diff
        dxte_diff = saxfr*dxt_diff
        rv_diff(3, i) = rv_diff(3, i) + azte_diff
        rv_diff(2, i) = rv_diff(2, i) + ayte_diff
        rv_diff(1, i) = rv_diff(1, i) + axte_diff
        rv2_diff(3, i) = rv2_diff(3, i) + dzte_diff
        rv1_diff(3, i) = rv1_diff(3, i) - dzte_diff
        rv2_diff(2, i) = rv2_diff(2, i) + dyte_diff
        rv1_diff(2, i) = rv1_diff(2, i) - dyte_diff
        rv2_diff(1, i) = rv2_diff(1, i) + dxte_diff
        rv1_diff(1, i) = rv1_diff(1, i) - dxte_diff
        i = ijfrst(j)
        rv_diff(3, i) = rv_diff(3, i) + azle_diff
        rv_diff(2, i) = rv_diff(2, i) + ayle_diff
        rv_diff(1, i) = rv_diff(1, i) + axle_diff
        rv2_diff(3, i) = rv2_diff(3, i) + dzle_diff
        rv1_diff(3, i) = rv1_diff(3, i) - dzle_diff
        rv2_diff(2, i) = rv2_diff(2, i) + dyle_diff
        rv1_diff(2, i) = rv1_diff(2, i) - dyle_diff
        rv2_diff(1, i) = rv2_diff(1, i) + dxle_diff
        rv1_diff(1, i) = rv1_diff(1, i) - dxle_diff
        CALL POPINTEGER4(i)
      ENDDO
      END
C ENCALC
C

