C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) - 15 Jan 2021 14:26
C
C  Differentiation of aero in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: clff cyff cdff spanef cdtot
C                cltot cxtot cytot cztot crtot cmtot cntot crsax
C                cnsax cdvtot cdtot_d cltot_d cxtot_d cytot_d cztot_d
C                crtot_d cmtot_d cntot_d
C   with respect to varying inputs: alfa vinf sref cref bref xyzref
C                mach cdref clff cyff cdff spanef cdtot cltot cxtot
C                cytot cztot crtot cmtot cntot crsax cnsax cdvtot
C                cdtot_d cltot_d cxtot_d cytot_d cztot_d crtot_d
C                cmtot_d cntot_d rle chord rle1 chord1 rle2 chord2
C                wstrip ensy ensz xsref ysref zsref rv1 rv2 rv
C                rc gam gam_d wv
C   RW status of diff variables: alfa:out vinf:out sref:out cref:out
C                bref:out xyzref:out mach:out cdref:out clff:in-zero
C                cyff:in-zero cdff:in-zero spanef:in-zero cdtot:in-zero
C                cltot:in-zero cxtot:in-zero cytot:in-zero cztot:in-zero
C                crtot:in-zero cmtot:in-zero cntot:in-zero crsax:in-zero
C                cnsax:in-zero cdvtot:in-zero cdtot_d:in-out cltot_d:in-out
C                cxtot_d:in-out cytot_d:in-out cztot_d:in-out crtot_d:in-out
C                cmtot_d:in-out cntot_d:in-out rle:out chord:out
C                rle1:out chord1:out rle2:out chord2:out wstrip:out
C                ensy:out ensz:out xsref:out ysref:out zsref:out
C                rv1:out rv2:out rv:out rc:out gam:out gam_d:out
C                wv:out
C***********************************************************************
C    Module:  aero.f
C 
C    Copyright (C) 2002 Mark Drela, Harold Youngren
C 
C    This program is free software; you can redistribute it and/or modify
C    it under the terms of the GNU General Public License as published by
C    the Free Software Foundation; either version 2 of the License, or
C    (at your option) any later version.
C
C    This program is distributed in the hope that it will be useful,
C    but WITHOUT ANY WARRANTY; without even the implied warranty of
C    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
C    GNU General Public License for more details.
C
C    You should have received a copy of the GNU General Public License
C    along with this program; if not, write to the Free Software
C    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
C***********************************************************************
C
      SUBROUTINE AERO_B()
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
      CHARACTER*50 satype
      INTEGER l
      INTEGER n
      REAL sina
      INTRINSIC SIN
      REAL cosa
      INTRINSIC COS
      REAL dir
      EXTERNAL GETSA
      INTEGER k
      REAL vsq
      REAL vsq_diff
      REAL vmag
      REAL vmag_diff
      INTRINSIC SQRT
      INTEGER iu
      INTEGER ii1
C
      cdtot = 0.
      cltot = 0.
      cxtot = 0.
      cytot = 0.
      cztot = 0.
      crtot = 0.
      cmtot = 0.
      cntot = 0.
      cdvtot = 0.
C
      cdtot_a = 0.
      cltot_a = 0.
C
      DO l=1,ncontrol
        chinge(l) = 0.
      ENDDO
C
      DO n=1,numax
        cdtot_u(n) = 0.
        cltot_u(n) = 0.
        cxtot_u(n) = 0.
        cytot_u(n) = 0.
        cztot_u(n) = 0.
        crtot_u(n) = 0.
        cmtot_u(n) = 0.
        cntot_u(n) = 0.
        DO l=1,ncontrol
          chinge_u(l, n) = 0.
        ENDDO
      ENDDO
C
      DO n=1,ncontrol
        cdtot_d(n) = 0.
        cltot_d(n) = 0.
        cxtot_d(n) = 0.
        cytot_d(n) = 0.
        cztot_d(n) = 0.
        crtot_d(n) = 0.
        cmtot_d(n) = 0.
        cntot_d(n) = 0.
        DO l=1,ncontrol
          chinge_d(l, n) = 0.
        ENDDO
      ENDDO
C
      DO n=1,ndesign
        cdtot_g(n) = 0.
        cltot_g(n) = 0.
        cxtot_g(n) = 0.
        cytot_g(n) = 0.
        cztot_g(n) = 0.
        crtot_g(n) = 0.
        cmtot_g(n) = 0.
        cntot_g(n) = 0.
        DO l=1,ncontrol
          chinge_g(l, n) = 0.
        ENDDO
      ENDDO
C
C
      CALL PUSHREAL8ARRAY(cdv_lstrp, nsmax)
      CALL PUSHREAL8ARRAY(cmst_d, nsmax*ndmax)
      CALL PUSHREAL8ARRAY(cnst_d, nsmax*ndmax)
      CALL PUSHREAL8ARRAY(crst_d, nsmax*ndmax)
      CALL PUSHREAL8ARRAY(czst_d, nsmax*ndmax)
      CALL PUSHREAL8ARRAY(cyst_d, nsmax*ndmax)
      CALL PUSHREAL8ARRAY(cxst_d, nsmax*ndmax)
      CALL PUSHREAL8ARRAY(clst_d, nsmax*ndmax)
      CALL PUSHREAL8ARRAY(cdst_d, nsmax*ndmax)
      CALL PUSHREAL8ARRAY(cmstrp, nsmax)
      CALL PUSHREAL8ARRAY(cnstrp, nsmax)
      CALL PUSHREAL8ARRAY(crstrp, nsmax)
      CALL PUSHREAL8ARRAY(czstrp, nsmax)
      CALL PUSHREAL8ARRAY(cystrp, nsmax)
      CALL PUSHREAL8ARRAY(cxstrp, nsmax)
      CALL PUSHREAL8ARRAY(clstrp, nsmax)
      CALL PUSHREAL8ARRAY(cdstrp, nsmax)
      CALL SFFORC()
      CALL BDFORC()
C
C     calculate stability axis based values
      CALL GETSA(lnasa_sa, satype, dir)
C---------------------------------------------------------
C---- add baseline reference CD
C
      vsq = vinf(1)**2 + vinf(2)**2 + vinf(3)**2
      vmag = SQRT(vsq)
C
C
C
      CALL CALCST_B()
      vmag_diff = cdref*vinf(3)*cztot_diff + cdref*vinf(2)*cytot_diff + 
     +  cdref*vinf(1)*cxtot_diff
      IF (vsq .EQ. 0.D0) THEN
        vsq_diff = cdref*cdtot_diff + cdref*cdvtot_diff
      ELSE
        vsq_diff = cdref*cdtot_diff + cdref*cdvtot_diff + vmag_diff/(2.0
     +    *SQRT(vsq))
      END IF
      DO ii1=1,3
        vinf_diff(ii1) = 0.D0
      ENDDO
      vinf_diff(3) = vinf_diff(3) + cdref*vmag*cztot_diff + 2*vinf(3)*
     +  vsq_diff
      cdref_diff = vmag*vinf(3)*cztot_diff + vmag*vinf(2)*cytot_diff + 
     +  vmag*vinf(1)*cxtot_diff + vsq*cdtot_diff + vsq*cdvtot_diff
      vinf_diff(2) = vinf_diff(2) + cdref*vmag*cytot_diff + 2*vinf(2)*
     +  vsq_diff
      vinf_diff(1) = vinf_diff(1) + cdref*vmag*cxtot_diff + 2*vinf(1)*
     +  vsq_diff
      DO k=ncontrol,1,-1
        cntot_d_diff(k) = dir*cntot_d_diff(k)
        crtot_d_diff(k) = dir*crtot_d_diff(k)
      ENDDO
      CALL TPFORC_B()
      CALL BDFORC_B()
      CALL POPREAL8ARRAY(cdstrp, nsmax)
      CALL POPREAL8ARRAY(clstrp, nsmax)
      CALL POPREAL8ARRAY(cxstrp, nsmax)
      CALL POPREAL8ARRAY(cystrp, nsmax)
      CALL POPREAL8ARRAY(czstrp, nsmax)
      CALL POPREAL8ARRAY(crstrp, nsmax)
      CALL POPREAL8ARRAY(cnstrp, nsmax)
      CALL POPREAL8ARRAY(cmstrp, nsmax)
      CALL POPREAL8ARRAY(cdst_d, nsmax*ndmax)
      CALL POPREAL8ARRAY(clst_d, nsmax*ndmax)
      CALL POPREAL8ARRAY(cxst_d, nsmax*ndmax)
      CALL POPREAL8ARRAY(cyst_d, nsmax*ndmax)
      CALL POPREAL8ARRAY(czst_d, nsmax*ndmax)
      CALL POPREAL8ARRAY(crst_d, nsmax*ndmax)
      CALL POPREAL8ARRAY(cnst_d, nsmax*ndmax)
      CALL POPREAL8ARRAY(cmst_d, nsmax*ndmax)
      CALL POPREAL8ARRAY(cdv_lstrp, nsmax)
      CALL SFFORC_B()
      DO n=ncontrol,1,-1
        cntot_d_diff(n) = 0.D0
        cmtot_d_diff(n) = 0.D0
        crtot_d_diff(n) = 0.D0
        cztot_d_diff(n) = 0.D0
        cytot_d_diff(n) = 0.D0
        cxtot_d_diff(n) = 0.D0
        cltot_d_diff(n) = 0.D0
        cdtot_d_diff(n) = 0.D0
      ENDDO
      clff_diff = 0.D0
      cyff_diff = 0.D0
      cdff_diff = 0.D0
      spanef_diff = 0.D0
      cdtot_diff = 0.D0
      cltot_diff = 0.D0
      cxtot_diff = 0.D0
      cytot_diff = 0.D0
      cztot_diff = 0.D0
      crtot_diff = 0.D0
      cmtot_diff = 0.D0
      cntot_diff = 0.D0
      crsax_diff = 0.D0
      cnsax_diff = 0.D0
      cdvtot_diff = 0.D0
      END

C  Differentiation of sfforc in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: alfa vinf sref cref bref xyzref
C                cdtot cltot cxtot cytot cztot crtot cmtot cntot
C                cdvtot cdtot_d cltot_d cxtot_d cytot_d cztot_d
C                crtot_d cmtot_d cntot_d rv1 rv2 gam
C   with respect to varying inputs: alfa vinf sref cref bref xyzref
C                cdtot_d cltot_d cxtot_d cytot_d cztot_d crtot_d
C                cmtot_d cntot_d rle chord rle1 chord1 rle2 chord2
C                wstrip ensy ensz xsref ysref zsref rv1 rv2 rv
C                gam gam_d wv
C AERO
C
C
C
      SUBROUTINE SFFORC_B()
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
C
      REAL rrot(3)
      REAL rrot_diff(3)
      REAL veff(3), vrot(3), veff_u(3, 6), vrot_u(3), wrot_u(3)
      REAL veff_diff(3), vrot_diff(3)
      REAL vperp(3)
      REAL g(3), r(3), rh(3), mh(3)
      REAL g_diff(3), r_diff(3)
      REAL f(3), f_u(3, 6)
      REAL f_diff(3)
      REAL fgam(3), fgam_u(3, 6), fgam_d(3, ndmax), fgam_g(3, ngmax)
      REAL fgam_diff(3), fgam_d_diff(3, ndmax)
      REAL enave(3), spn(3), udrag(3), ulift(3)
      REAL spn_diff(3), udrag_diff(3), ulift_diff(3)
C
      REAL cfx_u(numax), cfy_u(numax), cfz_u(numax), cmx_u(numax), cmy_u
     +     (numax), cmz_u(numax), cfx_d(ndmax), cfy_d(ndmax), cfz_d(
     +     ndmax), cmx_d(ndmax), cmy_d(ndmax), cmz_d(ndmax), cfx_g(ngmax
     +     ), cfy_g(ngmax), cfz_g(ngmax), cmx_g(ngmax), cmy_g(ngmax), 
     +     cmz_g(ngmax), clv_u(numax), clv_d(ndmax), clv_g(ngmax)
      REAL cfx_d_diff(ndmax), cfy_d_diff(ndmax), cfz_d_diff(ndmax), 
     +     cmx_d_diff(ndmax), cmy_d_diff(ndmax), cmz_d_diff(ndmax), 
     +     clv_d_diff(ndmax)
      REAL sina
      REAL sina_diff
      INTRINSIC SIN
      REAL cosa
      REAL cosa_diff
      INTRINSIC COS
      INTEGER j
      INTEGER i1
      INTEGER nvc_strp
      REAL cr
      REAL cr_diff
      REAL sr
      REAL sr_diff
      REAL xte1
      REAL xte1_diff
      REAL xte2
      REAL xte2_diff
      REAL ulmag
      REAL ulmag_diff
      REAL DOT
      INTRINSIC SQRT
      REAL xr
      REAL xr_diff
      REAL yr
      REAL yr_diff
      REAL zr
      REAL zr_diff
      REAL cfx
      REAL cfx_diff
      REAL cfy
      REAL cfy_diff
      REAL cfz
      REAL cfz_diff
      REAL cmx
      REAL cmx_diff
      REAL cmy
      REAL cmy_diff
      REAL cmz
      REAL cmz_diff
      INTEGER n
      INTEGER ii
      INTEGER i
      INTEGER k
      REAL fnv
      REAL fnv_u
      REAL fnv_d
      REAL fnv_g
      REAL dcfx
      REAL dcfx_diff
      REAL dcfy
      REAL dcfy_diff
      REAL dcfz
      REAL dcfz_diff
      REAL dcfx_u
      REAL dcfy_u
      REAL dcfz_u
      REAL dcfx_d
      REAL dcfx_d_diff
      REAL dcfy_d
      REAL dcfy_d_diff
      REAL dcfz_d
      REAL dcfz_d_diff
      REAL dcfx_g
      REAL dcfy_g
      REAL dcfz_g
      INTEGER l
      REAL dfac
      INTEGER ileg
      REAL veffmag
      REAL veffmag_diff
      REAL clv
      REAL clv_diff
      REAL cdv
      REAL cdv_diff
      REAL cdv_clv
      REAL cdv_clv_diff
      REAL dcvfx
      REAL dcvfx_diff
      REAL dcvfy
      REAL dcvfy_diff
      REAL dcvfz
      REAL dcvfz_diff
      REAL dcvfx_u
      REAL dcvfy_u
      REAL dcvfz_u
      REAL dcvfx_d
      REAL dcvfx_d_diff
      REAL dcvfy_d
      REAL dcvfy_d_diff
      REAL dcvfz_d
      REAL dcvfz_d_diff
      REAL dcvfx_g
      REAL dcvfy_g
      REAL dcvfz_g
      REAL vsq
      REAL vsqi
      REAL vspan
      REAL vpsq
      REAL vpsqi
      REAL delx
      REAL dely
      REAL delz
      REAL dmag
      INTEGER is
      INTEGER nstrps
      INTEGER jj
      INTEGER l1
      INTRINSIC MOD
      INTEGER l2
      REAL dcm
      REAL enmag
      REAL result1
      REAL result1_diff
      REAL result2
      REAL(kind=8) temp_diff
      REAL(kind=avl_real) temp_diff0
      REAL temp_diff1
      INTEGER ii1
      REAL temp_diff2
      INTEGER branch
      INTEGER ad_to
      INTEGER ii2
C
C
      sina = SIN(alfa)
      cosa = COS(alfa)
      CALL PUSHREAL8ARRAY(f, 3)
      CALL PUSHREAL8ARRAY(g, 3)
      CALL PUSHREAL8ARRAY(r, 3)
      CALL PUSHREAL8ARRAY(udrag, 3)
      CALL PUSHREAL8ARRAY(cfx_d, ndmax)
      CALL PUSHREAL8ARRAY(cfz_d, ndmax)
      CALL PUSHREAL8ARRAY(vrot, 3)
      CALL PUSHREAL8ARRAY(clv_d, ndmax)
      CALL PUSHREAL8ARRAY(veff, 3)
      CALL PUSHREAL8ARRAY(ulift, 3)
      CALL PUSHREAL8ARRAY(fgam, 3)
      CALL PUSHREAL8ARRAY(rrot, 3)
      CALL PUSHREAL8ARRAY(cfy_d, ndmax)
      CALL PUSHREAL8ARRAY(fgam_d, 3*ndmax)
      CALL PUSHREAL8ARRAY(spn, 3)
C$FWD-OF II-LOOP 
C
C***********************************************************************
C...Integrate the forces strip-wise, surface-wise and total-wise
C***********************************************************************
C
C...Calculate strip forces...
C    normalized to strip reference quantities (strip area, chord)
      DO j=1,nstrip
C
        i1 = ijfrst(j)
        nvc_strp = nvstrp(j)
C
        cr = chord(j)
        sr = chord(j)*wstrip(j)
C
        xte1 = rle1(1, j) + chord1(j)
        xte2 = rle2(1, j) + chord2(j)
C
C--- Define local strip lift and drag directions
C--- The "spanwise" vector is cross product of strip normal with X chordline 
        spn(1) = 0.0
        spn(2) = ensz(j)
        spn(3) = -ensy(j)
C--- Stability axes stream vector defines drag direction
        udrag(1) = cosa
        udrag(2) = 0.0
        udrag(3) = sina
C--- Lift direction is vector product of "stream" and spanwise vector
        CALL CROSS(udrag, spn, ulift)
        result1 = DOT(ulift, ulift)
        ulmag = SQRT(result1)
        IF (ulmag .EQ. 0.) THEN
          ulift(3) = 1.0
        ELSE
          ulift(1) = ulift(1)/ulmag
          ulift(2) = ulift(2)/ulmag
          ulift(3) = ulift(3)/ulmag
        END IF
C
C...Use the strip 1/4 chord location for strip moments
        xr = rle(1, j) + 0.25*cr
        yr = rle(2, j)
        zr = rle(3, j)
C
        cfx = 0.
        cfy = 0.
        cfz = 0.
        cmx = 0.
        cmy = 0.
        cmz = 0.
        cnc(j) = 0.
C
        DO n=1,numax
          cfx_u(n) = 0.
          cfy_u(n) = 0.
          cfz_u(n) = 0.
          cmx_u(n) = 0.
          cmy_u(n) = 0.
          cmz_u(n) = 0.
          cnc_u(j, n) = 0.
        ENDDO
C
        DO n=1,ncontrol
          cfx_d(n) = 0.
          cfy_d(n) = 0.
          cfz_d(n) = 0.
          cmx_d(n) = 0.
          cmy_d(n) = 0.
          cmz_d(n) = 0.
          cnc_d(j, n) = 0.
        ENDDO
C
        DO n=1,ndesign
          cfx_g(n) = 0.
          cfy_g(n) = 0.
          cfz_g(n) = 0.
          cmx_g(n) = 0.
          cmy_g(n) = 0.
          cmz_g(n) = 0.
          cnc_g(j, n) = 0.
        ENDDO
C
C...Sum the forces in the strip as generated by velocity
C    (freestream + rotation + induced) acting on bound vortex 
        DO ii=1,nvc_strp
          i = i1 + (ii-1)
C
C------- local moment reference vector from vortex midpoint to strip c/4 pt.
C          R(1) = 0.5*(RV1(1,I) + RV2(1,I)) - XR
C          R(2) = 0.5*(RV1(2,I) + RV2(2,I)) - YR
C          R(3) = 0.5*(RV1(3,I) + RV2(3,I)) - ZR
          r(1) = rv(1, i) - xr
          r(2) = rv(2, i) - yr
          r(3) = rv(3, i) - zr
C
C------- vector from rotation axes
C          RROT(1) = 0.5*(RV1(1,I) + RV2(1,I)) - XYZREF(1)
C          RROT(2) = 0.5*(RV1(2,I) + RV2(2,I)) - XYZREF(2)
C          RROT(3) = 0.5*(RV1(3,I) + RV2(3,I)) - XYZREF(3)
          rrot(1) = rv(1, i) - xyzref(1)
          rrot(2) = rv(2, i) - xyzref(2)
          rrot(3) = rv(3, i) - xyzref(3)
C
C-------- set total effective velocity = freestream + rotation + induced
          CALL CROSS(rrot, wrot, vrot)
          veff(1) = vinf(1) + vrot(1) + wv(1, i)
          veff(2) = vinf(2) + vrot(2) + wv(2, i)
C$AD II-LOOP
          veff(3) = vinf(3) + vrot(3) + wv(3, i)
C
C-------- set VEFF sensitivities to freestream,rotation components
          DO k=1,3
            veff_u(1, k) = wv_u(1, i, k)
            veff_u(2, k) = wv_u(2, i, k)
            veff_u(3, k) = wv_u(3, i, k)
            veff_u(k, k) = 1.0 + veff_u(k, k)
          ENDDO
          DO k=4,6
            wrot_u(1) = 0.
            wrot_u(2) = 0.
            wrot_u(3) = 0.
            wrot_u(k-3) = 1.0
            CALL CROSS(rrot, wrot_u, vrot_u)
            veff_u(1, k) = vrot_u(1) + wv_u(1, i, k)
            veff_u(2, k) = vrot_u(2) + wv_u(2, i, k)
            veff_u(3, k) = vrot_u(3) + wv_u(3, i, k)
          ENDDO
C
C-------- Force coefficient on vortex segment is 2(Veff x Gamma)
          g(1) = rv2(1, i) - rv1(1, i)
          g(2) = rv2(2, i) - rv1(2, i)
          g(3) = rv2(3, i) - rv1(3, i)
          CALL CROSS(veff, g, f)
          DO n=1,numax
            CALL CROSS(veff_u(1, n), g, f_u(1, n))
          ENDDO
C
          fgam(1) = 2.0*gam(i)*f(1)
          fgam(2) = 2.0*gam(i)*f(2)
C$AD II-LOOP
          fgam(3) = 2.0*gam(i)*f(3)
          DO n=1,numax
            fgam_u(1, n) = 2.0*gam_u(i, n)*f(1) + 2.0*gam(i)*f_u(1, n)
            fgam_u(2, n) = 2.0*gam_u(i, n)*f(2) + 2.0*gam(i)*f_u(2, n)
            fgam_u(3, n) = 2.0*gam_u(i, n)*f(3) + 2.0*gam(i)*f_u(3, n)
          ENDDO
          DO n=1,ncontrol
            fgam_d(1, n) = 2.0*gam_d(i, n)*f(1)
            fgam_d(2, n) = 2.0*gam_d(i, n)*f(2)
            fgam_d(3, n) = 2.0*gam_d(i, n)*f(3)
          ENDDO
          DO n=1,ndesign
            fgam_g(1, n) = 2.0*gam_g(i, n)*f(1)
            fgam_g(2, n) = 2.0*gam_g(i, n)*f(2)
            fgam_g(3, n) = 2.0*gam_g(i, n)*f(3)
          ENDDO
C
C
C-------- Delta Cp (loading across lifting surface) from vortex 
          fnv = DOT(env(1, i), fgam)
C$AD II-LOOP
          dcp(i) = fnv/(dxv(i)*wstrip(j))
C
          DO n=1,numax
            fnv_u = DOT(env(1, i), fgam_u(1, n))
            dcp_u(i, n) = fnv_u/(dxv(i)*wstrip(j))
          ENDDO
C
          DO n=1,ncontrol
            result1 = DOT(env(1, i), fgam_d(1, n))
            result2 = DOT(env_d(1, i, n), fgam)
            fnv_d = result1 + result2
            dcp_d(i, n) = fnv_d/(dxv(i)*wstrip(j))
          ENDDO
C
          DO n=1,ndesign
            result1 = DOT(env(1, i), fgam_g(1, n))
            result2 = DOT(env_g(1, i, n), fgam)
            fnv_g = result1 + result2
            dcp_g(i, n) = fnv_g/(dxv(i)*wstrip(j))
          ENDDO
C
C-------- vortex contribution to strip forces
          dcfx = fgam(1)/sr
          dcfy = fgam(2)/sr
          dcfz = fgam(3)/sr
C
C-------- forces normalized by strip area
          cfx = cfx + dcfx
          cfy = cfy + dcfy
          cfz = cfz + dcfz
C
C-------- moments referred to strip c/4 pt., normalized by strip chord and area
          cmx = cmx + (dcfz*r(2)-dcfy*r(3))/cr
          cmy = cmy + (dcfx*r(3)-dcfz*r(1))/cr
          cmz = cmz + (dcfy*r(1)-dcfx*r(2))/cr
C
C-------- accumulate strip spanloading = c*CN
C$AD II-LOOP
          cnc(j) = cnc(j) + cr*(ensy(j)*dcfy+ensz(j)*dcfz)
C
C-------- freestream and rotation derivatives
          DO n=1,numax
            dcfx_u = fgam_u(1, n)/sr
            dcfy_u = fgam_u(2, n)/sr
            dcfz_u = fgam_u(3, n)/sr
C
            cfx_u(n) = cfx_u(n) + dcfx_u
            cfy_u(n) = cfy_u(n) + dcfy_u
            cfz_u(n) = cfz_u(n) + dcfz_u
            cmx_u(n) = cmx_u(n) + (dcfz_u*r(2)-dcfy_u*r(3))/cr
            cmy_u(n) = cmy_u(n) + (dcfx_u*r(3)-dcfz_u*r(1))/cr
            cmz_u(n) = cmz_u(n) + (dcfy_u*r(1)-dcfx_u*r(2))/cr
C
            cnc_u(j, n) = cnc_u(j, n) + cr*(ensy(j)*dcfy_u+ensz(j)*
     +        dcfz_u)
          ENDDO
C
C-------- control derivatives
          DO n=1,ncontrol
            dcfx_d = fgam_d(1, n)/sr
            dcfy_d = fgam_d(2, n)/sr
            dcfz_d = fgam_d(3, n)/sr
C
            cfx_d(n) = cfx_d(n) + dcfx_d
            cfy_d(n) = cfy_d(n) + dcfy_d
            cfz_d(n) = cfz_d(n) + dcfz_d
            cmx_d(n) = cmx_d(n) + (dcfz_d*r(2)-dcfy_d*r(3))/cr
            cmy_d(n) = cmy_d(n) + (dcfx_d*r(3)-dcfz_d*r(1))/cr
            cmz_d(n) = cmz_d(n) + (dcfy_d*r(1)-dcfx_d*r(2))/cr
C
            cnc_d(j, n) = cnc_d(j, n) + cr*(ensy(j)*dcfy_d+ensz(j)*
     +        dcfz_d)
          ENDDO
C
C-------- design derivatives
          DO n=1,ndesign
            dcfx_g = fgam_g(1, n)/sr
            dcfy_g = fgam_g(2, n)/sr
            dcfz_g = fgam_g(3, n)/sr
C
            cfx_g(n) = cfx_g(n) + dcfx_g
            cfy_g(n) = cfy_g(n) + dcfy_g
            cfz_g(n) = cfz_g(n) + dcfz_g
            cmx_g(n) = cmx_g(n) + (dcfz_g*r(2)-dcfy_g*r(3))/cr
            cmy_g(n) = cmy_g(n) + (dcfx_g*r(3)-dcfz_g*r(1))/cr
            cmz_g(n) = cmz_g(n) + (dcfy_g*r(1)-dcfx_g*r(2))/cr
C
            cnc_g(j, n) = cnc_g(j, n) + cr*(ensy(j)*dcfy_g+ensz(j)*
     +        dcfz_g)
          ENDDO
C
C-------- hinge moments
          DO l=1,ncontrol
            rh(1) = rv(1, i) - phinge(1, j, l)
            rh(2) = rv(2, i) - phinge(2, j, l)
            rh(3) = rv(3, i) - phinge(3, j, l)
C
            dfac = dcontrol(i, l)/(sref*cref)
C
            CALL CROSS(rh, fgam, mh)
            result1 = DOT(mh, vhinge(1, j, l))
            chinge(l) = chinge(l) + result1*dfac
C
            DO n=1,numax
              CALL CROSS(rh, fgam_u(1, n), mh)
              result1 = DOT(mh, vhinge(1, j, l))
              chinge_u(l, n) = chinge_u(l, n) + result1*dfac
            ENDDO
            DO n=1,ncontrol
              CALL CROSS(rh, fgam_d(1, n), mh)
              result1 = DOT(mh, vhinge(1, j, l))
              chinge_d(l, n) = chinge_d(l, n) + result1*dfac
            ENDDO
            DO n=1,ndesign
              CALL CROSS(rh, fgam_g(1, n), mh)
              result1 = DOT(mh, vhinge(1, j, l))
              chinge_g(l, n) = chinge_g(l, n) + result1*dfac
            ENDDO
          ENDDO
        ENDDO
C
C
C
        IF (ltrforce) THEN
C
C...Sum forces in the strip as generated by velocity (freestream + rotation)
C     the parts of trailing legs which lie on the surface
          DO ii=1,nvc_strp
            i = i1 + (ii-1)
C
            DO ileg=1,2
              IF (ileg .EQ. 1) THEN
C----------- local moment reference vector from vortex midpoint to strip c/4 pt
                r(1) = 0.5*(rv1(1, i)+xte1) - xr
                r(2) = rv1(2, i) - yr
                r(3) = rv1(3, i) - zr
C 
C----------- vector from rotation axes
                rrot(1) = 0.5*(rv1(1, i)+xte1) - xyzref(1)
                rrot(2) = rv1(2, i) - xyzref(2)
                rrot(3) = rv1(3, i) - xyzref(3)
C
C----------- part of trailing leg lying on surface
                g(1) = rv1(1, i) - xte1
                g(2) = 0.
                g(3) = 0.
C
              ELSE
C----------- local moment reference vector from vortex midpoint to strip c/4 pt
                r(1) = 0.5*(rv2(1, i)+xte2) - xr
                r(2) = rv2(2, i) - yr
                r(3) = rv2(3, i) - zr
C
C----------- vector from rotation axes
                rrot(1) = 0.5*(rv2(1, i)+xte2) - xyzref(1)
                rrot(2) = rv2(2, i) - xyzref(2)
                rrot(3) = rv2(3, i) - xyzref(3)
C
C----------- part of trailing leg lying on surface
                g(1) = xte2 - rv2(1, i)
                g(2) = 0.
                g(3) = 0.
              END IF
C
C---------- set total effective velocity = freestream + rotation
              CALL CROSS(rrot, wrot, vrot)
              veff(1) = vinf(1) + vrot(1)
              veff(2) = vinf(2) + vrot(2)
C$AD II-LOOP
              veff(3) = vinf(3) + vrot(3)
C
C---------- set VEFF sensitivities to freestream,rotation components
              DO k=1,3
                veff_u(1, k) = 0.
                veff_u(2, k) = 0.
                veff_u(3, k) = 0.
                veff_u(k, k) = 1.0
              ENDDO
              DO k=4,6
                wrot_u(1) = 0.
                wrot_u(2) = 0.
                wrot_u(3) = 0.
                wrot_u(k-3) = 1.0
                CALL CROSS(rrot, wrot_u, vrot_u)
                veff_u(1, k) = vrot_u(1)
                veff_u(2, k) = vrot_u(2)
                veff_u(3, k) = vrot_u(3)
              ENDDO
C
C---------- Force coefficient on vortex segment is 2(Veff x Gamma)
              CALL CROSS(veff, g, f)
C
              DO n=1,numax
                CALL CROSS(veff_u(1, n), g, f_u(1, n))
              ENDDO
C
              fgam(1) = 2.0*gam(i)*f(1)
              fgam(2) = 2.0*gam(i)*f(2)
C$AD II-LOOP
              fgam(3) = 2.0*gam(i)*f(3)
              DO n=1,numax
                fgam_u(1, n) = 2.0*gam_u(i, n)*f(1) + 2.0*gam(i)*f_u(1, 
     +            n)
                fgam_u(2, n) = 2.0*gam_u(i, n)*f(2) + 2.0*gam(i)*f_u(2, 
     +            n)
                fgam_u(3, n) = 2.0*gam_u(i, n)*f(3) + 2.0*gam(i)*f_u(3, 
     +            n)
              ENDDO
              DO n=1,ncontrol
                fgam_d(1, n) = 2.0*gam_d(i, n)*f(1)
                fgam_d(2, n) = 2.0*gam_d(i, n)*f(2)
                fgam_d(3, n) = 2.0*gam_d(i, n)*f(3)
              ENDDO
              DO n=1,ndesign
                fgam_g(1, n) = 2.0*gam_g(i, n)*f(1)
                fgam_g(2, n) = 2.0*gam_g(i, n)*f(2)
                fgam_g(3, n) = 2.0*gam_g(i, n)*f(3)
              ENDDO
C
CC---------- Delta Cp (loading across lifting surface) due to vortex 
C            FNV = DOT(ENV(1,I),FGAM)
C            DCP(I) = FNV / (DXV(I)*WSTRIP(J))
CC
C            DO N = 1, NUMAX
C              FNV_U = DOT(ENV(1,I),FGAM_U(1,N))
C              DCP_U(I,N) = FNV_U / (DXV(I)*WSTRIP(J))
C            ENDDO
CC
C            DO N = 1, NCONTROL
C              FNV_D = DOT(ENV(1,I),FGAM_D(1,N)) + DOT(ENV_D(1,I,N),FGAM)
C              DCP_D(I,N) = FNV_D / (DXV(I)*WSTRIP(J))
C            ENDDO
CC
C            DO N = 1, NDESIGN
C              FNV_G = DOT(ENV(1,I),FGAM_G(1,N)) + DOT(ENV_G(1,I,N),FGAM)
C              DCP_G(I,N) = FNV_G / (DXV(I)*WSTRIP(J))
C            ENDDO
C
C
C---------- vortex contribution to strip forces
              dcfx = fgam(1)/sr
              dcfy = fgam(2)/sr
              dcfz = fgam(3)/sr
C
C---------- forces normalized by strip area
              cfx = cfx + dcfx
              cfy = cfy + dcfy
              cfz = cfz + dcfz
C
C---------- moments referred to strip c/4 pt., normalized by strip chord and area
              cmx = cmx + (dcfz*r(2)-dcfy*r(3))/cr
              cmy = cmy + (dcfx*r(3)-dcfz*r(1))/cr
              cmz = cmz + (dcfy*r(1)-dcfx*r(2))/cr
C
C---------- accumulate strip spanloading = c*CN
              cnc(j) = cnc(j) + cr*(ensy(j)*dcfy+ensz(j)*dcfz)
C
C---------- freestream and rotation derivatives
              DO n=1,numax
                dcfx_u = fgam_u(1, n)/sr
                dcfy_u = fgam_u(2, n)/sr
                dcfz_u = fgam_u(3, n)/sr
C
                cfx_u(n) = cfx_u(n) + dcfx_u
                cfy_u(n) = cfy_u(n) + dcfy_u
                cfz_u(n) = cfz_u(n) + dcfz_u
                cmx_u(n) = cmx_u(n) + (dcfz_u*r(2)-dcfy_u*r(3))/cr
                cmy_u(n) = cmy_u(n) + (dcfx_u*r(3)-dcfz_u*r(1))/cr
                cmz_u(n) = cmz_u(n) + (dcfy_u*r(1)-dcfx_u*r(2))/cr
C
                cnc_u(j, n) = cnc_u(j, n) + cr*(ensy(j)*dcfy_u+ensz(j)*
     +            dcfz_u)
              ENDDO
C
C---------- control derivatives
              DO n=1,ncontrol
                dcfx_d = fgam_d(1, n)/sr
                dcfy_d = fgam_d(2, n)/sr
                dcfz_d = fgam_d(3, n)/sr
C  
                cfx_d(n) = cfx_d(n) + dcfx_d
                cfy_d(n) = cfy_d(n) + dcfy_d
                cfz_d(n) = cfz_d(n) + dcfz_d
                cmx_d(n) = cmx_d(n) + (dcfz_d*r(2)-dcfy_d*r(3))/cr
                cmy_d(n) = cmy_d(n) + (dcfx_d*r(3)-dcfz_d*r(1))/cr
                cmz_d(n) = cmz_d(n) + (dcfy_d*r(1)-dcfx_d*r(2))/cr
C  
                cnc_d(j, n) = cnc_d(j, n) + cr*(ensy(j)*dcfy_d+ensz(j)*
     +            dcfz_d)
              ENDDO
C
C---------- design derivatives
              DO n=1,ndesign
                dcfx_g = fgam_g(1, n)/sr
                dcfy_g = fgam_g(2, n)/sr
                dcfz_g = fgam_g(3, n)/sr
C
                cfx_g(n) = cfx_g(n) + dcfx_g
                cfy_g(n) = cfy_g(n) + dcfy_g
                cfz_g(n) = cfz_g(n) + dcfz_g
                cmx_g(n) = cmx_g(n) + (dcfz_g*r(2)-dcfy_g*r(3))/cr
                cmy_g(n) = cmy_g(n) + (dcfx_g*r(3)-dcfz_g*r(1))/cr
                cmz_g(n) = cmz_g(n) + (dcfy_g*r(1)-dcfx_g*r(2))/cr
C
                cnc_g(j, n) = cnc_g(j, n) + cr*(ensy(j)*dcfy_g+ensz(j)*
     +            dcfz_g)
              ENDDO
            ENDDO
          ENDDO
        END IF
C
CC---------- hinge moments
C            DO L=1, NCONTROL
C              RH(1) = RV(1,I) - PHINGE(1,J,L)
C              RH(2) = RV(2,I) - PHINGE(2,J,L)
C              RH(3) = RV(3,I) - PHINGE(3,J,L)
CC
C              DFAC = DCONTROL(I,L) / (SREF * CREF)
CC
C              CALL CROSS(RH,FGAM,MH)
C              CHINGE(L) = CHINGE(L) + DOT(MH,VHINGE(1,J,L))*DFAC
CC
C              DO N = 1, NUMAX
C                CALL CROSS(RH,FGAM_U(1,N),MH)
C                CHINGE_U(L,N) = CHINGE_U(L,N) + DOT(MH,VHINGE(1,J,L))*DFAC
C              ENDDO
C              DO N = 1, NCONTROL
C                CALL CROSS(RH,FGAM_D(1,N),MH)
C                CHINGE_D(L,N) = CHINGE_D(L,N) + DOT(MH,VHINGE(1,J,L))*DFAC
C              ENDDO
C              DO N = 1, NDESIGN
C                CALL CROSS(RH,FGAM_G(1,N),MH)
C                CHINGE_G(L,N) = CHINGE_G(L,N) + DOT(MH,VHINGE(1,J,L))*DFAC
C              ENDDO
C            ENDDO
C
C
C
C*******************************************************************
C--- Drag terms due to viscous effects
C    Drag forces are assumed to be characterized by velocity at the c/4 
C    point and are assumed to act thru the same point. CD is defined by 
C    user-specified CD(CL) polar.  Drag comes from function lookup on 
C    section polar drag using local lift coefficient.  
C
        cdv_lstrp(j) = 0.0
C
        IF (lvisc .AND. lviscstrp(j)) THEN
C--- local moment reference vector from ref point to c/4 point
C         R(1) = XR - XR
C         R(2) = YR - YR
C         R(3) = ZR - ZR
C--- Get rotational velocity at strip 1/4 chord reference point 
          rrot(1) = xr - xyzref(1)
          rrot(2) = yr - xyzref(2)
          rrot(3) = zr - xyzref(3)
C--- Onset velocity at strip c/4 = freestream + rotation
          CALL CROSS(rrot, wrot, vrot)
          veff(1) = vinf(1) + vrot(1)
          veff(2) = vinf(2) + vrot(2)
          veff(3) = vinf(3) + vrot(3)
          veffmag = SQRT(veff(1)**2 + veff(2)**2 + veff(3)**2)
C
C------- set sensitivities to freestream,rotation components
          DO k=1,3
            veff_u(1, k) = 0.
            veff_u(2, k) = 0.
            veff_u(3, k) = 0.
          ENDDO
          veff_u(1, 1) = 1.0
          veff_u(2, 2) = 1.0
          veff_u(3, 3) = 1.0
          DO k=4,6
            wrot_u(1) = 0.
            wrot_u(2) = 0.
            wrot_u(3) = 0.
            wrot_u(k-3) = 1.0
            CALL CROSS(rrot, wrot_u, vrot_u)
            veff_u(1, k) = vrot_u(1)
            veff_u(2, k) = vrot_u(2)
            veff_u(3, k) = vrot_u(3)
          ENDDO
C
C--- Generate CD from stored function using strip CL as parameter
          clv = ulift(1)*cfx + ulift(2)*cfy + ulift(3)*cfz
          DO n=1,numax
            clv_u(n) = ensy(j)*cfy_u(n) + ensz(j)*(cfz_u(n)*cosa-cfx_u(n
     +        )*sina)
          ENDDO
C
          DO n=1,ncontrol
            clv_d(n) = ensy(j)*cfy_d(n) + ensz(j)*(cfz_d(n)*cosa-cfx_d(n
     +        )*sina)
          ENDDO
C
          DO n=1,ndesign
            clv_g(n) = ensy(j)*cfy_g(n) + ensz(j)*(cfz_g(n)*cosa-cfx_g(n
     +        )*sina)
          ENDDO
C
          CALL CDCL(j, clv, cdv, cdv_clv)
C
C--- Strip viscous force contribution (per unit strip area)
          dcvfx = veff(1)*veffmag*cdv
          dcvfy = veff(2)*veffmag*cdv
          dcvfz = veff(3)*veffmag*cdv
C
C--- Add viscous terms to strip forces and moments
          cfx = cfx + dcvfx
          cfy = cfy + dcvfy
          cfz = cfz + dcvfz
C--- Viscous forces acting at c/4 have no effect on moments at c/4 pt.
C         CMX = CMX + (DCVFZ*R(2) - DCVFY*R(3))/CR
C         CMY = CMY + (DCVFX*R(3) - DCVFZ*R(1))/CR
C         CMZ = CMZ + (DCVFY*R(1) - DCVFX*R(2))/CR
C
C$AD II-LOOP
          cdv_lstrp(j) = udrag(1)*dcvfx + udrag(2)*dcvfy + udrag(3)*
     +      dcvfz
C
C--- Add the sensitivity of viscous forces to the flow conditions
          DO n=1,numax
            dcvfx_u = veff_u(1, n)*(veffmag+veff(1)**2/veffmag)*cdv + 
     +        veff(1)*veffmag*cdv_clv*clv_u(n)
            dcvfy_u = veff_u(2, n)*(veffmag+veff(2)**2/veffmag)*cdv + 
     +        veff(2)*veffmag*cdv_clv*clv_u(n)
            dcvfz_u = veff_u(3, n)*(veffmag+veff(3)**2/veffmag)*cdv + 
     +        veff(3)*veffmag*cdv_clv*clv_u(n)
C
            cfx_u(n) = cfx_u(n) + dcvfx_u
            cfy_u(n) = cfy_u(n) + dcvfy_u
            cfz_u(n) = cfz_u(n) + dcvfz_u
C--- Viscous forces acting at c/4 have no effect on moments at c/4 pt.
C           CMX_U(N) = CMX_U(N) + (DCVFZ_U*R(2) - DCVFY_U*R(3))/CR
C           CMY_U(N) = CMY_U(N) + (DCVFX_U*R(3) - DCVFZ_U*R(1))/CR
C           CMZ_U(N) = CMZ_U(N) + (DCVFY_U*R(1) - DCVFX_U*R(2))/CR
C
            cnc_u(j, n) = cnc_u(j, n) + cr*(ensy(j)*dcvfy_u+ensz(j)*
     +        dcvfz_u)
          ENDDO
C
          DO n=1,ncontrol
            dcvfx_d = veff(1)*veffmag*cdv_clv*clv_d(n)
            dcvfy_d = veff(2)*veffmag*cdv_clv*clv_d(n)
            dcvfz_d = veff(3)*veffmag*cdv_clv*clv_d(n)
C
            cfx_d(n) = cfx_d(n) + dcvfx_d
            cfy_d(n) = cfy_d(n) + dcvfy_d
            cfz_d(n) = cfz_d(n) + dcvfz_d
C--- Viscous forces acting at c/4 have no effect on moments at c/4 pt.
C           CMX_D(N) = CMX_D(N) + (DCVFZ_D*R(2) - DCVFY_D*R(3))/CR
C           CMY_D(N) = CMY_D(N) + (DCVFX_D*R(3) - DCVFZ_D*R(1))/CR
C           CMZ_D(N) = CMZ_D(N) + (DCVFY_D*R(1) - DCVFX_D*R(2))/CR
C
            cnc_d(j, n) = cnc_d(j, n) + cr*(ensy(j)*dcvfy_d+ensz(j)*
     +        dcvfz_d)
          ENDDO
C
          DO n=1,ndesign
            dcvfx_g = veff(1)*veffmag*cdv_clv*clv_g(n)
            dcvfy_g = veff(2)*veffmag*cdv_clv*clv_g(n)
            dcvfz_g = veff(3)*veffmag*cdv_clv*clv_g(n)
C
            cfx_g(n) = cfx_g(n) + dcvfx_g
            cfy_g(n) = cfy_g(n) + dcvfy_g
            cfz_g(n) = cfz_g(n) + dcvfz_g
C--- Viscous forces acting at c/4 have no effect on moments at c/4 pt.
C           CMX_G(N) = CMX_G(N) + (DCVFZ_G*R(2) - DCVFY_G*R(3))/CR
C           CMY_G(N) = CMY_G(N) + (DCVFX_G*R(3) - DCVFZ_G*R(1))/CR
C           CMZ_G(N) = CMZ_G(N) + (DCVFY_G*R(1) - DCVFX_G*R(2))/CR
C
            cnc_g(j, n) = cnc_g(j, n) + cr*(ensy(j)*dcvfy_g+ensz(j)*
     +        dcvfz_g)
          ENDDO
        END IF
C
C
C*******************************************************************
C
C---  At this point the forces are accumulated for the strip in body axes,
C     referenced to strip 1/4 chord and normalized by strip area and chord
C     CFX, CFY, CFZ   ! body axes forces 
C     CMX, CMY, CMZ   ! body axes moments about c/4 point 
C     CNC             ! strip spanloading CN*chord
C     CDV_LSTRP       ! strip viscous drag in stability axes
C
C...Store strip X,Y,Z body axes forces and moments 
C   referred to c/4 and strip area and chord
        cf_strp(1, j) = cfx
        cf_strp(2, j) = cfy
        cf_strp(3, j) = cfz
        cm_strp(1, j) = cmx
        cm_strp(2, j) = cmy
        cm_strp(3, j) = cmz
C
C...Strip body axes forces, referred to strip area and chord
        cxstrp(j) = cfx
        cystrp(j) = cfy
        czstrp(j) = cfz
C...Transform strip body axes forces into stability axes,
C   referred to strip area and chord
        cdstrp(j) = cfx*cosa + cfz*sina
        clstrp(j) = -(cfx*sina) + cfz*cosa
C
        cdst_a(j) = -(cfx*sina) + cfz*cosa
        clst_a(j) = -(cfx*cosa) - cfz*sina
C
        DO n=1,numax
          cdst_u(j, n) = cfx_u(n)*cosa + cfz_u(n)*sina
          clst_u(j, n) = -(cfx_u(n)*sina) + cfz_u(n)*cosa
          cxst_u(j, n) = cfx_u(n)
          cyst_u(j, n) = cfy_u(n)
          czst_u(j, n) = cfz_u(n)
        ENDDO
C
        DO n=1,ncontrol
          cdst_d(j, n) = cfx_d(n)*cosa + cfz_d(n)*sina
          clst_d(j, n) = -(cfx_d(n)*sina) + cfz_d(n)*cosa
          cxst_d(j, n) = cfx_d(n)
          cyst_d(j, n) = cfy_d(n)
          czst_d(j, n) = cfz_d(n)
        ENDDO
C
        DO n=1,ndesign
          cdst_g(j, n) = cfx_g(n)*cosa + cfz_g(n)*sina
          clst_g(j, n) = -(cfx_g(n)*sina) + cfz_g(n)*cosa
          cxst_g(j, n) = cfx_g(n)
          cyst_g(j, n) = cfy_g(n)
          czst_g(j, n) = cfz_g(n)
        ENDDO
C
C------ vector from chord c/4 reference point to case reference point XYZREF 
        r(1) = xr - xyzref(1)
        r(2) = yr - xyzref(2)
        r(3) = zr - xyzref(3)
C... Strip moments in body axes about the case moment reference point XYZREF 
C    normalized by strip area and chord
        crstrp(j) = cmx + (cfz*r(2)-cfy*r(3))/cr
        cmstrp(j) = cmy + (cfx*r(3)-cfz*r(1))/cr
        cnstrp(j) = cmz + (cfy*r(1)-cfx*r(2))/cr
C
        DO n=1,numax
          crst_u(j, n) = cmx_u(n) + (cfz_u(n)*r(2)-cfy_u(n)*r(3))/cr
          cmst_u(j, n) = cmy_u(n) + (cfx_u(n)*r(3)-cfz_u(n)*r(1))/cr
          cnst_u(j, n) = cmz_u(n) + (cfy_u(n)*r(1)-cfx_u(n)*r(2))/cr
        ENDDO
C
        DO n=1,ncontrol
          crst_d(j, n) = cmx_d(n) + (cfz_d(n)*r(2)-cfy_d(n)*r(3))/cr
          cmst_d(j, n) = cmy_d(n) + (cfx_d(n)*r(3)-cfz_d(n)*r(1))/cr
          cnst_d(j, n) = cmz_d(n) + (cfy_d(n)*r(1)-cfx_d(n)*r(2))/cr
        ENDDO
C
        DO n=1,ndesign
          crst_g(j, n) = cmx_g(n) + (cfz_g(n)*r(2)-cfy_g(n)*r(3))/cr
          cmst_g(j, n) = cmy_g(n) + (cfx_g(n)*r(3)-cfz_g(n)*r(1))/cr
          cnst_g(j, n) = cmz_g(n) + (cfy_g(n)*r(1)-cfx_g(n)*r(2))/cr
        ENDDO
C
C...Components of X,Y,Z forces in local strip axes 
C   axial/normal forces and lift/drag in plane normal to dihedral of strip
        cl_lstrp(j) = ulift(1)*cfx + ulift(2)*cfy + ulift(3)*cfz
        cd_lstrp(j) = udrag(1)*cfx + udrag(2)*cfy + udrag(3)*cfz
        caxlstrp(j) = cfx
        cnrmstrp(j) = ensy(j)*cfy + ensz(j)*cfz
        cmc4(j) = ensz(j)*cmy - ensy(j)*cmz
C
C------ vector at chord reference point from rotation axes
        rrot(1) = xsref(j) - xyzref(1)
        rrot(2) = ysref(j) - xyzref(2)
        rrot(3) = zsref(j) - xyzref(3)
C        print *,"WROT ",WROT
C
C------ set total effective velocity = freestream + rotation
        CALL CROSS(rrot, wrot, vrot)
        veff(1) = vinf(1) + vrot(1)
        veff(2) = vinf(2) + vrot(2)
        veff(3) = vinf(3) + vrot(3)
C
        vsq = veff(1)**2 + veff(2)**2 + veff(3)**2
        IF (vsq .EQ. 0.0) THEN
          vsqi = 1.0
        ELSE
          vsqi = 1.0/vsq
        END IF
C
C------ spanwise and perpendicular velocity components
        vspan = veff(1)*ess(1, j) + veff(2)*ess(2, j) + veff(3)*ess(3, j
     +    )
        vperp(1) = veff(1) - ess(1, j)*vspan
        vperp(2) = veff(2) - ess(2, j)*vspan
        vperp(3) = veff(3) - ess(3, j)*vspan
C
        vpsq = vperp(1)**2 + vperp(2)**2 + vperp(3)**2
        IF (vpsq .EQ. 0.0) THEN
          vpsqi = 1.0
        ELSE
          vpsqi = 1.0/vpsq
        END IF
Ccc     CLTSTRP(J) = CNRMSTRP(J) * VPSQI
        cltstrp(j) = cl_lstrp(j)*vpsqi
        clastrp(j) = cl_lstrp(j)*vsqi
C
C--- Moment about strip LE midpoint in direction of LE segment
        r(1) = xr - rle(1, j)
        r(2) = yr - rle(2, j)
        r(3) = zr - rle(3, j)
        delx = rle2(1, j) - rle1(1, j)
        dely = rle2(2, j) - rle1(2, j)
        delz = rle2(3, j) - rle1(3, j)
C
        IF (imags(nsurfs(j)) .LT. 0) THEN
          delx = -delx
          dely = -dely
          delz = -delz
        END IF
        dmag = SQRT(delx**2 + dely**2 + delz**2)
        cmle(j) = 0.0
        IF (dmag .NE. 0.0) cmle(j) = delx/dmag*(cmx+(cfz*r(2)-cfy*r(3))/
     +      cr) + dely/dmag*(cmy+(cfx*r(3)-cfz*r(1))/cr) + delz/dmag*(
     +      cmz+(cfy*r(1)-cfx*r(2))/cr)
      ENDDO
C
C
C
C
C...Surface forces and moments summed from strip forces...
C   XXSURF values normalized to configuration reference quantities
C   XX_SRF values normalized to each surface reference quantities
      DO is=1,nsurf
C
        nstrps = nj(is)
        DO jj=1,nstrps
          CALL PUSHINTEGER4(j)
          j = jfrst(is) + jj - 1
          CALL PUSHREAL8(sr)
          sr = chord(j)*wstrip(j)
          CALL PUSHREAL8(cr)
          cr = chord(j)
C
C
C--- Surface lift and drag referenced to case SREF, CREF, BREF 
C--- Surface body axes forces referenced to case SREF, CREF, BREF
C--- Surface body axes moments referenced to case SREF, CREF, BREF about XYZREF
C
C--- Bug fix, HHY/S.Allmaras 
C--- Surface viscous drag referenced to case SREF, CREF, BREF
C
        ENDDO
        CALL PUSHINTEGER4(jj - 1)
C
C---  Surface hinge moments defined by surface LE moment about hinge vector 
Ccc        CMLE_SRF(IS) = DOT(CM_SRF(1,IS),VHINGE(1,IS))
C
C
C-------------------------------------------------
        IF (lfload(is)) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
      ENDDO
C-------------------------------------------------
C
C
C--- If case is XZ symmetric (IYSYM=1), add contributions from images,
C    zero out the asymmetric forces and double the symmetric ones
      IF (iysym .EQ. 1) THEN
        DO n=ncontrol,1,-1
          cntot_d_diff(n) = 0.D0
          cmtot_d_diff(n) = 2.0*cmtot_d_diff(n)
          crtot_d_diff(n) = 0.D0
          cztot_d_diff(n) = 2.0*cztot_d_diff(n)
          cytot_d_diff(n) = 0.D0
          cxtot_d_diff(n) = 2.0*cxtot_d_diff(n)
          cltot_d_diff(n) = 2.0*cltot_d_diff(n)
          cdtot_d_diff(n) = 2.0*cdtot_d_diff(n)
        ENDDO
        cdvtot_diff = 2.0*cdvtot_diff
        cmtot_diff = 2.0*cmtot_diff
        cztot_diff = 2.0*cztot_diff
        cxtot_diff = 2.0*cxtot_diff
        cltot_diff = 2.0*cltot_diff
        cdtot_diff = 2.0*cdtot_diff
        cytot_diff = 0.D0
        crtot_diff = 0.D0
        cntot_diff = 0.D0
      END IF
      DO ii1=1,nfmax
        cdsurf_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nfmax
        clsurf_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nfmax
        cxsurf_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nfmax
        cysurf_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nfmax
        czsurf_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nfmax
        crsurf_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nfmax
        cnsurf_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nfmax
        cmsurf_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nfmax
        cdvsurf_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nfmax
          cds_d_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nfmax
          cls_d_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nfmax
          cxs_d_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nfmax
          cys_d_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nfmax
          czs_d_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nfmax
          crs_d_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nfmax
          cns_d_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nfmax
          cms_d_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nsmax
        chord_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        wstrip_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        cdstrp_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        clstrp_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        cxstrp_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        cystrp_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        czstrp_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        crstrp_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        cnstrp_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        cmstrp_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nsmax
          cdst_d_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nsmax
          clst_d_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nsmax
          cxst_d_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nsmax
          cyst_d_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nsmax
          czst_d_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nsmax
          crst_d_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nsmax
          cnst_d_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nsmax
          cmst_d_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nsmax
        cdv_lstrp_diff(ii1) = 0.D0
      ENDDO
      DO is=nsurf,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          DO n=ncontrol,1,-1
            cns_d_diff(is, n) = cns_d_diff(is, n) + cntot_d_diff(n)
            cms_d_diff(is, n) = cms_d_diff(is, n) + cmtot_d_diff(n)
            crs_d_diff(is, n) = crs_d_diff(is, n) + crtot_d_diff(n)
            czs_d_diff(is, n) = czs_d_diff(is, n) + cztot_d_diff(n)
            cys_d_diff(is, n) = cys_d_diff(is, n) + cytot_d_diff(n)
            cxs_d_diff(is, n) = cxs_d_diff(is, n) + cxtot_d_diff(n)
            cls_d_diff(is, n) = cls_d_diff(is, n) + cltot_d_diff(n)
            cds_d_diff(is, n) = cds_d_diff(is, n) + cdtot_d_diff(n)
          ENDDO
          cnsurf_diff(is) = cnsurf_diff(is) + cntot_diff
          cmsurf_diff(is) = cmsurf_diff(is) + cmtot_diff
          crsurf_diff(is) = crsurf_diff(is) + crtot_diff
          cdvsurf_diff(is) = cdvsurf_diff(is) + cdvtot_diff
          clsurf_diff(is) = clsurf_diff(is) + cltot_diff
          cdsurf_diff(is) = cdsurf_diff(is) + cdtot_diff
          czsurf_diff(is) = czsurf_diff(is) + cztot_diff
          cysurf_diff(is) = cysurf_diff(is) + cytot_diff
          cxsurf_diff(is) = cxsurf_diff(is) + cxtot_diff
        END IF
        CALL POPINTEGER4(ad_to)
        DO jj=ad_to,1,-1
          sr_diff = 0.D0
          cr_diff = 0.D0
          DO n=ncontrol,1,-1
            temp_diff = cns_d_diff(is, n)/(sref*bref)
            cnst_d_diff(j, n) = cnst_d_diff(j, n) + sr*cr*temp_diff
            temp_diff1 = cnst_d(j, n)*temp_diff
            temp_diff0 = -(cnst_d(j, n)*sr*cr*temp_diff/(sref*bref))
            sref_diff = sref_diff + bref*temp_diff0
            bref_diff = bref_diff + sref*temp_diff0
            sr_diff = sr_diff + cr*temp_diff1
            cr_diff = cr_diff + sr*temp_diff1
            temp_diff = cms_d_diff(is, n)/(sref*cref)
            cmst_d_diff(j, n) = cmst_d_diff(j, n) + sr*cr*temp_diff
            temp_diff1 = cmst_d(j, n)*temp_diff
            temp_diff0 = -(cmst_d(j, n)*sr*cr*temp_diff/(sref*cref))
            sref_diff = sref_diff + cref*temp_diff0
            cref_diff = cref_diff + sref*temp_diff0
            sr_diff = sr_diff + cr*temp_diff1
            cr_diff = cr_diff + sr*temp_diff1
            temp_diff = crs_d_diff(is, n)/(sref*bref)
            crst_d_diff(j, n) = crst_d_diff(j, n) + sr*cr*temp_diff
            temp_diff1 = crst_d(j, n)*temp_diff
            temp_diff0 = -(crst_d(j, n)*sr*cr*temp_diff/(sref*bref))
            bref_diff = bref_diff + sref*temp_diff0
            cr_diff = cr_diff + sr*temp_diff1
            czst_d_diff(j, n) = czst_d_diff(j, n) + sr*czs_d_diff(is, n)
     +        /sref
            temp_diff = czst_d(j, n)*czs_d_diff(is, n)/sref
            sref_diff = sref_diff + bref*temp_diff0 - sr*temp_diff/sref
            sr_diff = sr_diff + cr*temp_diff1 + temp_diff
            cyst_d_diff(j, n) = cyst_d_diff(j, n) + sr*cys_d_diff(is, n)
     +        /sref
            temp_diff = cyst_d(j, n)*cys_d_diff(is, n)/sref
            sr_diff = sr_diff + temp_diff
            sref_diff = sref_diff - sr*temp_diff/sref
            cxst_d_diff(j, n) = cxst_d_diff(j, n) + sr*cxs_d_diff(is, n)
     +        /sref
            temp_diff = cxst_d(j, n)*cxs_d_diff(is, n)/sref
            sr_diff = sr_diff + temp_diff
            sref_diff = sref_diff - sr*temp_diff/sref
            clst_d_diff(j, n) = clst_d_diff(j, n) + sr*cls_d_diff(is, n)
     +        /sref
            temp_diff = clst_d(j, n)*cls_d_diff(is, n)/sref
            sr_diff = sr_diff + temp_diff
            sref_diff = sref_diff - sr*temp_diff/sref
            cdst_d_diff(j, n) = cdst_d_diff(j, n) + sr*cds_d_diff(is, n)
     +        /sref
            temp_diff = cdst_d(j, n)*cds_d_diff(is, n)/sref
            sr_diff = sr_diff + temp_diff
            sref_diff = sref_diff - sr*temp_diff/sref
          ENDDO
          cdv_lstrp_diff(j) = cdv_lstrp_diff(j) + sr*cdvsurf_diff(is)/
     +      sref
          temp_diff = cdv_lstrp(j)*cdvsurf_diff(is)/sref
          sr_diff = sr_diff + temp_diff
          sref_diff = sref_diff - sr*temp_diff/sref
          temp_diff = cnsurf_diff(is)/(sref*bref)
          cnstrp_diff(j) = cnstrp_diff(j) + sr*cr*temp_diff
          sr_diff = sr_diff + cr*cnstrp(j)*temp_diff
          cr_diff = cr_diff + sr*cnstrp(j)*temp_diff
          temp_diff0 = -(cnstrp(j)*sr*cr*temp_diff/(sref*bref))
          sref_diff = sref_diff + bref*temp_diff0
          bref_diff = bref_diff + sref*temp_diff0
          temp_diff = cmsurf_diff(is)/(sref*cref)
          cmstrp_diff(j) = cmstrp_diff(j) + sr*cr*temp_diff
          sr_diff = sr_diff + cr*cmstrp(j)*temp_diff
          cr_diff = cr_diff + sr*cmstrp(j)*temp_diff
          temp_diff0 = -(cmstrp(j)*sr*cr*temp_diff/(sref*cref))
          sref_diff = sref_diff + cref*temp_diff0
          cref_diff = cref_diff + sref*temp_diff0
          temp_diff = crsurf_diff(is)/(sref*bref)
          crstrp_diff(j) = crstrp_diff(j) + sr*cr*temp_diff
          sr_diff = sr_diff + cr*crstrp(j)*temp_diff
          cr_diff = cr_diff + sr*crstrp(j)*temp_diff
          temp_diff0 = -(crstrp(j)*sr*cr*temp_diff/(sref*bref))
          bref_diff = bref_diff + sref*temp_diff0
          czstrp_diff(j) = czstrp_diff(j) + sr*czsurf_diff(is)/sref
          temp_diff = czstrp(j)*czsurf_diff(is)/sref
          sref_diff = sref_diff + bref*temp_diff0 - sr*temp_diff/sref
          sr_diff = sr_diff + temp_diff
          cystrp_diff(j) = cystrp_diff(j) + sr*cysurf_diff(is)/sref
          temp_diff = cystrp(j)*cysurf_diff(is)/sref
          sr_diff = sr_diff + temp_diff
          sref_diff = sref_diff - sr*temp_diff/sref
          cxstrp_diff(j) = cxstrp_diff(j) + sr*cxsurf_diff(is)/sref
          temp_diff = cxstrp(j)*cxsurf_diff(is)/sref
          sr_diff = sr_diff + temp_diff
          sref_diff = sref_diff - sr*temp_diff/sref
          clstrp_diff(j) = clstrp_diff(j) + sr*clsurf_diff(is)/sref
          temp_diff = clstrp(j)*clsurf_diff(is)/sref
          sr_diff = sr_diff + temp_diff
          sref_diff = sref_diff - sr*temp_diff/sref
          cdstrp_diff(j) = cdstrp_diff(j) + sr*cdsurf_diff(is)/sref
          temp_diff = cdstrp(j)*cdsurf_diff(is)/sref
          sr_diff = sr_diff + temp_diff
          sref_diff = sref_diff - sr*temp_diff/sref
          CALL POPREAL8(cr)
          chord_diff(j) = chord_diff(j) + cr_diff + wstrip(j)*sr_diff
          CALL POPREAL8(sr)
          wstrip_diff(j) = wstrip_diff(j) + chord(j)*sr_diff
          CALL POPINTEGER4(j)
        ENDDO
        DO n=ncontrol,1,-1
          cns_d_diff(is, n) = 0.D0
          cms_d_diff(is, n) = 0.D0
          crs_d_diff(is, n) = 0.D0
          czs_d_diff(is, n) = 0.D0
          cys_d_diff(is, n) = 0.D0
          cxs_d_diff(is, n) = 0.D0
          cls_d_diff(is, n) = 0.D0
          cds_d_diff(is, n) = 0.D0
        ENDDO
        cdvsurf_diff(is) = 0.D0
        cnsurf_diff(is) = 0.D0
        cmsurf_diff(is) = 0.D0
        crsurf_diff(is) = 0.D0
        czsurf_diff(is) = 0.D0
        cysurf_diff(is) = 0.D0
        cxsurf_diff(is) = 0.D0
        clsurf_diff(is) = 0.D0
        cdsurf_diff(is) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        DO ii2=1,3
          rle_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nsmax
        DO ii2=1,3
          rle1_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nsmax
        chord1_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        DO ii2=1,3
          rle2_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nsmax
        chord2_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        ensy_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        ensz_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        xsref_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        ysref_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        zsref_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nvmax
        DO ii2=1,3
          rv_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nvmax
          gam_d_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvmax
        DO ii2=1,3
          wv_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,3
        f_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        g_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        r_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        udrag_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        cmy_d_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        cfx_d_diff(ii1) = 0.D0
      ENDDO
      cosa_diff = 0.D0
      DO ii1=1,ndmax
        cfz_d_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        vrot_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        clv_d_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        cmx_d_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        veff_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        ulift_diff(ii1) = 0.D0
      ENDDO
      sina_diff = 0.D0
      DO ii1=1,3
        fgam_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        cmz_d_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        rrot_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        cfy_d_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,3
          fgam_d_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,3
        spn_diff(ii1) = 0.D0
      ENDDO
      CALL POPREAL8ARRAY(spn, 3)
      CALL POPREAL8ARRAY(fgam_d, 3*ndmax)
      CALL POPREAL8ARRAY(cfy_d, ndmax)
      CALL POPREAL8ARRAY(rrot, 3)
      CALL POPREAL8ARRAY(fgam, 3)
      CALL POPREAL8ARRAY(ulift, 3)
      CALL POPREAL8ARRAY(veff, 3)
      CALL POPREAL8ARRAY(clv_d, ndmax)
      CALL POPREAL8ARRAY(vrot, 3)
      CALL POPREAL8ARRAY(cfz_d, ndmax)
      CALL POPREAL8ARRAY(cfx_d, ndmax)
      CALL POPREAL8ARRAY(udrag, 3)
      CALL POPREAL8ARRAY(r, 3)
      CALL POPREAL8ARRAY(g, 3)
      CALL POPREAL8ARRAY(f, 3)
C$BWD-OF II-LOOP 
      DO j=1,nstrip
C
        i1 = ijfrst(j)
        nvc_strp = nvstrp(j)
C
        cr = chord(j)
        sr = chord(j)*wstrip(j)
C
        xte1 = rle1(1, j) + chord1(j)
        xte2 = rle2(1, j) + chord2(j)
C
C--- Define local strip lift and drag directions
C--- The "spanwise" vector is cross product of strip normal with X chordline 
        spn(1) = 0.0
        spn(2) = ensz(j)
        spn(3) = -ensy(j)
C--- Stability axes stream vector defines drag direction
        udrag(1) = cosa
        udrag(2) = 0.0
        udrag(3) = sina
C--- Lift direction is vector product of "stream" and spanwise vector
        CALL CROSS(udrag, spn, ulift)
        result1 = DOT(ulift, ulift)
        ulmag = SQRT(result1)
        IF (ulmag .EQ. 0.) THEN
          CALL PUSHREAL8(ulift(3))
          ulift(3) = 1.0
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL8(ulift(1))
          ulift(1) = ulift(1)/ulmag
          CALL PUSHREAL8(ulift(2))
          ulift(2) = ulift(2)/ulmag
          CALL PUSHREAL8(ulift(3))
          ulift(3) = ulift(3)/ulmag
          CALL PUSHCONTROL1B(1)
        END IF
C
C...Use the strip 1/4 chord location for strip moments
        xr = rle(1, j) + 0.25*cr
        yr = rle(2, j)
        zr = rle(3, j)
C
        cfx = 0.
        cfy = 0.
        cfz = 0.
C
        DO n=1,ncontrol
          cfx_d(n) = 0.
          cfy_d(n) = 0.
          cfz_d(n) = 0.
        ENDDO
        CALL PUSHREAL8ARRAY(f, 3)
        CALL PUSHREAL8ARRAY(g, 3)
        CALL PUSHREAL8ARRAY(r, 3)
        CALL PUSHREAL8ARRAY(vrot, 3)
        CALL PUSHREAL8ARRAY(veff, 3)
        CALL PUSHREAL8(result1)
        CALL PUSHREAL8ARRAY(fgam, 3)
        CALL PUSHREAL8ARRAY(rrot, 3)
        CALL PUSHREAL8ARRAY(fgam_d, 3*ndmax)
C$FWD-OF II-LOOP 
C
C...Sum the forces in the strip as generated by velocity
C    (freestream + rotation + induced) acting on bound vortex 
        DO ii=1,nvc_strp
          i = i1 + (ii-1)
C
C------- local moment reference vector from vortex midpoint to strip c/4 pt.
C          R(1) = 0.5*(RV1(1,I) + RV2(1,I)) - XR
C          R(2) = 0.5*(RV1(2,I) + RV2(2,I)) - YR
C          R(3) = 0.5*(RV1(3,I) + RV2(3,I)) - ZR
          r(1) = rv(1, i) - xr
          r(2) = rv(2, i) - yr
          r(3) = rv(3, i) - zr
C
C------- vector from rotation axes
C          RROT(1) = 0.5*(RV1(1,I) + RV2(1,I)) - XYZREF(1)
C          RROT(2) = 0.5*(RV1(2,I) + RV2(2,I)) - XYZREF(2)
C          RROT(3) = 0.5*(RV1(3,I) + RV2(3,I)) - XYZREF(3)
          rrot(1) = rv(1, i) - xyzref(1)
          rrot(2) = rv(2, i) - xyzref(2)
          rrot(3) = rv(3, i) - xyzref(3)
C
C-------- set total effective velocity = freestream + rotation + induced
          CALL CROSS(rrot, wrot, vrot)
          veff(1) = vinf(1) + vrot(1) + wv(1, i)
          veff(2) = vinf(2) + vrot(2) + wv(2, i)
C$AD II-LOOP
          veff(3) = vinf(3) + vrot(3) + wv(3, i)
C
C-------- set VEFF sensitivities to freestream,rotation components
          DO k=1,3
            veff_u(1, k) = wv_u(1, i, k)
            veff_u(2, k) = wv_u(2, i, k)
            veff_u(3, k) = wv_u(3, i, k)
            veff_u(k, k) = 1.0 + veff_u(k, k)
          ENDDO
          DO k=4,6
            wrot_u(1) = 0.
            wrot_u(2) = 0.
            wrot_u(3) = 0.
            wrot_u(k-3) = 1.0
            CALL CROSS(rrot, wrot_u, vrot_u)
            veff_u(1, k) = vrot_u(1) + wv_u(1, i, k)
            veff_u(2, k) = vrot_u(2) + wv_u(2, i, k)
            veff_u(3, k) = vrot_u(3) + wv_u(3, i, k)
          ENDDO
C
C-------- Force coefficient on vortex segment is 2(Veff x Gamma)
          g(1) = rv2(1, i) - rv1(1, i)
          g(2) = rv2(2, i) - rv1(2, i)
          g(3) = rv2(3, i) - rv1(3, i)
          CALL CROSS(veff, g, f)
          DO n=1,numax
            CALL CROSS(veff_u(1, n), g, f_u(1, n))
          ENDDO
C
          fgam(1) = 2.0*gam(i)*f(1)
          fgam(2) = 2.0*gam(i)*f(2)
C$AD II-LOOP
          fgam(3) = 2.0*gam(i)*f(3)
          DO n=1,numax
            fgam_u(1, n) = 2.0*gam_u(i, n)*f(1) + 2.0*gam(i)*f_u(1, n)
            fgam_u(2, n) = 2.0*gam_u(i, n)*f(2) + 2.0*gam(i)*f_u(2, n)
            fgam_u(3, n) = 2.0*gam_u(i, n)*f(3) + 2.0*gam(i)*f_u(3, n)
          ENDDO
          DO n=1,ncontrol
            fgam_d(1, n) = 2.0*gam_d(i, n)*f(1)
            fgam_d(2, n) = 2.0*gam_d(i, n)*f(2)
            fgam_d(3, n) = 2.0*gam_d(i, n)*f(3)
          ENDDO
          DO n=1,ndesign
            fgam_g(1, n) = 2.0*gam_g(i, n)*f(1)
            fgam_g(2, n) = 2.0*gam_g(i, n)*f(2)
            fgam_g(3, n) = 2.0*gam_g(i, n)*f(3)
          ENDDO
C
C
C-------- Delta Cp (loading across lifting surface) from vortex 
          fnv = DOT(env(1, i), fgam)
C$AD II-LOOP
          dcp(i) = fnv/(dxv(i)*wstrip(j))
C
          DO n=1,numax
            fnv_u = DOT(env(1, i), fgam_u(1, n))
            dcp_u(i, n) = fnv_u/(dxv(i)*wstrip(j))
          ENDDO
C
          DO n=1,ncontrol
            result1 = DOT(env(1, i), fgam_d(1, n))
            result2 = DOT(env_d(1, i, n), fgam)
            fnv_d = result1 + result2
            dcp_d(i, n) = fnv_d/(dxv(i)*wstrip(j))
          ENDDO
C
          DO n=1,ndesign
            result1 = DOT(env(1, i), fgam_g(1, n))
            result2 = DOT(env_g(1, i, n), fgam)
            fnv_g = result1 + result2
            dcp_g(i, n) = fnv_g/(dxv(i)*wstrip(j))
          ENDDO
C
C-------- vortex contribution to strip forces
          dcfx = fgam(1)/sr
          dcfy = fgam(2)/sr
          dcfz = fgam(3)/sr
C
C-------- forces normalized by strip area
          cfx = cfx + dcfx
          cfy = cfy + dcfy
          cfz = cfz + dcfz
C
C-------- moments referred to strip c/4 pt., normalized by strip chord and area
          cmx = cmx + (dcfz*r(2)-dcfy*r(3))/cr
          cmy = cmy + (dcfx*r(3)-dcfz*r(1))/cr
          cmz = cmz + (dcfy*r(1)-dcfx*r(2))/cr
C
C-------- accumulate strip spanloading = c*CN
C$AD II-LOOP
          cnc(j) = cnc(j) + cr*(ensy(j)*dcfy+ensz(j)*dcfz)
C
C-------- freestream and rotation derivatives
          DO n=1,numax
            dcfx_u = fgam_u(1, n)/sr
            dcfy_u = fgam_u(2, n)/sr
            dcfz_u = fgam_u(3, n)/sr
C
            cfx_u(n) = cfx_u(n) + dcfx_u
            cfy_u(n) = cfy_u(n) + dcfy_u
            cfz_u(n) = cfz_u(n) + dcfz_u
            cmx_u(n) = cmx_u(n) + (dcfz_u*r(2)-dcfy_u*r(3))/cr
            cmy_u(n) = cmy_u(n) + (dcfx_u*r(3)-dcfz_u*r(1))/cr
            cmz_u(n) = cmz_u(n) + (dcfy_u*r(1)-dcfx_u*r(2))/cr
C
            cnc_u(j, n) = cnc_u(j, n) + cr*(ensy(j)*dcfy_u+ensz(j)*
     +        dcfz_u)
          ENDDO
C
C-------- control derivatives
          DO n=1,ncontrol
            dcfx_d = fgam_d(1, n)/sr
            dcfy_d = fgam_d(2, n)/sr
            dcfz_d = fgam_d(3, n)/sr
C
            cfx_d(n) = cfx_d(n) + dcfx_d
            cfy_d(n) = cfy_d(n) + dcfy_d
            cfz_d(n) = cfz_d(n) + dcfz_d
            cmx_d(n) = cmx_d(n) + (dcfz_d*r(2)-dcfy_d*r(3))/cr
            cmy_d(n) = cmy_d(n) + (dcfx_d*r(3)-dcfz_d*r(1))/cr
            cmz_d(n) = cmz_d(n) + (dcfy_d*r(1)-dcfx_d*r(2))/cr
C
            cnc_d(j, n) = cnc_d(j, n) + cr*(ensy(j)*dcfy_d+ensz(j)*
     +        dcfz_d)
          ENDDO
C
C-------- design derivatives
          DO n=1,ndesign
            dcfx_g = fgam_g(1, n)/sr
            dcfy_g = fgam_g(2, n)/sr
            dcfz_g = fgam_g(3, n)/sr
C
            cfx_g(n) = cfx_g(n) + dcfx_g
            cfy_g(n) = cfy_g(n) + dcfy_g
            cfz_g(n) = cfz_g(n) + dcfz_g
            cmx_g(n) = cmx_g(n) + (dcfz_g*r(2)-dcfy_g*r(3))/cr
            cmy_g(n) = cmy_g(n) + (dcfx_g*r(3)-dcfz_g*r(1))/cr
            cmz_g(n) = cmz_g(n) + (dcfy_g*r(1)-dcfx_g*r(2))/cr
C
            cnc_g(j, n) = cnc_g(j, n) + cr*(ensy(j)*dcfy_g+ensz(j)*
     +        dcfz_g)
          ENDDO
C
C-------- hinge moments
          DO l=1,ncontrol
            rh(1) = rv(1, i) - phinge(1, j, l)
            rh(2) = rv(2, i) - phinge(2, j, l)
            rh(3) = rv(3, i) - phinge(3, j, l)
C
            dfac = dcontrol(i, l)/(sref*cref)
C
            CALL CROSS(rh, fgam, mh)
            result1 = DOT(mh, vhinge(1, j, l))
            chinge(l) = chinge(l) + result1*dfac
C
            DO n=1,numax
              CALL CROSS(rh, fgam_u(1, n), mh)
              result1 = DOT(mh, vhinge(1, j, l))
              chinge_u(l, n) = chinge_u(l, n) + result1*dfac
            ENDDO
            DO n=1,ncontrol
              CALL CROSS(rh, fgam_d(1, n), mh)
              result1 = DOT(mh, vhinge(1, j, l))
              chinge_d(l, n) = chinge_d(l, n) + result1*dfac
            ENDDO
            DO n=1,ndesign
              CALL CROSS(rh, fgam_g(1, n), mh)
              result1 = DOT(mh, vhinge(1, j, l))
              chinge_g(l, n) = chinge_g(l, n) + result1*dfac
            ENDDO
          ENDDO
        ENDDO
C
C
C
        IF (.NOT.ltrforce) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
C
C...Sum forces in the strip as generated by velocity (freestream + rotation)
C     the parts of trailing legs which lie on the surface
          DO ii=1,nvc_strp
            CALL PUSHINTEGER4(i)
            i = i1 + (ii-1)
C
            DO ileg=1,2
              IF (ileg .EQ. 1) THEN
C----------- local moment reference vector from vortex midpoint to strip c/4 pt
                CALL PUSHREAL8(r(1))
                r(1) = 0.5*(rv1(1, i)+xte1) - xr
                CALL PUSHREAL8(r(2))
                r(2) = rv1(2, i) - yr
                CALL PUSHREAL8(r(3))
                r(3) = rv1(3, i) - zr
C 
C----------- vector from rotation axes
                CALL PUSHREAL8(rrot(1))
                rrot(1) = 0.5*(rv1(1, i)+xte1) - xyzref(1)
                CALL PUSHREAL8(rrot(2))
                rrot(2) = rv1(2, i) - xyzref(2)
                CALL PUSHREAL8(rrot(3))
                rrot(3) = rv1(3, i) - xyzref(3)
C
C----------- part of trailing leg lying on surface
                CALL PUSHREAL8(g(1))
                g(1) = rv1(1, i) - xte1
                CALL PUSHREAL8(g(2))
                g(2) = 0.
                CALL PUSHREAL8(g(3))
                g(3) = 0.
C
                CALL PUSHCONTROL1B(0)
              ELSE
C----------- local moment reference vector from vortex midpoint to strip c/4 pt
                CALL PUSHREAL8(r(1))
                r(1) = 0.5*(rv2(1, i)+xte2) - xr
                CALL PUSHREAL8(r(2))
                r(2) = rv2(2, i) - yr
                CALL PUSHREAL8(r(3))
                r(3) = rv2(3, i) - zr
C
C----------- vector from rotation axes
                CALL PUSHREAL8(rrot(1))
                rrot(1) = 0.5*(rv2(1, i)+xte2) - xyzref(1)
                CALL PUSHREAL8(rrot(2))
                rrot(2) = rv2(2, i) - xyzref(2)
                CALL PUSHREAL8(rrot(3))
                rrot(3) = rv2(3, i) - xyzref(3)
C
C----------- part of trailing leg lying on surface
                CALL PUSHREAL8(g(1))
                g(1) = xte2 - rv2(1, i)
                CALL PUSHREAL8(g(2))
                g(2) = 0.
                CALL PUSHREAL8(g(3))
                g(3) = 0.
                CALL PUSHCONTROL1B(1)
              END IF
C
C---------- set total effective velocity = freestream + rotation
              CALL CROSS(rrot, wrot, vrot)
              CALL PUSHREAL8(veff(1))
              veff(1) = vinf(1) + vrot(1)
              CALL PUSHREAL8(veff(2))
              veff(2) = vinf(2) + vrot(2)
C$AD II-LOOP
              CALL PUSHREAL8(veff(3))
              veff(3) = vinf(3) + vrot(3)
C
C---------- Force coefficient on vortex segment is 2(Veff x Gamma)
              CALL PUSHREAL8ARRAY(f, 3)
              CALL CROSS(veff, g, f)
C
              CALL PUSHREAL8(fgam(1))
              fgam(1) = 2.0*gam(i)*f(1)
              CALL PUSHREAL8(fgam(2))
              fgam(2) = 2.0*gam(i)*f(2)
C$AD II-LOOP
              CALL PUSHREAL8(fgam(3))
              fgam(3) = 2.0*gam(i)*f(3)
              CALL PUSHREAL8ARRAY(fgam_d, 3*ndmax)
C$FWD-OF II-LOOP 
              DO n=1,ncontrol
                fgam_d(1, n) = 2.0*gam_d(i, n)*f(1)
                fgam_d(2, n) = 2.0*gam_d(i, n)*f(2)
                fgam_d(3, n) = 2.0*gam_d(i, n)*f(3)
              ENDDO
C
CC---------- Delta Cp (loading across lifting surface) due to vortex 
C            FNV = DOT(ENV(1,I),FGAM)
C            DCP(I) = FNV / (DXV(I)*WSTRIP(J))
CC
C            DO N = 1, NUMAX
C              FNV_U = DOT(ENV(1,I),FGAM_U(1,N))
C              DCP_U(I,N) = FNV_U / (DXV(I)*WSTRIP(J))
C            ENDDO
CC
C            DO N = 1, NCONTROL
C              FNV_D = DOT(ENV(1,I),FGAM_D(1,N)) + DOT(ENV_D(1,I,N),FGAM)
C              DCP_D(I,N) = FNV_D / (DXV(I)*WSTRIP(J))
C            ENDDO
CC
C            DO N = 1, NDESIGN
C              FNV_G = DOT(ENV(1,I),FGAM_G(1,N)) + DOT(ENV_G(1,I,N),FGAM)
C              DCP_G(I,N) = FNV_G / (DXV(I)*WSTRIP(J))
C            ENDDO
C
C
C---------- vortex contribution to strip forces
              dcfx = fgam(1)/sr
              dcfy = fgam(2)/sr
              dcfz = fgam(3)/sr
C
C---------- forces normalized by strip area
              cfx = cfx + dcfx
              cfy = cfy + dcfy
              cfz = cfz + dcfz
C
C---------- moments referred to strip c/4 pt., normalized by strip chord and area
C
C---------- accumulate strip spanloading = c*CN
C$FWD-OF II-LOOP 
C
C---------- control derivatives
              DO n=1,ncontrol
                dcfx_d = fgam_d(1, n)/sr
                dcfy_d = fgam_d(2, n)/sr
                dcfz_d = fgam_d(3, n)/sr
C  
                cfx_d(n) = cfx_d(n) + dcfx_d
                cfy_d(n) = cfy_d(n) + dcfy_d
                cfz_d(n) = cfz_d(n) + dcfz_d
                cmx_d(n) = cmx_d(n) + (dcfz_d*r(2)-dcfy_d*r(3))/cr
                cmy_d(n) = cmy_d(n) + (dcfx_d*r(3)-dcfz_d*r(1))/cr
                cmz_d(n) = cmz_d(n) + (dcfy_d*r(1)-dcfx_d*r(2))/cr
C  
                cnc_d(j, n) = cnc_d(j, n) + cr*(ensy(j)*dcfy_d+ensz(j)*
     +            dcfz_d)
              ENDDO
            ENDDO
          ENDDO
          CALL PUSHCONTROL1B(1)
        END IF
C
CC---------- hinge moments
C            DO L=1, NCONTROL
C              RH(1) = RV(1,I) - PHINGE(1,J,L)
C              RH(2) = RV(2,I) - PHINGE(2,J,L)
C              RH(3) = RV(3,I) - PHINGE(3,J,L)
CC
C              DFAC = DCONTROL(I,L) / (SREF * CREF)
CC
C              CALL CROSS(RH,FGAM,MH)
C              CHINGE(L) = CHINGE(L) + DOT(MH,VHINGE(1,J,L))*DFAC
CC
C              DO N = 1, NUMAX
C                CALL CROSS(RH,FGAM_U(1,N),MH)
C                CHINGE_U(L,N) = CHINGE_U(L,N) + DOT(MH,VHINGE(1,J,L))*DFAC
C              ENDDO
C              DO N = 1, NCONTROL
C                CALL CROSS(RH,FGAM_D(1,N),MH)
C                CHINGE_D(L,N) = CHINGE_D(L,N) + DOT(MH,VHINGE(1,J,L))*DFAC
C              ENDDO
C              DO N = 1, NDESIGN
C                CALL CROSS(RH,FGAM_G(1,N),MH)
C                CHINGE_G(L,N) = CHINGE_G(L,N) + DOT(MH,VHINGE(1,J,L))*DFAC
C              ENDDO
C            ENDDO
C
C
C
C*******************************************************************
C--- Drag terms due to viscous effects
C    Drag forces are assumed to be characterized by velocity at the c/4 
C    point and are assumed to act thru the same point. CD is defined by 
C    user-specified CD(CL) polar.  Drag comes from function lookup on 
C    section polar drag using local lift coefficient.  
C
C
        IF (lvisc .AND. lviscstrp(j)) THEN
C--- local moment reference vector from ref point to c/4 point
C         R(1) = XR - XR
C         R(2) = YR - YR
C         R(3) = ZR - ZR
C--- Get rotational velocity at strip 1/4 chord reference point 
          CALL PUSHREAL8(rrot(1))
          rrot(1) = xr - xyzref(1)
          CALL PUSHREAL8(rrot(2))
          rrot(2) = yr - xyzref(2)
          CALL PUSHREAL8(rrot(3))
          rrot(3) = zr - xyzref(3)
C--- Onset velocity at strip c/4 = freestream + rotation
          CALL CROSS(rrot, wrot, vrot)
          CALL PUSHREAL8(veff(1))
          veff(1) = vinf(1) + vrot(1)
          CALL PUSHREAL8(veff(2))
          veff(2) = vinf(2) + vrot(2)
          CALL PUSHREAL8(veff(3))
          veff(3) = vinf(3) + vrot(3)
          veffmag = SQRT(veff(1)**2 + veff(2)**2 + veff(3)**2)
C
C--- Generate CD from stored function using strip CL as parameter
          clv = ulift(1)*cfx + ulift(2)*cfy + ulift(3)*cfz
C
          DO n=1,ncontrol
            clv_d(n) = ensy(j)*cfy_d(n) + ensz(j)*(cfz_d(n)*cosa-cfx_d(n
     +        )*sina)
          ENDDO
C
          CALL CDCL(j, clv, cdv, cdv_clv)
C
C--- Strip viscous force contribution (per unit strip area)
          dcvfx = veff(1)*veffmag*cdv
          dcvfy = veff(2)*veffmag*cdv
          dcvfz = veff(3)*veffmag*cdv
C
C--- Add viscous terms to strip forces and moments
          CALL PUSHREAL8(cfx)
          cfx = cfx + dcvfx
          CALL PUSHREAL8(cfy)
          cfy = cfy + dcvfy
          CALL PUSHREAL8(cfz)
          cfz = cfz + dcvfz
C--- Viscous forces acting at c/4 have no effect on moments at c/4 pt.
C         CMX = CMX + (DCVFZ*R(2) - DCVFY*R(3))/CR
C         CMY = CMY + (DCVFX*R(3) - DCVFZ*R(1))/CR
C         CMZ = CMZ + (DCVFY*R(1) - DCVFX*R(2))/CR
C
C$AD II-LOOP
C
          DO n=1,ncontrol
            dcvfx_d = veff(1)*veffmag*cdv_clv*clv_d(n)
            dcvfy_d = veff(2)*veffmag*cdv_clv*clv_d(n)
            dcvfz_d = veff(3)*veffmag*cdv_clv*clv_d(n)
C
            CALL PUSHREAL8(cfx_d(n))
            cfx_d(n) = cfx_d(n) + dcvfx_d
            CALL PUSHREAL8(cfy_d(n))
            cfy_d(n) = cfy_d(n) + dcvfy_d
            CALL PUSHREAL8(cfz_d(n))
            cfz_d(n) = cfz_d(n) + dcvfz_d
C--- Viscous forces acting at c/4 have no effect on moments at c/4 pt.
C           CMX_D(N) = CMX_D(N) + (DCVFZ_D*R(2) - DCVFY_D*R(3))/CR
C           CMY_D(N) = CMY_D(N) + (DCVFX_D*R(3) - DCVFZ_D*R(1))/CR
C           CMZ_D(N) = CMZ_D(N) + (DCVFY_D*R(1) - DCVFX_D*R(2))/CR
C
          ENDDO
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
C
C------ vector from chord c/4 reference point to case reference point XYZREF 
        CALL PUSHREAL8(r(1))
        r(1) = xr - xyzref(1)
        CALL PUSHREAL8(r(2))
        r(2) = yr - xyzref(2)
        CALL PUSHREAL8(r(3))
        r(3) = zr - xyzref(3)
C... Strip moments in body axes about the case moment reference point XYZREF 
C    normalized by strip area and chord
C
C...Components of X,Y,Z forces in local strip axes 
C   axial/normal forces and lift/drag in plane normal to dihedral of strip
C
C------ vector at chord reference point from rotation axes
        CALL PUSHREAL8(rrot(1))
        rrot(1) = xsref(j) - xyzref(1)
        CALL PUSHREAL8(rrot(2))
        rrot(2) = ysref(j) - xyzref(2)
        CALL PUSHREAL8(rrot(3))
        rrot(3) = zsref(j) - xyzref(3)
C        print *,"WROT ",WROT
C
C------ set total effective velocity = freestream + rotation
C
        zr_diff = r_diff(3)
        rle_diff(3, j) = rle_diff(3, j) - r_diff(3)
        r_diff(3) = 0.D0
        yr_diff = r_diff(2)
        rle_diff(2, j) = rle_diff(2, j) - r_diff(2)
        r_diff(2) = 0.D0
        xr_diff = r_diff(1)
        rle_diff(1, j) = rle_diff(1, j) - r_diff(1)
        r_diff(1) = 0.D0
        vinf_diff(3) = vinf_diff(3) + veff_diff(3)
        vrot_diff(3) = vrot_diff(3) + veff_diff(3)
        veff_diff(3) = 0.D0
        vinf_diff(2) = vinf_diff(2) + veff_diff(2)
        vrot_diff(2) = vrot_diff(2) + veff_diff(2)
        veff_diff(2) = 0.D0
        vinf_diff(1) = vinf_diff(1) + veff_diff(1)
        vrot_diff(1) = vrot_diff(1) + veff_diff(1)
        veff_diff(1) = 0.D0
        DO ii1=1,3
          wrot_diff(ii1) = 0.D0
        ENDDO
        CALL CROSS_B(rrot, rrot_diff, wrot, wrot_diff, vrot, vrot_diff)
        CALL POPREAL8(rrot(3))
        zsref_diff(j) = zsref_diff(j) + rrot_diff(3)
        xyzref_diff(3) = xyzref_diff(3) - rrot_diff(3)
        rrot_diff(3) = 0.D0
        CALL POPREAL8(rrot(2))
        ysref_diff(j) = ysref_diff(j) + rrot_diff(2)
        xyzref_diff(2) = xyzref_diff(2) - rrot_diff(2)
        rrot_diff(2) = 0.D0
        CALL POPREAL8(rrot(1))
        xsref_diff(j) = xsref_diff(j) + rrot_diff(1)
        xyzref_diff(1) = xyzref_diff(1) - rrot_diff(1)
        rrot_diff(1) = 0.D0
        cr_diff = 0.D0
        DO n=ncontrol,1,-1
          cmz_d_diff(n) = cmz_d_diff(n) + cnst_d_diff(j, n)
          temp_diff2 = cnst_d_diff(j, n)/cr
          cnst_d_diff(j, n) = 0.D0
          cfy_d_diff(n) = cfy_d_diff(n) + r(1)*temp_diff2
          r_diff(1) = r_diff(1) + cfy_d(n)*temp_diff2
          cfx_d_diff(n) = cfx_d_diff(n) - r(2)*temp_diff2
          r_diff(2) = r_diff(2) - cfx_d(n)*temp_diff2
          cr_diff = cr_diff - (cfy_d(n)*r(1)-cfx_d(n)*r(2))*temp_diff2/
     +      cr
          cmy_d_diff(n) = cmy_d_diff(n) + cmst_d_diff(j, n)
          temp_diff2 = cmst_d_diff(j, n)/cr
          cmst_d_diff(j, n) = 0.D0
          cfx_d_diff(n) = cfx_d_diff(n) + r(3)*temp_diff2
          r_diff(3) = r_diff(3) + cfx_d(n)*temp_diff2
          cfz_d_diff(n) = cfz_d_diff(n) - r(1)*temp_diff2
          r_diff(1) = r_diff(1) - cfz_d(n)*temp_diff2
          cr_diff = cr_diff - (cfx_d(n)*r(3)-cfz_d(n)*r(1))*temp_diff2/
     +      cr
          cmx_d_diff(n) = cmx_d_diff(n) + crst_d_diff(j, n)
          temp_diff2 = crst_d_diff(j, n)/cr
          crst_d_diff(j, n) = 0.D0
          cfz_d_diff(n) = cfz_d_diff(n) + r(2)*temp_diff2
          r_diff(2) = r_diff(2) + cfz_d(n)*temp_diff2
          cfy_d_diff(n) = cfy_d_diff(n) - r(3)*temp_diff2
          r_diff(3) = r_diff(3) - cfy_d(n)*temp_diff2
          cr_diff = cr_diff - (cfz_d(n)*r(2)-cfy_d(n)*r(3))*temp_diff2/
     +      cr
        ENDDO
        cmz_diff = cnstrp_diff(j)
        temp_diff2 = cnstrp_diff(j)/cr
        cnstrp_diff(j) = 0.D0
        cfy_diff = r(1)*temp_diff2
        r_diff(1) = r_diff(1) + cfy*temp_diff2
        cfx_diff = -(r(2)*temp_diff2)
        r_diff(2) = r_diff(2) - cfx*temp_diff2
        cr_diff = cr_diff - (cfy*r(1)-cfx*r(2))*temp_diff2/cr
        cmy_diff = cmstrp_diff(j)
        temp_diff2 = cmstrp_diff(j)/cr
        cmstrp_diff(j) = 0.D0
        cfx_diff = cfx_diff + r(3)*temp_diff2
        r_diff(3) = r_diff(3) + cfx*temp_diff2
        cfz_diff = -(r(1)*temp_diff2)
        r_diff(1) = r_diff(1) - cfz*temp_diff2
        cr_diff = cr_diff - (cfx*r(3)-cfz*r(1))*temp_diff2/cr
        cmx_diff = crstrp_diff(j)
        temp_diff2 = crstrp_diff(j)/cr
        crstrp_diff(j) = 0.D0
        cfz_diff = cfz_diff + r(2)*temp_diff2
        r_diff(2) = r_diff(2) + cfz*temp_diff2
        cfy_diff = cfy_diff - r(3)*temp_diff2
        r_diff(3) = r_diff(3) - cfy*temp_diff2
        cr_diff = cr_diff - (cfz*r(2)-cfy*r(3))*temp_diff2/cr
        CALL POPREAL8(r(3))
        zr_diff = zr_diff + r_diff(3)
        xyzref_diff(3) = xyzref_diff(3) - r_diff(3)
        r_diff(3) = 0.D0
        CALL POPREAL8(r(2))
        yr_diff = yr_diff + r_diff(2)
        xyzref_diff(2) = xyzref_diff(2) - r_diff(2)
        r_diff(2) = 0.D0
        CALL POPREAL8(r(1))
        xr_diff = xr_diff + r_diff(1)
        xyzref_diff(1) = xyzref_diff(1) - r_diff(1)
        r_diff(1) = 0.D0
        DO n=ncontrol,1,-1
          cfz_d_diff(n) = cfz_d_diff(n) + czst_d_diff(j, n) + cosa*
     +      clst_d_diff(j, n) + sina*cdst_d_diff(j, n)
          czst_d_diff(j, n) = 0.D0
          cfy_d_diff(n) = cfy_d_diff(n) + cyst_d_diff(j, n)
          cyst_d_diff(j, n) = 0.D0
          cfx_d_diff(n) = cfx_d_diff(n) + cxst_d_diff(j, n) + cosa*
     +      cdst_d_diff(j, n) - sina*clst_d_diff(j, n)
          cxst_d_diff(j, n) = 0.D0
          cosa_diff = cosa_diff + cfz_d(n)*clst_d_diff(j, n) + cfx_d(n)*
     +      cdst_d_diff(j, n)
          sina_diff = sina_diff + cfz_d(n)*cdst_d_diff(j, n) - cfx_d(n)*
     +      clst_d_diff(j, n)
          clst_d_diff(j, n) = 0.D0
          cdst_d_diff(j, n) = 0.D0
        ENDDO
        cfz_diff = cfz_diff + cosa*clstrp_diff(j) + sina*cdstrp_diff(j) 
     +    + czstrp_diff(j)
        cosa_diff = cosa_diff + cfz*clstrp_diff(j) + cfx*cdstrp_diff(j)
        cfx_diff = cfx_diff + cosa*cdstrp_diff(j) - sina*clstrp_diff(j) 
     +    + cxstrp_diff(j)
        sina_diff = sina_diff + cfz*cdstrp_diff(j) - cfx*clstrp_diff(j)
        clstrp_diff(j) = 0.D0
        cdstrp_diff(j) = 0.D0
        czstrp_diff(j) = 0.D0
        cfy_diff = cfy_diff + cystrp_diff(j)
        cystrp_diff(j) = 0.D0
        cxstrp_diff(j) = 0.D0
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          cdv_clv_diff = 0.D0
          veffmag_diff = 0.D0
          DO n=ncontrol,1,-1
            CALL POPREAL8(cfz_d(n))
            dcvfz_d_diff = cfz_d_diff(n)
            CALL POPREAL8(cfy_d(n))
            dcvfy_d_diff = cfy_d_diff(n)
            CALL POPREAL8(cfx_d(n))
            dcvfx_d_diff = cfx_d_diff(n)
            temp_diff2 = veff(3)*clv_d(n)*dcvfz_d_diff
            temp_diff1 = veffmag*cdv_clv*dcvfz_d_diff
            veff_diff(3) = veff_diff(3) + clv_d(n)*temp_diff1
            clv_d_diff(n) = clv_d_diff(n) + veff(3)*temp_diff1
            veffmag_diff = veffmag_diff + cdv_clv*temp_diff2
            cdv_clv_diff = cdv_clv_diff + veffmag*temp_diff2
            temp_diff2 = veff(2)*clv_d(n)*dcvfy_d_diff
            temp_diff1 = veffmag*cdv_clv*dcvfy_d_diff
            veff_diff(2) = veff_diff(2) + clv_d(n)*temp_diff1
            clv_d_diff(n) = clv_d_diff(n) + veff(2)*temp_diff1
            temp_diff1 = veff(1)*clv_d(n)*dcvfx_d_diff
            veffmag_diff = veffmag_diff + cdv_clv*temp_diff2 + cdv_clv*
     +        temp_diff1
            cdv_clv_diff = cdv_clv_diff + veffmag*temp_diff2 + veffmag*
     +        temp_diff1
            temp_diff2 = veffmag*cdv_clv*dcvfx_d_diff
            veff_diff(1) = veff_diff(1) + clv_d(n)*temp_diff2
            clv_d_diff(n) = clv_d_diff(n) + veff(1)*temp_diff2
          ENDDO
          udrag_diff(1) = udrag_diff(1) + dcvfx*cdv_lstrp_diff(j)
          dcvfx_diff = udrag(1)*cdv_lstrp_diff(j) + cfx_diff
          udrag_diff(2) = udrag_diff(2) + dcvfy*cdv_lstrp_diff(j)
          dcvfy_diff = udrag(2)*cdv_lstrp_diff(j) + cfy_diff
          udrag_diff(3) = udrag_diff(3) + dcvfz*cdv_lstrp_diff(j)
          dcvfz_diff = udrag(3)*cdv_lstrp_diff(j) + cfz_diff
          cdv_lstrp_diff(j) = 0.D0
          CALL POPREAL8(cfz)
          CALL POPREAL8(cfy)
          CALL POPREAL8(cfx)
          veff_diff(3) = veff_diff(3) + veffmag*cdv*dcvfz_diff
          veffmag_diff = veffmag_diff + cdv*veff(3)*dcvfz_diff + cdv*
     +      veff(2)*dcvfy_diff + cdv*veff(1)*dcvfx_diff
          cdv_diff = veffmag*veff(3)*dcvfz_diff + veffmag*veff(2)*
     +      dcvfy_diff + veffmag*veff(1)*dcvfx_diff
          veff_diff(2) = veff_diff(2) + veffmag*cdv*dcvfy_diff
          veff_diff(1) = veff_diff(1) + veffmag*cdv*dcvfx_diff
          CALL CDCL_B(j, clv, clv_diff, cdv, cdv_diff, cdv_clv, 
     +                cdv_clv_diff)
          DO n=ncontrol,1,-1
            ensy_diff(j) = ensy_diff(j) + cfy_d(n)*clv_d_diff(n)
            cfy_d_diff(n) = cfy_d_diff(n) + ensy(j)*clv_d_diff(n)
            ensz_diff(j) = ensz_diff(j) + (cfz_d(n)*cosa-cfx_d(n)*sina)*
     +        clv_d_diff(n)
            temp_diff1 = ensz(j)*clv_d_diff(n)
            clv_d_diff(n) = 0.D0
            cfz_d_diff(n) = cfz_d_diff(n) + cosa*temp_diff1
            cosa_diff = cosa_diff + cfz_d(n)*temp_diff1
            cfx_d_diff(n) = cfx_d_diff(n) - sina*temp_diff1
            sina_diff = sina_diff - cfx_d(n)*temp_diff1
          ENDDO
          ulift_diff(1) = ulift_diff(1) + cfx*clv_diff
          cfx_diff = cfx_diff + ulift(1)*clv_diff
          ulift_diff(2) = ulift_diff(2) + cfy*clv_diff
          cfy_diff = cfy_diff + ulift(2)*clv_diff
          ulift_diff(3) = ulift_diff(3) + cfz*clv_diff
          cfz_diff = cfz_diff + ulift(3)*clv_diff
          IF (veff(1)**2 + veff(2)**2 + veff(3)**2 .EQ. 0.D0) THEN
            temp_diff1 = 0.D0
          ELSE
            temp_diff1 = veffmag_diff/(2.0*SQRT(veff(1)**2+veff(2)**2+
     +        veff(3)**2))
          END IF
          veff_diff(1) = veff_diff(1) + 2*veff(1)*temp_diff1
          veff_diff(2) = veff_diff(2) + 2*veff(2)*temp_diff1
          veff_diff(3) = veff_diff(3) + 2*veff(3)*temp_diff1
          CALL POPREAL8(veff(3))
          vinf_diff(3) = vinf_diff(3) + veff_diff(3)
          vrot_diff(3) = vrot_diff(3) + veff_diff(3)
          veff_diff(3) = 0.D0
          CALL POPREAL8(veff(2))
          vinf_diff(2) = vinf_diff(2) + veff_diff(2)
          vrot_diff(2) = vrot_diff(2) + veff_diff(2)
          veff_diff(2) = 0.D0
          CALL POPREAL8(veff(1))
          vinf_diff(1) = vinf_diff(1) + veff_diff(1)
          vrot_diff(1) = vrot_diff(1) + veff_diff(1)
          veff_diff(1) = 0.D0
          DO ii1=1,3
            wrot_diff(ii1) = 0.D0
          ENDDO
          CALL CROSS_B(rrot, rrot_diff, wrot, wrot_diff, vrot, vrot_diff
     +                )
          CALL POPREAL8(rrot(3))
          zr_diff = zr_diff + rrot_diff(3)
          xyzref_diff(3) = xyzref_diff(3) - rrot_diff(3)
          rrot_diff(3) = 0.D0
          CALL POPREAL8(rrot(2))
          yr_diff = yr_diff + rrot_diff(2)
          xyzref_diff(2) = xyzref_diff(2) - rrot_diff(2)
          rrot_diff(2) = 0.D0
          CALL POPREAL8(rrot(1))
          xr_diff = xr_diff + rrot_diff(1)
          xyzref_diff(1) = xyzref_diff(1) - rrot_diff(1)
          rrot_diff(1) = 0.D0
        END IF
        cdv_lstrp_diff(j) = 0.D0
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          xte1_diff = 0.D0
          xte2_diff = 0.D0
          sr_diff = 0.D0
        ELSE
          xte1_diff = 0.D0
          xte2_diff = 0.D0
          sr_diff = 0.D0
          DO ii=nvc_strp,1,-1
            i = i1 + (ii-1)
            DO ileg=2,1,-1
C$BWD-OF II-LOOP 
              DO n=1,ncontrol
                dcfx_d = fgam_d(1, n)/sr
                dcfy_d = fgam_d(2, n)/sr
                dcfz_d = fgam_d(3, n)/sr
C  
C  
                temp_diff2 = cmz_d_diff(n)/cr
                dcfy_d_diff = r(1)*temp_diff2
                r_diff(1) = r_diff(1) + dcfy_d*temp_diff2
                dcfx_d_diff = -(r(2)*temp_diff2)
                r_diff(2) = r_diff(2) - dcfx_d*temp_diff2
                cr_diff = cr_diff - (dcfy_d*r(1)-dcfx_d*r(2))*temp_diff2
     +            /cr
                temp_diff2 = cmy_d_diff(n)/cr
                dcfx_d_diff = dcfx_d_diff + r(3)*temp_diff2 + cfx_d_diff
     +            (n)
                r_diff(3) = r_diff(3) + dcfx_d*temp_diff2
                dcfz_d_diff = -(r(1)*temp_diff2)
                r_diff(1) = r_diff(1) - dcfz_d*temp_diff2
                cr_diff = cr_diff - (dcfx_d*r(3)-dcfz_d*r(1))*temp_diff2
     +            /cr
                temp_diff2 = cmx_d_diff(n)/cr
                dcfz_d_diff = dcfz_d_diff + r(2)*temp_diff2 + cfz_d_diff
     +            (n)
                r_diff(2) = r_diff(2) + dcfz_d*temp_diff2
                dcfy_d_diff = dcfy_d_diff + cfy_d_diff(n) - r(3)*
     +            temp_diff2
                r_diff(3) = r_diff(3) - dcfy_d*temp_diff2
                cr_diff = cr_diff - (dcfz_d*r(2)-dcfy_d*r(3))*temp_diff2
     +            /cr
                fgam_d_diff(3, n) = fgam_d_diff(3, n) + dcfz_d_diff/sr
                sr_diff = sr_diff - fgam_d(3, n)*dcfz_d_diff/sr**2 - 
     +            fgam_d(2, n)*dcfy_d_diff/sr**2 - fgam_d(1, n)*
     +            dcfx_d_diff/sr**2
                fgam_d_diff(2, n) = fgam_d_diff(2, n) + dcfy_d_diff/sr
                fgam_d_diff(1, n) = fgam_d_diff(1, n) + dcfx_d_diff/sr
              ENDDO
              dcfx = fgam(1)/sr
              dcfy = fgam(2)/sr
              temp_diff1 = cmz_diff/cr
              dcfy_diff = r(1)*temp_diff1
              r_diff(1) = r_diff(1) + dcfy*temp_diff1
              dcfx_diff = -(r(2)*temp_diff1)
              r_diff(2) = r_diff(2) - dcfx*temp_diff1
              cr_diff = cr_diff - (dcfy*r(1)-dcfx*r(2))*temp_diff1/cr
              dcfz = fgam(3)/sr
              temp_diff1 = cmy_diff/cr
              dcfx_diff = dcfx_diff + r(3)*temp_diff1 + cfx_diff
              r_diff(3) = r_diff(3) + dcfx*temp_diff1
              dcfz_diff = -(r(1)*temp_diff1)
              r_diff(1) = r_diff(1) - dcfz*temp_diff1
              cr_diff = cr_diff - (dcfx*r(3)-dcfz*r(1))*temp_diff1/cr
              temp_diff1 = cmx_diff/cr
              dcfz_diff = dcfz_diff + r(2)*temp_diff1 + cfz_diff
              r_diff(2) = r_diff(2) + dcfz*temp_diff1
              dcfy_diff = dcfy_diff + cfy_diff - r(3)*temp_diff1
              r_diff(3) = r_diff(3) - dcfy*temp_diff1
              cr_diff = cr_diff - (dcfz*r(2)-dcfy*r(3))*temp_diff1/cr
              fgam_diff(3) = fgam_diff(3) + dcfz_diff/sr
              sr_diff = sr_diff - fgam(3)*dcfz_diff/sr**2 - fgam(2)*
     +          dcfy_diff/sr**2 - fgam(1)*dcfx_diff/sr**2
              fgam_diff(2) = fgam_diff(2) + dcfy_diff/sr
              fgam_diff(1) = fgam_diff(1) + dcfx_diff/sr
              CALL POPREAL8ARRAY(fgam_d, 3*ndmax)
C$BWD-OF II-LOOP 
              DO n=1,ncontrol
                gam_d_diff(i, n) = gam_d_diff(i, n) + f(3)*2.0*
     +            fgam_d_diff(3, n) + f(2)*2.0*fgam_d_diff(2, n) + f(1)*
     +            2.0*fgam_d_diff(1, n)
                f_diff(3) = f_diff(3) + gam_d(i, n)*2.0*fgam_d_diff(3, n
     +            )
                fgam_d_diff(3, n) = 0.D0
                f_diff(2) = f_diff(2) + gam_d(i, n)*2.0*fgam_d_diff(2, n
     +            )
                fgam_d_diff(2, n) = 0.D0
                f_diff(1) = f_diff(1) + gam_d(i, n)*2.0*fgam_d_diff(1, n
     +            )
                fgam_d_diff(1, n) = 0.D0
              ENDDO
              CALL POPREAL8(fgam(3))
              gam_diff(i) = gam_diff(i) + f(3)*2.0*fgam_diff(3) + f(2)*
     +          2.0*fgam_diff(2) + f(1)*2.0*fgam_diff(1)
              f_diff(3) = f_diff(3) + gam(i)*2.0*fgam_diff(3)
              fgam_diff(3) = 0.D0
              CALL POPREAL8(fgam(2))
              f_diff(2) = f_diff(2) + gam(i)*2.0*fgam_diff(2)
              fgam_diff(2) = 0.D0
              CALL POPREAL8(fgam(1))
              f_diff(1) = f_diff(1) + gam(i)*2.0*fgam_diff(1)
              fgam_diff(1) = 0.D0
              CALL POPREAL8ARRAY(f, 3)
              CALL CROSS_B(veff, veff_diff, g, g_diff, f, f_diff)
              CALL POPREAL8(veff(3))
              vinf_diff(3) = vinf_diff(3) + veff_diff(3)
              vrot_diff(3) = vrot_diff(3) + veff_diff(3)
              veff_diff(3) = 0.D0
              CALL POPREAL8(veff(2))
              vinf_diff(2) = vinf_diff(2) + veff_diff(2)
              vrot_diff(2) = vrot_diff(2) + veff_diff(2)
              veff_diff(2) = 0.D0
              CALL POPREAL8(veff(1))
              vinf_diff(1) = vinf_diff(1) + veff_diff(1)
              vrot_diff(1) = vrot_diff(1) + veff_diff(1)
              veff_diff(1) = 0.D0
              DO ii1=1,3
                wrot_diff(ii1) = 0.D0
              ENDDO
              CALL CROSS_B(rrot, rrot_diff, wrot, wrot_diff, vrot, 
     +                     vrot_diff)
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                CALL POPREAL8(g(3))
                g_diff(3) = 0.D0
                CALL POPREAL8(g(2))
                g_diff(2) = 0.D0
                CALL POPREAL8(g(1))
                rv1_diff(1, i) = rv1_diff(1, i) + g_diff(1) + 0.5*
     +            rrot_diff(1) + 0.5*r_diff(1)
                xte1_diff = xte1_diff + 0.5*rrot_diff(1) - g_diff(1) + 
     +            0.5*r_diff(1)
                g_diff(1) = 0.D0
                CALL POPREAL8(rrot(3))
                rv1_diff(3, i) = rv1_diff(3, i) + rrot_diff(3) + r_diff(
     +            3)
                xyzref_diff(3) = xyzref_diff(3) - rrot_diff(3)
                rrot_diff(3) = 0.D0
                CALL POPREAL8(rrot(2))
                rv1_diff(2, i) = rv1_diff(2, i) + rrot_diff(2) + r_diff(
     +            2)
                xyzref_diff(2) = xyzref_diff(2) - rrot_diff(2)
                rrot_diff(2) = 0.D0
                CALL POPREAL8(rrot(1))
                xyzref_diff(1) = xyzref_diff(1) - rrot_diff(1)
                rrot_diff(1) = 0.D0
                CALL POPREAL8(r(3))
                zr_diff = zr_diff - r_diff(3)
                r_diff(3) = 0.D0
                CALL POPREAL8(r(2))
                yr_diff = yr_diff - r_diff(2)
                r_diff(2) = 0.D0
                CALL POPREAL8(r(1))
                xr_diff = xr_diff - r_diff(1)
                r_diff(1) = 0.D0
              ELSE
                CALL POPREAL8(g(3))
                g_diff(3) = 0.D0
                CALL POPREAL8(g(2))
                g_diff(2) = 0.D0
                CALL POPREAL8(g(1))
                xte2_diff = xte2_diff + g_diff(1) + 0.5*rrot_diff(1) + 
     +            0.5*r_diff(1)
                rv2_diff(1, i) = rv2_diff(1, i) + 0.5*rrot_diff(1) - 
     +            g_diff(1) + 0.5*r_diff(1)
                g_diff(1) = 0.D0
                CALL POPREAL8(rrot(3))
                rv2_diff(3, i) = rv2_diff(3, i) + rrot_diff(3) + r_diff(
     +            3)
                xyzref_diff(3) = xyzref_diff(3) - rrot_diff(3)
                rrot_diff(3) = 0.D0
                CALL POPREAL8(rrot(2))
                rv2_diff(2, i) = rv2_diff(2, i) + rrot_diff(2) + r_diff(
     +            2)
                xyzref_diff(2) = xyzref_diff(2) - rrot_diff(2)
                rrot_diff(2) = 0.D0
                CALL POPREAL8(rrot(1))
                xyzref_diff(1) = xyzref_diff(1) - rrot_diff(1)
                rrot_diff(1) = 0.D0
                CALL POPREAL8(r(3))
                zr_diff = zr_diff - r_diff(3)
                r_diff(3) = 0.D0
                CALL POPREAL8(r(2))
                yr_diff = yr_diff - r_diff(2)
                r_diff(2) = 0.D0
                CALL POPREAL8(r(1))
                xr_diff = xr_diff - r_diff(1)
                r_diff(1) = 0.D0
              END IF
            ENDDO
            CALL POPINTEGER4(i)
          ENDDO
        END IF
        CALL POPREAL8ARRAY(fgam_d, 3*ndmax)
        CALL POPREAL8ARRAY(rrot, 3)
        CALL POPREAL8ARRAY(fgam, 3)
        CALL POPREAL8(result1)
        CALL POPREAL8ARRAY(veff, 3)
        CALL POPREAL8ARRAY(vrot, 3)
        CALL POPREAL8ARRAY(r, 3)
        CALL POPREAL8ARRAY(g, 3)
        CALL POPREAL8ARRAY(f, 3)
C$BWD-OF II-LOOP 
        DO ii=1,nvc_strp
          i = i1 + (ii-1)
C
C------- local moment reference vector from vortex midpoint to strip c/4 pt.
C          R(1) = 0.5*(RV1(1,I) + RV2(1,I)) - XR
C          R(2) = 0.5*(RV1(2,I) + RV2(2,I)) - YR
C          R(3) = 0.5*(RV1(3,I) + RV2(3,I)) - ZR
          r(1) = rv(1, i) - xr
          r(2) = rv(2, i) - yr
          r(3) = rv(3, i) - zr
C
C------- vector from rotation axes
C          RROT(1) = 0.5*(RV1(1,I) + RV2(1,I)) - XYZREF(1)
C          RROT(2) = 0.5*(RV1(2,I) + RV2(2,I)) - XYZREF(2)
C          RROT(3) = 0.5*(RV1(3,I) + RV2(3,I)) - XYZREF(3)
          rrot(1) = rv(1, i) - xyzref(1)
          rrot(2) = rv(2, i) - xyzref(2)
          rrot(3) = rv(3, i) - xyzref(3)
C
C-------- set total effective velocity = freestream + rotation + induced
          CALL CROSS(rrot, wrot, vrot)
          veff(1) = vinf(1) + vrot(1) + wv(1, i)
          veff(2) = vinf(2) + vrot(2) + wv(2, i)
C$AD II-LOOP
          veff(3) = vinf(3) + vrot(3) + wv(3, i)
C
C-------- Force coefficient on vortex segment is 2(Veff x Gamma)
          g(1) = rv2(1, i) - rv1(1, i)
          g(2) = rv2(2, i) - rv1(2, i)
          g(3) = rv2(3, i) - rv1(3, i)
          CALL CROSS(veff, g, f)
C
          fgam(1) = 2.0*gam(i)*f(1)
          fgam(2) = 2.0*gam(i)*f(2)
C$AD II-LOOP
          fgam(3) = 2.0*gam(i)*f(3)
C$FWD-OF II-LOOP 
          DO n=1,ncontrol
            fgam_d(1, n) = 2.0*gam_d(i, n)*f(1)
            fgam_d(2, n) = 2.0*gam_d(i, n)*f(2)
            fgam_d(3, n) = 2.0*gam_d(i, n)*f(3)
          ENDDO
          CALL PUSHINTEGER4(n)
C
C-------- vortex contribution to strip forces
          dcfx = fgam(1)/sr
          dcfy = fgam(2)/sr
          dcfz = fgam(3)/sr
C
C-------- forces normalized by strip area
C
C-------- moments referred to strip c/4 pt., normalized by strip chord and area
C
C-------- accumulate strip spanloading = c*CN
C$AD II-LOOP
          CALL PUSHINTEGER4(n)
          CALL PUSHINTEGER4(l)
          CALL POPINTEGER4(l)
C$BWD-OF II-LOOP 
          DO n=1,ncontrol
            dcfx_d = fgam_d(1, n)/sr
            dcfy_d = fgam_d(2, n)/sr
            dcfz_d = fgam_d(3, n)/sr
C
C
            temp_diff2 = cmz_d_diff(n)/cr
            dcfy_d_diff = r(1)*temp_diff2
            r_diff(1) = r_diff(1) + dcfy_d*temp_diff2
            dcfx_d_diff = -(r(2)*temp_diff2)
            r_diff(2) = r_diff(2) - dcfx_d*temp_diff2
            cr_diff = cr_diff - (dcfy_d*r(1)-dcfx_d*r(2))*temp_diff2/cr
            temp_diff2 = cmy_d_diff(n)/cr
            dcfx_d_diff = dcfx_d_diff + r(3)*temp_diff2 + cfx_d_diff(n)
            r_diff(3) = r_diff(3) + dcfx_d*temp_diff2
            dcfz_d_diff = -(r(1)*temp_diff2)
            r_diff(1) = r_diff(1) - dcfz_d*temp_diff2
            cr_diff = cr_diff - (dcfx_d*r(3)-dcfz_d*r(1))*temp_diff2/cr
            temp_diff2 = cmx_d_diff(n)/cr
            dcfz_d_diff = dcfz_d_diff + r(2)*temp_diff2 + cfz_d_diff(n)
            r_diff(2) = r_diff(2) + dcfz_d*temp_diff2
            dcfy_d_diff = dcfy_d_diff + cfy_d_diff(n) - r(3)*temp_diff2
            r_diff(3) = r_diff(3) - dcfy_d*temp_diff2
            cr_diff = cr_diff - (dcfz_d*r(2)-dcfy_d*r(3))*temp_diff2/cr
            fgam_d_diff(3, n) = fgam_d_diff(3, n) + dcfz_d_diff/sr
            sr_diff = sr_diff - fgam_d(3, n)*dcfz_d_diff/sr**2 - fgam_d(
     +        2, n)*dcfy_d_diff/sr**2 - fgam_d(1, n)*dcfx_d_diff/sr**2
            fgam_d_diff(2, n) = fgam_d_diff(2, n) + dcfy_d_diff/sr
            fgam_d_diff(1, n) = fgam_d_diff(1, n) + dcfx_d_diff/sr
          ENDDO
          CALL POPINTEGER4(n)
          temp_diff2 = cmz_diff/cr
          dcfy_diff = r(1)*temp_diff2
          r_diff(1) = r_diff(1) + dcfy*temp_diff2
          dcfx_diff = -(r(2)*temp_diff2)
          r_diff(2) = r_diff(2) - dcfx*temp_diff2
          cr_diff = cr_diff - (dcfy*r(1)-dcfx*r(2))*temp_diff2/cr
          temp_diff2 = cmy_diff/cr
          dcfx_diff = dcfx_diff + r(3)*temp_diff2 + cfx_diff
          r_diff(3) = r_diff(3) + dcfx*temp_diff2
          dcfz_diff = -(r(1)*temp_diff2)
          r_diff(1) = r_diff(1) - dcfz*temp_diff2
          cr_diff = cr_diff - (dcfx*r(3)-dcfz*r(1))*temp_diff2/cr
          temp_diff2 = cmx_diff/cr
          dcfz_diff = dcfz_diff + r(2)*temp_diff2 + cfz_diff
          r_diff(2) = r_diff(2) + dcfz*temp_diff2
          dcfy_diff = dcfy_diff + cfy_diff - r(3)*temp_diff2
          r_diff(3) = r_diff(3) - dcfy*temp_diff2
          cr_diff = cr_diff - (dcfz*r(2)-dcfy*r(3))*temp_diff2/cr
          fgam_diff(3) = fgam_diff(3) + dcfz_diff/sr
          sr_diff = sr_diff - fgam(3)*dcfz_diff/sr**2 - fgam(2)*
     +      dcfy_diff/sr**2 - fgam(1)*dcfx_diff/sr**2
          fgam_diff(2) = fgam_diff(2) + dcfy_diff/sr
          fgam_diff(1) = fgam_diff(1) + dcfx_diff/sr
          CALL POPINTEGER4(n)
C$BWD-OF II-LOOP 
          DO n=1,ncontrol
            gam_d_diff(i, n) = gam_d_diff(i, n) + f(3)*2.0*fgam_d_diff(3
     +        , n) + f(2)*2.0*fgam_d_diff(2, n) + f(1)*2.0*fgam_d_diff(1
     +        , n)
            f_diff(3) = f_diff(3) + gam_d(i, n)*2.0*fgam_d_diff(3, n)
            fgam_d_diff(3, n) = 0.D0
            f_diff(2) = f_diff(2) + gam_d(i, n)*2.0*fgam_d_diff(2, n)
            fgam_d_diff(2, n) = 0.D0
            f_diff(1) = f_diff(1) + gam_d(i, n)*2.0*fgam_d_diff(1, n)
            fgam_d_diff(1, n) = 0.D0
          ENDDO
          gam_diff(i) = gam_diff(i) + f(3)*2.0*fgam_diff(3) + f(2)*2.0*
     +      fgam_diff(2) + f(1)*2.0*fgam_diff(1)
          f_diff(3) = f_diff(3) + gam(i)*2.0*fgam_diff(3)
          fgam_diff(3) = 0.D0
          f_diff(2) = f_diff(2) + gam(i)*2.0*fgam_diff(2)
          fgam_diff(2) = 0.D0
          f_diff(1) = f_diff(1) + gam(i)*2.0*fgam_diff(1)
          fgam_diff(1) = 0.D0
          CALL CROSS_B(veff, veff_diff, g, g_diff, f, f_diff)
          rv2_diff(3, i) = rv2_diff(3, i) + g_diff(3)
          rv1_diff(3, i) = rv1_diff(3, i) - g_diff(3)
          g_diff(3) = 0.D0
          rv2_diff(2, i) = rv2_diff(2, i) + g_diff(2)
          rv1_diff(2, i) = rv1_diff(2, i) - g_diff(2)
          g_diff(2) = 0.D0
          rv2_diff(1, i) = rv2_diff(1, i) + g_diff(1)
          rv1_diff(1, i) = rv1_diff(1, i) - g_diff(1)
          g_diff(1) = 0.D0
          vinf_diff(3) = vinf_diff(3) + veff_diff(3)
          vrot_diff(3) = vrot_diff(3) + veff_diff(3)
          wv_diff(3, i) = wv_diff(3, i) + veff_diff(3)
          veff_diff(3) = 0.D0
          vinf_diff(2) = vinf_diff(2) + veff_diff(2)
          vrot_diff(2) = vrot_diff(2) + veff_diff(2)
          wv_diff(2, i) = wv_diff(2, i) + veff_diff(2)
          veff_diff(2) = 0.D0
          vinf_diff(1) = vinf_diff(1) + veff_diff(1)
          vrot_diff(1) = vrot_diff(1) + veff_diff(1)
          wv_diff(1, i) = wv_diff(1, i) + veff_diff(1)
          veff_diff(1) = 0.D0
          DO ii1=1,3
            wrot_diff(ii1) = 0.D0
          ENDDO
          CALL CROSS_B(rrot, rrot_diff, wrot, wrot_diff, vrot, vrot_diff
     +                )
          rv_diff(3, i) = rv_diff(3, i) + rrot_diff(3) + r_diff(3)
          xyzref_diff(3) = xyzref_diff(3) - rrot_diff(3)
          rrot_diff(3) = 0.D0
          rv_diff(2, i) = rv_diff(2, i) + rrot_diff(2) + r_diff(2)
          xyzref_diff(2) = xyzref_diff(2) - rrot_diff(2)
          rrot_diff(2) = 0.D0
          rv_diff(1, i) = rv_diff(1, i) + rrot_diff(1) + r_diff(1)
          xyzref_diff(1) = xyzref_diff(1) - rrot_diff(1)
          rrot_diff(1) = 0.D0
          zr_diff = zr_diff - r_diff(3)
          r_diff(3) = 0.D0
          yr_diff = yr_diff - r_diff(2)
          r_diff(2) = 0.D0
          xr_diff = xr_diff - r_diff(1)
          r_diff(1) = 0.D0
        ENDDO
        DO n=ncontrol,1,-1
          cmz_d_diff(n) = 0.D0
          cmy_d_diff(n) = 0.D0
          cmx_d_diff(n) = 0.D0
          cfz_d_diff(n) = 0.D0
          cfy_d_diff(n) = 0.D0
          cfx_d_diff(n) = 0.D0
        ENDDO
        rle_diff(3, j) = rle_diff(3, j) + zr_diff
        rle_diff(2, j) = rle_diff(2, j) + yr_diff
        rle_diff(1, j) = rle_diff(1, j) + xr_diff
        cr_diff = cr_diff + 0.25*xr_diff
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(ulift(3))
          ulift_diff(3) = 0.D0
          ulmag_diff = 0.D0
        ELSE
          CALL POPREAL8(ulift(3))
          CALL POPREAL8(ulift(2))
          CALL POPREAL8(ulift(1))
          ulmag_diff = -(ulift(3)*ulift_diff(3)/ulmag**2) - ulift(2)*
     +      ulift_diff(2)/ulmag**2 - ulift(1)*ulift_diff(1)/ulmag**2
          ulift_diff(3) = ulift_diff(3)/ulmag
          ulift_diff(2) = ulift_diff(2)/ulmag
          ulift_diff(1) = ulift_diff(1)/ulmag
        END IF
        IF (result1 .EQ. 0.D0) THEN
          result1_diff = 0.D0
        ELSE
          result1_diff = ulmag_diff/(2.0*SQRT(result1))
        END IF
        CALL DOT_B(ulift, ulift_diff, ulift, ulift_diff, result1_diff)
        CALL CROSS_B(udrag, udrag_diff, spn, spn_diff, ulift, ulift_diff
     +              )
        sina_diff = sina_diff + udrag_diff(3)
        udrag_diff(3) = 0.D0
        udrag_diff(2) = 0.D0
        cosa_diff = cosa_diff + udrag_diff(1)
        udrag_diff(1) = 0.D0
        ensy_diff(j) = ensy_diff(j) - spn_diff(3)
        spn_diff(3) = 0.D0
        ensz_diff(j) = ensz_diff(j) + spn_diff(2)
        spn_diff(2) = 0.D0
        spn_diff(1) = 0.D0
        rle2_diff(1, j) = rle2_diff(1, j) + xte2_diff
        chord2_diff(j) = chord2_diff(j) + xte2_diff
        rle1_diff(1, j) = rle1_diff(1, j) + xte1_diff
        chord1_diff(j) = chord1_diff(j) + xte1_diff
        chord_diff(j) = chord_diff(j) + wstrip(j)*sr_diff + cr_diff
        wstrip_diff(j) = wstrip_diff(j) + chord(j)*sr_diff
      ENDDO
      alfa_diff = alfa_diff + COS(alfa)*sina_diff - SIN(alfa)*cosa_diff
      END

C  Differentiation of bdforc in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: alfa vinf sref bref cdtot cltot
C                cxtot cytot cztot crtot cmtot cntot
C   with respect to varying inputs: alfa vinf sref cref bref xyzref
C                mach cdtot cltot cxtot cytot cztot crtot cmtot
C                cntot
C SFFORC
C
C
C
      SUBROUTINE BDFORC_B()
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
C
      REAL rrot(3)
      REAL rrot_diff(3)
      REAL veff(3), vrot(3), veff_u(3, 6), vrot_u(3), wrot_u(3)
      REAL veff_diff(3), vrot_diff(3)
      REAL drl(3), esl(3), fb(3), fb_u(3, numax), mb(3), mb_u(3, numax)
      REAL drl_diff(3), esl_diff(3), fb_diff(3), mb_diff(3)
      REAL cdbdy_u(numax), clbdy_u(numax), cxbdy_u(numax), cybdy_u(numax
     +     ), czbdy_u(numax), crbdy_u(numax), cmbdy_u(numax), cnbdy_u(
     +     numax)
      REAL betm
      REAL betm_diff
      INTRINSIC SQRT
      REAL sina
      REAL sina_diff
      INTRINSIC SIN
      REAL cosa
      REAL cosa_diff
      INTRINSIC COS
      INTEGER ib
      INTEGER iu
      INTEGER ilseg
      INTEGER l1
      INTEGER l2
      INTEGER l
      REAL drlmag
      REAL drlmag_diff
      REAL drlmi
      REAL drlmi_diff
      REAL dia
      REAL dinv
      INTEGER k
      REAL us
      REAL us_diff
      REAL un
      REAL un_diff
      REAL un_u
      REAL temp_diff
      INTEGER ii1
      REAL(kind=8) temp_diff0
      REAL(kind=avl_real) temp_diff1
      INTEGER branch
      INTEGER ad_to
C
C
      betm = SQRT(1.0 - mach**2)
C
      sina = SIN(alfa)
      cosa = COS(alfa)
C
C
C---- add on body force contributions
      DO ib=1,nbody
C
        DO ilseg=1,nl(ib)-1
          l1 = lfrst(ib) + ilseg - 1
          l2 = lfrst(ib) + ilseg
C
          l = l1
C
          CALL PUSHREAL8(drl(1))
          drl(1) = (rl(1, l2)-rl(1, l1))/betm
          CALL PUSHREAL8(drl(2))
          drl(2) = rl(2, l2) - rl(2, l1)
          CALL PUSHREAL8(drl(3))
          drl(3) = rl(3, l2) - rl(3, l1)
          CALL PUSHREAL8(drlmag)
          drlmag = SQRT(drl(1)**2 + drl(2)**2 + drl(3)**2)
          IF (drlmag .EQ. 0.0) THEN
            CALL PUSHREAL8(drlmi)
            drlmi = 0.0
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHREAL8(drlmi)
            drlmi = 1.0/drlmag
            CALL PUSHCONTROL1B(1)
          END IF
C
C-------- unit vector along line segment
          CALL PUSHREAL8(esl(1))
          esl(1) = drl(1)*drlmi
          CALL PUSHREAL8(esl(2))
          esl(2) = drl(2)*drlmi
          CALL PUSHREAL8(esl(3))
          esl(3) = drl(3)*drlmi
C
          CALL PUSHREAL8(rrot(1))
          rrot(1) = 0.5*(rl(1, l2)+rl(1, l1)) - xyzref(1)
          CALL PUSHREAL8(rrot(2))
          rrot(2) = 0.5*(rl(2, l2)+rl(2, l1)) - xyzref(2)
          CALL PUSHREAL8(rrot(3))
          rrot(3) = 0.5*(rl(3, l2)+rl(3, l1)) - xyzref(3)
C
C-------- go over freestream velocity and rotation components
          CALL PUSHREAL8ARRAY(vrot, 3)
          CALL CROSS(rrot, wrot, vrot)
C
          CALL PUSHREAL8(veff(1))
          veff(1) = (vinf(1)+vrot(1))/betm
          CALL PUSHREAL8(veff(2))
          veff(2) = vinf(2) + vrot(2)
          CALL PUSHREAL8(veff(3))
          veff(3) = vinf(3) + vrot(3)
C
C-------- U.es
          us = veff(1)*esl(1) + veff(2)*esl(2) + veff(3)*esl(3)
C
C
C-------- velocity projected on normal plane = U - (U.es) es
          DO k=1,3
            un = veff(k) - us*esl(k)
            CALL PUSHREAL8(fb(k))
            fb(k) = un*src(l)
          ENDDO
C
          CALL PUSHREAL8ARRAY(mb, 3)
          CALL CROSS(rrot, fb, mb)
        ENDDO
        CALL PUSHINTEGER4(ilseg - 1)
      ENDDO
      cref_diff = 0.D0
      DO ii1=1,3
        xyzref_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nbmax
        cdbdy_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nbmax
        clbdy_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nbmax
        cxbdy_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nbmax
        cybdy_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nbmax
        czbdy_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nbmax
        crbdy_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nbmax
        cnbdy_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nbmax
        cmbdy_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        esl_diff(ii1) = 0.D0
      ENDDO
      cosa_diff = 0.D0
      DO ii1=1,3
        drl_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        vrot_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        fb_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        veff_diff(ii1) = 0.D0
      ENDDO
      sina_diff = 0.D0
      DO ii1=1,3
        mb_diff(ii1) = 0.D0
      ENDDO
      betm_diff = 0.D0
      DO ii1=1,3
        rrot_diff(ii1) = 0.D0
      ENDDO
      DO ib=nbody,1,-1
        cnbdy_diff(ib) = cnbdy_diff(ib) + cntot_diff
        cmbdy_diff(ib) = cmbdy_diff(ib) + cmtot_diff
        crbdy_diff(ib) = crbdy_diff(ib) + crtot_diff
        czbdy_diff(ib) = czbdy_diff(ib) + cztot_diff
        cybdy_diff(ib) = cybdy_diff(ib) + cytot_diff
        cxbdy_diff(ib) = cxbdy_diff(ib) + cxtot_diff
        clbdy_diff(ib) = clbdy_diff(ib) + cltot_diff
        cdbdy_diff(ib) = cdbdy_diff(ib) + cdtot_diff
        CALL POPINTEGER4(ad_to)
        DO ilseg=ad_to,1,-1
          temp_diff0 = 2.0*cnbdy_diff(ib)/(sref*bref)
          mb_diff(3) = mb_diff(3) + temp_diff0
          temp_diff1 = -(mb(3)*temp_diff0/(sref*bref))
          sref_diff = sref_diff + bref*temp_diff1
          bref_diff = bref_diff + sref*temp_diff1
          temp_diff0 = 2.0*cmbdy_diff(ib)/(sref*cref)
          mb_diff(2) = mb_diff(2) + temp_diff0
          temp_diff1 = -(mb(2)*temp_diff0/(sref*cref))
          sref_diff = sref_diff + cref*temp_diff1
          cref_diff = cref_diff + sref*temp_diff1
          temp_diff0 = 2.0*crbdy_diff(ib)/(sref*bref)
          mb_diff(1) = mb_diff(1) + temp_diff0
          temp_diff1 = -(mb(1)*temp_diff0/(sref*bref))
          bref_diff = bref_diff + sref*temp_diff1
          temp_diff0 = 2.0*czbdy_diff(ib)/sref
          sref_diff = sref_diff + bref*temp_diff1 - fb(3)*temp_diff0/
     +      sref
          fb_diff(3) = fb_diff(3) + temp_diff0
          temp_diff0 = 2.0*cybdy_diff(ib)/sref
          fb_diff(2) = fb_diff(2) + temp_diff0
          sref_diff = sref_diff - fb(2)*temp_diff0/sref
          temp_diff0 = 2.0*cxbdy_diff(ib)/sref
          fb_diff(1) = fb_diff(1) + temp_diff0
          sref_diff = sref_diff - fb(1)*temp_diff0/sref
          temp_diff0 = 2.0*clbdy_diff(ib)/sref
          fb_diff(3) = fb_diff(3) + cosa*temp_diff0
          cosa_diff = cosa_diff + fb(3)*temp_diff0
          fb_diff(1) = fb_diff(1) - sina*temp_diff0
          sina_diff = sina_diff - fb(1)*temp_diff0
          sref_diff = sref_diff - (fb(3)*cosa-fb(1)*sina)*temp_diff0/
     +      sref
          temp_diff0 = 2.0*cdbdy_diff(ib)/sref
          fb_diff(1) = fb_diff(1) + cosa*temp_diff0
          cosa_diff = cosa_diff + fb(1)*temp_diff0
          fb_diff(3) = fb_diff(3) + sina*temp_diff0
          sina_diff = sina_diff + fb(3)*temp_diff0
          sref_diff = sref_diff - (fb(1)*cosa+fb(3)*sina)*temp_diff0/
     +      sref
          CALL POPREAL8ARRAY(mb, 3)
          CALL CROSS_B(rrot, rrot_diff, fb, fb_diff, mb, mb_diff)
          l1 = lfrst(ib) + ilseg - 1
          l = l1
          us = veff(1)*esl(1) + veff(2)*esl(2) + veff(3)*esl(3)
          us_diff = 0.D0
          DO k=3,1,-1
            CALL POPREAL8(fb(k))
            un_diff = src(l)*fb_diff(k)
            fb_diff(k) = 0.D0
            veff_diff(k) = veff_diff(k) + un_diff
            us_diff = us_diff - esl(k)*un_diff
            esl_diff(k) = esl_diff(k) - us*un_diff
          ENDDO
          veff_diff(1) = veff_diff(1) + esl(1)*us_diff
          esl_diff(1) = esl_diff(1) + veff(1)*us_diff
          veff_diff(2) = veff_diff(2) + esl(2)*us_diff
          esl_diff(2) = esl_diff(2) + veff(2)*us_diff
          veff_diff(3) = veff_diff(3) + esl(3)*us_diff
          esl_diff(3) = esl_diff(3) + veff(3)*us_diff
          CALL POPREAL8(veff(3))
          vinf_diff(3) = vinf_diff(3) + veff_diff(3)
          vrot_diff(3) = vrot_diff(3) + veff_diff(3)
          veff_diff(3) = 0.D0
          CALL POPREAL8(veff(2))
          vinf_diff(2) = vinf_diff(2) + veff_diff(2)
          vrot_diff(2) = vrot_diff(2) + veff_diff(2)
          veff_diff(2) = 0.D0
          CALL POPREAL8(veff(1))
          temp_diff0 = veff_diff(1)/betm
          veff_diff(1) = 0.D0
          vinf_diff(1) = vinf_diff(1) + temp_diff0
          vrot_diff(1) = vrot_diff(1) + temp_diff0
          betm_diff = betm_diff - (vinf(1)+vrot(1))*temp_diff0/betm
          CALL POPREAL8ARRAY(vrot, 3)
          DO ii1=1,3
            wrot_diff(ii1) = 0.D0
          ENDDO
          CALL CROSS_B(rrot, rrot_diff, wrot, wrot_diff, vrot, vrot_diff
     +                )
          l2 = lfrst(ib) + ilseg
          CALL POPREAL8(rrot(3))
          xyzref_diff(3) = xyzref_diff(3) - rrot_diff(3)
          rrot_diff(3) = 0.D0
          CALL POPREAL8(rrot(2))
          xyzref_diff(2) = xyzref_diff(2) - rrot_diff(2)
          rrot_diff(2) = 0.D0
          CALL POPREAL8(rrot(1))
          xyzref_diff(1) = xyzref_diff(1) - rrot_diff(1)
          rrot_diff(1) = 0.D0
          CALL POPREAL8(esl(3))
          drl_diff(3) = drl_diff(3) + drlmi*esl_diff(3)
          drlmi_diff = drl(3)*esl_diff(3) + drl(2)*esl_diff(2) + drl(1)*
     +      esl_diff(1)
          esl_diff(3) = 0.D0
          CALL POPREAL8(esl(2))
          drl_diff(2) = drl_diff(2) + drlmi*esl_diff(2)
          esl_diff(2) = 0.D0
          CALL POPREAL8(esl(1))
          drl_diff(1) = drl_diff(1) + drlmi*esl_diff(1)
          esl_diff(1) = 0.D0
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(drlmi)
            drlmag_diff = 0.D0
          ELSE
            CALL POPREAL8(drlmi)
            drlmag_diff = -(drlmi_diff/drlmag**2)
          END IF
          CALL POPREAL8(drlmag)
          IF (drl(1)**2 + drl(2)**2 + drl(3)**2 .EQ. 0.D0) THEN
            temp_diff = 0.D0
          ELSE
            temp_diff = drlmag_diff/(2.0*SQRT(drl(1)**2+drl(2)**2+drl(3)
     +        **2))
          END IF
          drl_diff(1) = drl_diff(1) + 2*drl(1)*temp_diff
          drl_diff(3) = 0.D0
          CALL POPREAL8(drl(3))
          drl_diff(2) = 0.D0
          CALL POPREAL8(drl(2))
          CALL POPREAL8(drl(1))
          betm_diff = betm_diff - (rl(1, l2)-rl(1, l1))*drl_diff(1)/betm
     +      **2
          drl_diff(1) = 0.D0
        ENDDO
        cnbdy_diff(ib) = 0.D0
        cmbdy_diff(ib) = 0.D0
        crbdy_diff(ib) = 0.D0
        czbdy_diff(ib) = 0.D0
        cybdy_diff(ib) = 0.D0
        cxbdy_diff(ib) = 0.D0
        clbdy_diff(ib) = 0.D0
        cdbdy_diff(ib) = 0.D0
      ENDDO
      alfa_diff = alfa_diff + COS(alfa)*sina_diff - SIN(alfa)*cosa_diff
      IF (1.0 - mach**2 .EQ. 0.D0) THEN
        mach_diff = 0.D0
      ELSE
        mach_diff = -(2*mach*betm_diff/(2.0*SQRT(1.0-mach**2)))
      END IF
      END

C  Differentiation of vinfab in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: alfa beta vinf
C   with respect to varying inputs: alfa beta vinf
C BDFORC
C
C
C
      SUBROUTINE VINFAB_B()
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
      REAL sina
      REAL sina_diff
      INTRINSIC SIN
      REAL cosa
      REAL cosa_diff
      INTRINSIC COS
      REAL sinb
      REAL sinb_diff
      REAL cosb
      REAL cosb_diff
C
      sina = SIN(alfa)
      cosa = COS(alfa)
      cosb = COS(beta)
C
C
C
C
      sina_diff = cosb*vinf_diff(3)
      cosb_diff = sina*vinf_diff(3) + cosa*vinf_diff(1)
      vinf_diff(3) = 0.D0
      sinb_diff = -vinf_diff(2)
      vinf_diff(2) = 0.D0
      cosa_diff = cosb*vinf_diff(1)
      vinf_diff(1) = 0.D0
      beta_diff = beta_diff + COS(beta)*sinb_diff - SIN(beta)*cosb_diff
      alfa_diff = alfa_diff + COS(alfa)*sina_diff - SIN(alfa)*cosa_diff
      END
C VINFAB

