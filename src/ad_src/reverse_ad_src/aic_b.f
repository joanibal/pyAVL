C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) - 15 Jan 2021 14:26
C
C  Differentiation of vvor in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: chordv rc rv1 rv2 zsym ysym
C                wc_gam
C   with respect to varying inputs: chordv rc rv1 rv2 zsym betm
C                ysym wc_gam
C***********************************************************************
C    Module:  aic.f
C 
C    Copyright (C) 2002 Mark Drela, Harold Youngren
C 
C    This program is free software; you can redistribute it and/or modify
C    it under the terms of the GNU General Public License as published by
C    the Free Software Foundation; either version 2 of the License, or
C    (at your option) any later version.
C
C    This program is distributed in the hope that it will be useful,
C    but WITHOUT ANY WARRANTY; without even the implied warranty of
C    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
C    GNU General Public License for more details.
C
C    You should have received a copy of the GNU General Public License
C    along with this program; if not, write to the Free Software
C    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
C***********************************************************************
C
C
      SUBROUTINE VVOR_B(betm, betm_diff, iysym, ysym, ysym_diff, izsym, 
     +                  zsym, zsym_diff, vrcore, nv, rv1, rv1_diff, rv2
     +                  , rv2_diff, nsurfv, chordv, chordv_diff, nc, rc
     +                  , rc_diff, nsurfc, lvtest, wc_gam, wc_gam_diff, 
     +                  ncdim)
      INTEGER nv
C--------------------------------------------------------------------
C     Calculates the velocity influence matrix for a collection 
C     of horseshoe vortices and control points
C     
C Input
C -----
C     BETM      SQRT(1-MACH*MACH)
C     IYSYM     Plane of symmetry XZ 
C                = 0 no symmetry
C                = 1 regular symmetry
C                =-1 free-surface symmetry
C     YSYM      Y coordinate of symmetry plane
C     IZSYM     Second plane of symmetry XY 
C                = 0 no second plane
C                = 1 regular symmetry
C                =-1 free-surface symmetry
C     ZSYM      Z coordinate of symmetry plane
C
C     VRCORE    vortex-line core radius / max(semichord,vortex width)
C
C     NV        number of vortices
C     RV1(3,v)  coordinates of endpoint #1 of the vortices
C     RV2(3,v)  coordinates of endpoint #2 of the vortices
C     NSURFV(v) index of surface containing h.v.
C     CHORDV(v) chord of strip containing h.v.
C
C     NC        number of control points
C     RC(3,c)   coordinates of the control points
C     NSURFC(c) index of surface containing c.p.
C     LVTEST    T if core-radius test is to be applied
C
C     NCDIM     declared size of WC_GAM matrix
C     
C Output
C ------
C     WC_GAM(3..)   Induced-velocity/gamma influence matrix
C     
C--------------------------------------------------------------------
      REAL rv1(3, nv), rv2(3, nv), chordv(nv)
      REAL rv1_diff(3, nv), rv2_diff(3, nv), chordv_diff(nv)
      INTEGER nc
      INTEGER ncdim
      REAL rc(3, nc), wc_gam(3, ncdim, ncdim)
      REAL rc_diff(3, nc), wc_gam_diff(3, ncdim, ncdim)
      INTEGER nsurfv(nv), nsurfc(nc)
      LOGICAL lvtest
C     
      LOGICAL lbound
      REAL fysym
      INTRINSIC FLOAT
      REAL fzsym
      INTEGER i
      REAL x
      REAL x_diff
      REAL y
      REAL y_diff
      REAL z
      REAL z_diff
      REAL u
      REAL u_diff
      REAL v
      REAL v_diff
      REAL w
      REAL w_diff
      INTEGER j
      REAL dsyz
      REAL dsyz_diff
      INTRINSIC SQRT
      REAL rcore
      REAL rcore_diff
      INTRINSIC MAX
      REAL ui
      REAL ui_diff
      REAL vi
      REAL vi_diff
      REAL wi
      REAL wi_diff
      REAL yoff
      REAL yoff_diff
      REAL zoff
      REAL zoff_diff
      REAL xave
      REAL yave
      REAL zave
      REAL uii
      REAL uii_diff
      REAL vii
      REAL vii_diff
      REAL wii
      REAL wii_diff
      REAL us
      REAL us_diff
      REAL vs
      REAL vs_diff
      REAL ws
      REAL ws_diff
      REAL arg1
      REAL arg1_diff
      REAL arg2
      REAL arg2_diff
      REAL arg3
      REAL arg3_diff
      REAL arg4
      REAL arg4_diff
      REAL temp
      REAL temp0
      REAL temp_diff
      REAL temp_diff0
      REAL temp_diff1
      INTEGER branch
      REAL vrcore
      REAL zsym
      REAL zsym_diff
      INTEGER izsym
      REAL betm
      REAL betm_diff
      REAL ysym
      REAL ysym_diff
      INTEGER iysym
C     
C     
      fysym = FLOAT(iysym)
      fzsym = FLOAT(izsym)
      betm_diff = 0.D0
C$BWD-OF II-LOOP 
      DO i=1,nc
C...  Control point location
        x = rc(1, i)
        y = rc(2, i)
        z = rc(3, i)
C     
        x_diff = 0.D0
        y_diff = 0.D0
        z_diff = 0.D0
C$BWD-OF II-LOOP 
        DO j=1,nv
C--------- set vortex core
          dsyz = SQRT((rv2(2, j)-rv1(2, j))**2 + (rv2(3, j)-rv1(3, j))**
     +      2)
          IF (nsurfc(i) .EQ. nsurfv(j)) THEN
            rcore = 0.0001*dsyz
            CALL PUSHCONTROL2B(0)
          ELSE IF (vrcore*chordv(j) .LT. 2.0*vrcore*dsyz) THEN
            rcore = 2.0*vrcore*dsyz
            CALL PUSHCONTROL2B(2)
          ELSE
            rcore = vrcore*chordv(j)
            CALL PUSHCONTROL2B(1)
          END IF
C     
C     
          yoff = 2.0*ysym
          zoff = 2.0*zsym
CCC   ZOFF = 2.0*(ZSYM + ALFA*0.5*(RV1(1,J)+RV2(1,J)) )
C     
C...  Calculate the influence of the REAL vortex
C
C     
          IF (iysym .NE. 0) THEN
C...  Calculate the influence of the y-IMAGE vortex
            lbound = .true.
C...  For sym/asym matrices check for vortex midpoints of image vortices
            IF (iysym .EQ. 1) THEN
              xave = 0.5*(rv1(1, j)+rv2(1, j))
              yave = yoff - 0.5*(rv1(2, j)+rv2(2, j))
              zave = 0.5*(rv1(3, j)+rv2(3, j))
              IF (x .EQ. xave .AND. y .EQ. yave .AND. z .EQ. zave) THEN
                CALL PUSHCONTROL1B(0)
                lbound = .false.
              ELSE
                CALL PUSHCONTROL1B(0)
              END IF
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
C     
          IF (izsym .NE. 0) THEN
C...  Calculate the influence of the z-IMAGE vortex
            CALL PUSHBOOLEAN(lbound)
C     
C...  Calculate the influence of the y,z-IMAGE vortex
            IF (iysym .NE. 0) THEN
              lbound = .true.
              arg1 = yoff - rv1(2, j)
              arg2 = zoff - rv1(3, j)
              arg3 = yoff - rv2(2, j)
              arg4 = zoff - rv2(3, j)
C     
              CALL PUSHCONTROL2B(0)
            ELSE
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE
            CALL PUSHCONTROL2B(2)
          END IF
          ws_diff = wc_gam_diff(3, i, j)
          wc_gam_diff(3, i, j) = 0.D0
          vs_diff = wc_gam_diff(2, i, j)
          wc_gam_diff(2, i, j) = 0.D0
          us_diff = wc_gam_diff(1, i, j)
          wc_gam_diff(1, i, j) = 0.D0
          w_diff = ws_diff
          wi_diff = ws_diff
          v_diff = vs_diff
          vi_diff = vs_diff
          u_diff = us_diff
          ui_diff = us_diff
          CALL POPCONTROL2B(branch)
          IF (branch .EQ. 0) THEN
            wii_diff = fysym*fzsym*wi_diff
            vii_diff = fysym*fzsym*vi_diff
            uii_diff = fysym*fzsym*ui_diff
            arg1_diff = 0.D0
            arg2_diff = 0.D0
            arg3_diff = 0.D0
            arg4_diff = 0.D0
            rcore_diff = 0.D0
            CALL VORVELC_B(x, x_diff, y, y_diff, z, z_diff, lbound, rv1(
     +                     1, j), rv1_diff(1, j), arg1, arg1_diff, arg2
     +                     , arg2_diff, rv2(1, j), rv2_diff(1, j), arg3
     +                     , arg3_diff, arg4, arg4_diff, betm, betm_diff
     +                     , uii, uii_diff, vii, vii_diff, wii, wii_diff
     +                     , rcore, rcore_diff)
            zoff_diff = arg4_diff + arg2_diff
            rv2_diff(3, j) = rv2_diff(3, j) - arg4_diff
            yoff_diff = arg3_diff + arg1_diff
            rv2_diff(2, j) = rv2_diff(2, j) - arg3_diff
            rv1_diff(3, j) = rv1_diff(3, j) - arg2_diff
            rv1_diff(2, j) = rv1_diff(2, j) - arg1_diff
          ELSE IF (branch .EQ. 1) THEN
            rcore_diff = 0.D0
            zoff_diff = 0.D0
            yoff_diff = 0.D0
          ELSE
            rcore_diff = 0.D0
            zoff_diff = 0.D0
            yoff_diff = 0.D0
            GOTO 100
          END IF
          wii_diff = fzsym*w_diff
          vii_diff = fzsym*v_diff
          uii_diff = fzsym*u_diff
          lbound = .true.
          arg1 = zoff - rv2(3, j)
          arg2 = zoff - rv1(3, j)
          arg1_diff = 0.D0
          arg2_diff = 0.D0
          CALL VORVELC_B(x, x_diff, y, y_diff, z, z_diff, lbound, rv2(1
     +                   , j), rv2_diff(1, j), rv2(2, j), rv2_diff(2, j)
     +                   , arg1, arg1_diff, rv1(1, j), rv1_diff(1, j), 
     +                   rv1(2, j), rv1_diff(2, j), arg2, arg2_diff, 
     +                   betm, betm_diff, uii, uii_diff, vii, vii_diff, 
     +                   wii, wii_diff, rcore, rcore_diff)
          zoff_diff = zoff_diff + arg2_diff + arg1_diff
          rv1_diff(3, j) = rv1_diff(3, j) - arg2_diff
          rv2_diff(3, j) = rv2_diff(3, j) - arg1_diff
          CALL POPBOOLEAN(lbound)
 100      CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            wi_diff = fysym*wi_diff
            vi_diff = fysym*vi_diff
            ui_diff = fysym*ui_diff
            arg1 = yoff - rv2(2, j)
            arg2 = yoff - rv1(2, j)
            arg1_diff = 0.D0
            arg2_diff = 0.D0
            CALL VORVELC_B(x, x_diff, y, y_diff, z, z_diff, lbound, rv2(
     +                     1, j), rv2_diff(1, j), arg1, arg1_diff, rv2(3
     +                     , j), rv2_diff(3, j), rv1(1, j), rv1_diff(1, 
     +                     j), arg2, arg2_diff, rv1(3, j), rv1_diff(3, j
     +                     ), betm, betm_diff, ui, ui_diff, vi, vi_diff
     +                     , wi, wi_diff, rcore, rcore_diff)
            yoff_diff = yoff_diff + arg2_diff + arg1_diff
            rv1_diff(2, j) = rv1_diff(2, j) - arg2_diff
            rv2_diff(2, j) = rv2_diff(2, j) - arg1_diff
            CALL POPCONTROL1B(branch)
          END IF
          lbound = .NOT.(lvtest .AND. i .EQ. j)
          CALL VORVELC_B(x, x_diff, y, y_diff, z, z_diff, lbound, rv1(1
     +                   , j), rv1_diff(1, j), rv1(2, j), rv1_diff(2, j)
     +                   , rv1(3, j), rv1_diff(3, j), rv2(1, j), 
     +                   rv2_diff(1, j), rv2(2, j), rv2_diff(2, j), rv2(
     +                   3, j), rv2_diff(3, j), betm, betm_diff, u, 
     +                   u_diff, v, v_diff, w, w_diff, rcore, rcore_diff
     +                  )
          zsym_diff = zsym_diff + 2.0*zoff_diff
          ysym_diff = ysym_diff + 2.0*yoff_diff
          CALL POPCONTROL2B(branch)
          IF (branch .EQ. 0) THEN
            dsyz_diff = 0.0001*rcore_diff
          ELSE IF (branch .EQ. 1) THEN
            chordv_diff(j) = chordv_diff(j) + vrcore*rcore_diff
            dsyz_diff = 0.D0
          ELSE
            dsyz_diff = vrcore*2.0*rcore_diff
          END IF
          temp = rv2(3, j) - rv1(3, j)
          temp0 = rv2(2, j) - rv1(2, j)
          IF (temp0**2 + temp**2 .EQ. 0.D0) THEN
            temp_diff = 0.D0
          ELSE
            temp_diff = dsyz_diff/(2.0*SQRT(temp0**2+temp**2))
          END IF
          temp_diff0 = 2*temp0*temp_diff
          temp_diff1 = 2*temp*temp_diff
          rv2_diff(3, j) = rv2_diff(3, j) + temp_diff1
          rv1_diff(3, j) = rv1_diff(3, j) - temp_diff1
          rv2_diff(2, j) = rv2_diff(2, j) + temp_diff0
          rv1_diff(2, j) = rv1_diff(2, j) - temp_diff0
        ENDDO
        rc_diff(3, i) = rc_diff(3, i) + z_diff
        rc_diff(2, i) = rc_diff(2, i) + y_diff
        rc_diff(1, i) = rc_diff(1, i) + x_diff
      ENDDO
      END

C  Differentiation of cross in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: u v w
C   with respect to varying inputs: u v w
C SRDSET
C
C
C
      SUBROUTINE CROSS_B(u, u_diff, v, v_diff, w, w_diff)
      REAL u(3), v(3), w(3)
      REAL u_diff(3), v_diff(3), w_diff(3)
      u_diff(1) = u_diff(1) + v(2)*w_diff(3) - v(3)*w_diff(2)
      v_diff(2) = v_diff(2) + u(1)*w_diff(3) - u(3)*w_diff(1)
      u_diff(2) = u_diff(2) + v(3)*w_diff(1) - v(1)*w_diff(3)
      v_diff(1) = v_diff(1) + u(3)*w_diff(2) - u(2)*w_diff(3)
      w_diff(3) = 0.D0
      u_diff(3) = u_diff(3) + v(1)*w_diff(2) - v(2)*w_diff(1)
      v_diff(3) = v_diff(3) + u(2)*w_diff(1) - u(1)*w_diff(2)
      w_diff(2) = 0.D0
      w_diff(1) = 0.D0
      END

C  Differentiation of dot in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: u v dot
C   with respect to varying inputs: u v
C
C
      SUBROUTINE DOT_B(u, u_diff, v, v_diff, dot_diff)
      REAL u(3), v(3)
      REAL u_diff(3), v_diff(3)
      REAL dot
      REAL dot_diff
      u_diff(1) = u_diff(1) + v(1)*dot_diff
      v_diff(1) = v_diff(1) + u(1)*dot_diff
      u_diff(2) = u_diff(2) + v(2)*dot_diff
      v_diff(2) = v_diff(2) + u(2)*dot_diff
      u_diff(3) = u_diff(3) + v(3)*dot_diff
      v_diff(3) = v_diff(3) + u(3)*dot_diff
      END

C  Differentiation of vorvelc in reverse (adjoint) mode (with options i4 dr8 r8):
C   gradient     of useful results: y1 y2 rcore u v w x y z z1
C                z2 x1 x2 beta
C   with respect to varying inputs: y1 y2 rcore x y z z1 z2 x1
C                x2 beta
C VORVEL
C
C
C
C
      SUBROUTINE VORVELC_B(x, x_diff, y, y_diff, z, z_diff, lbound, x1, 
     +                     x1_diff, y1, y1_diff, z1, z1_diff, x2, 
     +                     x2_diff, y2, y2_diff, z2, z2_diff, beta, 
     +                     beta_diff, u, u_diff, v, v_diff, w, w_diff, 
     +                     rcore, rcore_diff)
C----------------------------------------------------------
C     Same as VORVEL, with finite core radius
C     Uses Scully (also Burnham-Hallock) core model 
C       Vtan = Gam/2*pi . r/(r^2 +rcore^2)
C----------------------------------------------------------
      LOGICAL lbound
C
C
      REAL a(3), b(3), axb(3)
      REAL a_diff(3), b_diff(3), axb_diff(3)
      REAL asq
      REAL asq_diff
      REAL bsq
      REAL bsq_diff
      REAL amag
      REAL amag_diff
      INTRINSIC SQRT
      REAL bmag
      REAL bmag_diff
      REAL axbsq
      REAL axbsq_diff
      REAL adb
      REAL adb_diff
      REAL alsq
      REAL alsq_diff
      REAL ab
      REAL t
      REAL t_diff
      REAL axisq
      REAL axisq_diff
      REAL adi
      REAL adi_diff
      REAL rsq
      REAL rsq_diff
      REAL bxisq
      REAL bxisq_diff
      REAL bdi
      REAL bdi_diff
      REAL temp
      REAL temp_diff
      REAL temp_diff0
      REAL temp0
      REAL temp1
      REAL temp_diff1
      REAL temp_diff2
      REAL temp2
      REAL temp3
      REAL temp_diff3
      REAL temp_diff4
      INTEGER ii1
      INTEGER branch
      REAL y1
      REAL y1_diff
      REAL y2
      REAL y2_diff
      REAL rcore
      REAL rcore_diff
      REAL u
      REAL u_diff
      REAL v
      REAL v_diff
      REAL w
      REAL w_diff
      REAL x
      REAL x_diff
      REAL y
      REAL y_diff
      REAL z
      REAL z_diff
      REAL z1
      REAL z1_diff
      REAL z2
      REAL z2_diff
      REAL x1
      REAL x1_diff
      REAL x2
      REAL x2_diff
      REAL beta
      REAL beta_diff
      REAL pi4inv
C
      DATA pi4inv /0.079577472/
C
      a(1) = (x1-x)/beta
      a(2) = y1 - y
      a(3) = z1 - z
C
      b(1) = (x2-x)/beta
      b(2) = y2 - y
      b(3) = z2 - z
C
      asq = a(1)**2 + a(2)**2 + a(3)**2
      bsq = b(1)**2 + b(2)**2 + b(3)**2
C
      amag = SQRT(asq)
      bmag = SQRT(bsq)
C
      u = 0.
C
C---- contribution from the transverse bound leg
      IF (lbound .AND. amag*bmag .NE. 0.0) THEN
        axb(1) = a(2)*b(3) - a(3)*b(2)
        axb(2) = a(3)*b(1) - a(1)*b(3)
        axb(3) = a(1)*b(2) - a(2)*b(1)
        axbsq = axb(1)**2 + axb(2)**2 + axb(3)**2
C
        adb = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
        alsq = asq + bsq - 2.0*adb
C
Ccc     RSQ = AXBSQ / ALSQ
C
C        T = (AMAG+BMAG)*(1.0 - ADB/AB) / (AXBSQ + ALSQ*RCORE**2)
        t = ((bsq-adb)/SQRT(bsq+rcore**2)+(asq-adb)/SQRT(asq+rcore**2))/
     +    (axbsq+alsq*rcore**2)
C
        u = axb(1)*t
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
C
C---- trailing leg attached to A
      IF (amag .NE. 0.0) THEN
        axisq = a(3)**2 + a(2)**2
C
        adi = a(1)
C
        CALL PUSHREAL8(t)
C
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
C
C---- trailing leg attached to B
      IF (bmag .NE. 0.0) THEN
        bxisq = b(3)**2 + b(2)**2
C
        bdi = b(1)
        rsq = bxisq
C
        CALL PUSHREAL8(t)
        t = (1.0-bdi/bmag)/(rsq+rcore**2)
C
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      w_diff = pi4inv*w_diff
      v_diff = pi4inv*v_diff
      temp_diff4 = pi4inv*u_diff/beta
      u_diff = temp_diff4
      beta_diff = beta_diff - u*temp_diff4/beta
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        t_diff = b(3)*v_diff - b(2)*w_diff
        temp_diff4 = t_diff/(rsq+rcore**2)
        temp_diff3 = -((1.0-bdi/bmag)*temp_diff4/(rsq+rcore**2))
        rsq_diff = temp_diff3
        bxisq_diff = rsq_diff
        DO ii1=1,3
          b_diff(ii1) = 0.D0
        ENDDO
        b_diff(2) = b_diff(2) + 2*b(2)*bxisq_diff - t*w_diff
        b_diff(3) = b_diff(3) + t*v_diff + 2*b(3)*bxisq_diff
        CALL POPREAL8(t)
        bdi_diff = -(temp_diff4/bmag)
        bmag_diff = bdi*temp_diff4/bmag**2
        rcore_diff = rcore_diff + 2*rcore*temp_diff3
        b_diff(1) = b_diff(1) + bdi_diff
      ELSE
        bmag_diff = 0.D0
        DO ii1=1,3
          b_diff(ii1) = 0.D0
        ENDDO
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        rsq = axisq
        t = -((1.0-adi/amag)/(rsq+rcore**2))
        DO ii1=1,3
          a_diff(ii1) = 0.D0
        ENDDO
        t_diff = a(3)*v_diff - a(2)*w_diff
        temp_diff4 = -(t_diff/(rsq+rcore**2))
        adi_diff = -(temp_diff4/amag)
        amag_diff = adi*temp_diff4/amag**2
        temp_diff3 = -((1.0-adi/amag)*temp_diff4/(rsq+rcore**2))
        rsq_diff = temp_diff3
        rcore_diff = rcore_diff + 2*rcore*temp_diff3
        axisq_diff = rsq_diff
        a_diff(2) = a_diff(2) + 2*a(2)*axisq_diff - t*w_diff
        a_diff(3) = a_diff(3) + t*v_diff + 2*a(3)*axisq_diff
        CALL POPREAL8(t)
        a_diff(1) = a_diff(1) + adi_diff
      ELSE
        amag_diff = 0.D0
        DO ii1=1,3
          a_diff(ii1) = 0.D0
        ENDDO
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        t_diff = axb(3)*w_diff + axb(2)*v_diff + axb(1)*u_diff
        temp = axbsq + alsq*(rcore*rcore)
        temp0 = SQRT(bsq + rcore*rcore)
        temp1 = (bsq-adb)/temp0
        temp2 = SQRT(asq + rcore*rcore)
        temp3 = (asq-adb)/temp2
        temp_diff0 = t_diff/temp
        temp_diff = -((temp1+temp3)*temp_diff0/temp)
        axbsq_diff = temp_diff
        DO ii1=1,3
          axb_diff(ii1) = 0.D0
        ENDDO
        axb_diff(3) = axb_diff(3) + t*w_diff + 2*axb(3)*axbsq_diff
        axb_diff(2) = axb_diff(2) + t*v_diff + 2*axb(2)*axbsq_diff
        axb_diff(1) = axb_diff(1) + t*u_diff + 2*axb(1)*axbsq_diff
        temp_diff1 = temp_diff0/temp0
        temp_diff3 = temp_diff0/temp2
        alsq_diff = rcore**2*temp_diff
        adb_diff = -temp_diff3 - temp_diff1 - 2.0*alsq_diff
        IF (asq + rcore**2 .EQ. 0.D0) THEN
          temp_diff4 = 0.D0
        ELSE
          temp_diff4 = -(temp3*temp_diff3/(2.0*temp2))
        END IF
        asq_diff = temp_diff3 + temp_diff4 + alsq_diff
        IF (bsq + rcore**2 .EQ. 0.D0) THEN
          temp_diff2 = 0.D0
        ELSE
          temp_diff2 = -(temp1*temp_diff1/(2.0*temp0))
        END IF
        rcore_diff = rcore_diff + 2*rcore*alsq*temp_diff + 2*rcore*
     +    temp_diff4 + 2*rcore*temp_diff2
        bsq_diff = temp_diff1 + temp_diff2 + alsq_diff
        a_diff(1) = a_diff(1) + b(1)*adb_diff + b(2)*axb_diff(3) - b(3)*
     +    axb_diff(2)
        b_diff(1) = b_diff(1) + a(1)*adb_diff + a(3)*axb_diff(2) - a(2)*
     +    axb_diff(3)
        a_diff(2) = a_diff(2) + b(2)*adb_diff + b(3)*axb_diff(1) - b(1)*
     +    axb_diff(3)
        b_diff(2) = b_diff(2) + a(2)*adb_diff + a(1)*axb_diff(3) - a(3)*
     +    axb_diff(1)
        a_diff(3) = a_diff(3) + b(3)*adb_diff + b(1)*axb_diff(2) - b(2)*
     +    axb_diff(1)
        b_diff(3) = b_diff(3) + a(3)*adb_diff + a(2)*axb_diff(1) - a(1)*
     +    axb_diff(2)
        axb_diff(3) = 0.D0
        axb_diff(2) = 0.D0
      ELSE
        bsq_diff = 0.D0
        asq_diff = 0.D0
      END IF
      IF (.NOT.bsq .EQ. 0.D0) bsq_diff = bsq_diff + bmag_diff/(2.0*SQRT(
     +    bsq))
      IF (.NOT.asq .EQ. 0.D0) asq_diff = asq_diff + amag_diff/(2.0*SQRT(
     +    asq))
      b_diff(1) = b_diff(1) + 2*b(1)*bsq_diff
      b_diff(2) = b_diff(2) + 2*b(2)*bsq_diff
      b_diff(3) = b_diff(3) + 2*b(3)*bsq_diff
      a_diff(1) = a_diff(1) + 2*a(1)*asq_diff
      a_diff(2) = a_diff(2) + 2*a(2)*asq_diff
      a_diff(3) = a_diff(3) + 2*a(3)*asq_diff
      z2_diff = z2_diff + b_diff(3)
      z_diff = z_diff - b_diff(3) - a_diff(3)
      b_diff(3) = 0.D0
      y2_diff = y2_diff + b_diff(2)
      y_diff = y_diff - b_diff(2) - a_diff(2)
      b_diff(2) = 0.D0
      temp_diff = b_diff(1)/beta
      x2_diff = x2_diff + temp_diff
      x_diff = x_diff - temp_diff
      beta_diff = beta_diff - (x2-x)*temp_diff/beta
      z1_diff = z1_diff + a_diff(3)
      a_diff(3) = 0.D0
      y1_diff = y1_diff + a_diff(2)
      a_diff(2) = 0.D0
      temp_diff = a_diff(1)/beta
      x1_diff = x1_diff + temp_diff
      x_diff = x_diff - temp_diff
      beta_diff = beta_diff - (x1-x)*temp_diff/beta
      END

