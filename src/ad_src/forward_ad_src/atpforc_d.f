C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) - 15 Jan 2021 14:26
C
C  Differentiation of tpforc in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: clff cyff cdff spanef
C   with respect to varying inputs: sref bref rv1 rv2 rc gam
C***********************************************************************
C    Module:  atpforc.f
C 
C    Copyright (C) 2002 Mark Drela, Harold Youngren
C 
C    This program is free software; you can redistribute it and/or modify
C    it under the terms of the GNU General Public License as published by
C    the Free Software Foundation; either version 2 of the License, or
C    (at your option) any later version.
C
C    This program is distributed in the hope that it will be useful,
C    but WITHOUT ANY WARRANTY; without even the implied warranty of
C    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
C    GNU General Public License for more details.
C
C    You should have received a copy of the GNU General Public License
C    along with this program; if not, write to the Free Software
C    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
C***********************************************************************
C
      SUBROUTINE TPFORC_D()
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
C
      REAL ny, nz
      REAL vy_u(numax), vz_u(numax), vy_d(ndmax), vz_d(ndmax), vy_g(
     +     ngmax), vz_g(ngmax)
      REAL p(3, 3), p_m(3, 3), p_a(3, 3), p_b(3, 3)
      REAL rt1(3, nsmax), rt2(3, nsmax), rtc(3, nsmax)
      REAL rt1_diff(3, nsmax), rt2_diff(3, nsmax), rtc_diff(3, nsmax)
      REAL gams(nsmax), gams_u(nsmax, numax), gams_d(nsmax, ndmax), 
     +     gams_g(nsmax, ngmax)
      REAL gams_diff(nsmax)
      REAL hpi
      REAL alfat
      REAL betat
      REAL yoff
      REAL zoff
      INTEGER n
      INTEGER jc
      INTEGER i1
      INTEGER i
      INTEGER ic
      INTEGER k
      REAL dxt
      REAL dyt
      REAL dyt_diff
      REAL dzt
      REAL dzt_diff
      REAL dst
      INTRINSIC SQRT
      REAL ycntr
      REAL ycntr_diff
      REAL zcntr
      REAL zcntr_diff
      REAL vy
      REAL vy_diff
      REAL vz
      REAL vz_diff
      INTEGER jv
      REAL dsyz
      REAL rcore
      INTRINSIC MAX
      REAL dy1
      REAL dy1_diff
      REAL dy2
      REAL dy2_diff
      REAL dz1
      REAL dz1_diff
      REAL dz2
      REAL dz2_diff
      REAL rsq1
      REAL rsq1_diff
      REAL rsq2
      REAL rsq2_diff
      REAL ar
      REAL ar_diff
      REAL spanef_cl
      REAL spanef_cy
      REAL spanef_cd
      REAL arg1
      REAL temp
      REAL temp0
      REAL(kind=8) temp1
      REAL(kind=avl_real) temp2
      REAL(kind=8) temp3
      INTEGER ii1
      INTEGER ii2
C
      hpi = 1.0/(2.0*pi)
C
C---- set Prandtl-Glauert transformation matrix
      alfat = 0.
      betat = 0.
      CALL PGMAT(amach, alfat, betat, p, p_m, p_a, p_b)
C
      yoff = 2.0*ysym
      zoff = 2.0*zsym
C
      clff = 0.
      cyff = 0.
      cdff = 0.
      DO n=1,numax
        clff_u(n) = 0.
        cyff_u(n) = 0.
        cdff_u(n) = 0.
      ENDDO
      DO n=1,ncontrol
        clff_d(n) = 0.
        cyff_d(n) = 0.
        cdff_d(n) = 0.
      ENDDO
      DO n=1,ndesign
        clff_g(n) = 0.
        cyff_g(n) = 0.
        cdff_g(n) = 0.
      ENDDO
      DO ii1=1,nsmax
        gams_diff(ii1) = 0.D0
      ENDDO
C
      DO jc=1,nstrip
        gams_diff(jc) = 0.D0
        gams(jc) = 0.
        DO n=1,numax
          gams_u(jc, n) = 0.
        ENDDO
        DO n=1,ncontrol
          gams_d(jc, n) = 0.
        ENDDO
        DO n=1,ndesign
          gams_g(jc, n) = 0.
        ENDDO
C
Ccc        ISURF = NSURFS(JC)
Ccc        IF(LFLOAD(ISURF)) THEN   !Bug 6/13/14 HHY 
C------- add circulation of this strip only if it contributes to total load
        i1 = ijfrst(jc)
        DO i=i1,i1+nvstrp(jc)-1
          gams_diff(jc) = gams_diff(jc) + gam_diff(i)
          gams(jc) = gams(jc) + gam(i)
          DO n=1,numax
            gams_u(jc, n) = gams_u(jc, n) + gam_u(i, n)
          ENDDO
          DO n=1,ncontrol
            gams_d(jc, n) = gams_d(jc, n) + gam_d(i, n)
          ENDDO
          DO n=1,ndesign
            gams_g(jc, n) = gams_g(jc, n) + gam_g(i, n)
          ENDDO
        ENDDO
      ENDDO
      DO ii1=1,nsmax
        DO ii2=1,3
          rt2_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nsmax
        DO ii2=1,3
          rtc_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nsmax
        DO ii2=1,3
          rt1_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
Ccc        ENDIF
C
C---- set x,y,z in wind axes (Y,Z are then in Trefftz plane)
      DO jc=1,nstrip
        ic = ijfrst(jc) + nvstrp(jc) - 1
        DO k=1,3
          rt1_diff(k, jc) = p(k, 1)*rv1_diff(1, ic) + p(k, 2)*rv1_diff(2
     +      , ic) + p(k, 3)*rv1_diff(3, ic)
          rt1(k, jc) = p(k, 1)*rv1(1, ic) + p(k, 2)*rv1(2, ic) + p(k, 3)
     +      *rv1(3, ic)
          rt2_diff(k, jc) = p(k, 1)*rv2_diff(1, ic) + p(k, 2)*rv2_diff(2
     +      , ic) + p(k, 3)*rv2_diff(3, ic)
          rt2(k, jc) = p(k, 1)*rv2(1, ic) + p(k, 2)*rv2(2, ic) + p(k, 3)
     +      *rv2(3, ic)
          rtc_diff(k, jc) = p(k, 1)*rc_diff(1, ic) + p(k, 2)*rc_diff(2, 
     +      ic) + p(k, 3)*rc_diff(3, ic)
          rtc(k, jc) = p(k, 1)*rc(1, ic) + p(k, 2)*rc(2, ic) + p(k, 3)*
     +      rc(3, ic)
        ENDDO
      ENDDO
      clff_diff = 0.D0
      cyff_diff = 0.D0
      cdff_diff = 0.D0
C
C...Find the normal velocity across each strip at the projected control
C   point location
      DO jc=1,nstrip
        dxt = rt2(1, jc) - rt1(1, jc)
        dyt_diff = rt2_diff(2, jc) - rt1_diff(2, jc)
        dyt = rt2(2, jc) - rt1(2, jc)
        dzt_diff = rt2_diff(3, jc) - rt1_diff(3, jc)
        dzt = rt2(3, jc) - rt1(3, jc)
        arg1 = dyt*dyt + dzt*dzt
        dst = SQRT(arg1)
C
        ny = -(dzt/dst)
        nz = dyt/dst
        ycntr_diff = rtc_diff(2, jc)
        ycntr = rtc(2, jc)
        zcntr_diff = rtc_diff(3, jc)
        zcntr = rtc(3, jc)
C
        vy = 0.
        vz = 0.
        DO n=1,numax
          vy_u(n) = 0.
          vz_u(n) = 0.
        ENDDO
        DO n=1,ncontrol
          vy_d(n) = 0.
          vz_d(n) = 0.
        ENDDO
        DO n=1,ndesign
          vy_g(n) = 0.
          vz_g(n) = 0.
        ENDDO
        vy_diff = 0.D0
        vz_diff = 0.D0
C
C...Sum velocity contributions from wake vortices
        DO jv=1,nstrip
          arg1 = (rt2(2, jv)-rt1(2, jv))**2 + (rt2(3, jv)-rt1(3, jv))**2
          dsyz = SQRT(arg1)
          IF (lscomp(nsurfs(jc)) .EQ. lscomp(nsurfs(jv))) THEN
Ccc        RCORE = 0.0001*DSYZ
            rcore = 0.
          ELSE IF (vrcore*chord(jv) .LT. 2.0*vrcore*dsyz) THEN
            rcore = 2.0*vrcore*dsyz
          ELSE
            rcore = vrcore*chord(jv)
          END IF
C
          rcore = 0.
C
          dy1_diff = ycntr_diff - rt1_diff(2, jv)
          dy1 = ycntr - rt1(2, jv)
          dy2_diff = ycntr_diff - rt2_diff(2, jv)
          dy2 = ycntr - rt2(2, jv)
          dz1_diff = zcntr_diff - rt1_diff(3, jv)
          dz1 = zcntr - rt1(3, jv)
          dz2_diff = zcntr_diff - rt2_diff(3, jv)
          dz2 = zcntr - rt2(3, jv)
          rsq1_diff = 2*dy1*dy1_diff + 2*dz1*dz1_diff
          rsq1 = dy1*dy1 + dz1*dz1 + rcore**2
          rsq2_diff = 2*dy2*dy2_diff + 2*dz2*dz2_diff
          rsq2 = dy2*dy2 + dz2*dz2 + rcore**2
          temp = dz1/rsq1 - dz2/rsq2
          vy_diff = vy_diff + hpi*(temp*gams_diff(jv)+gams(jv)*((
     +      dz1_diff-dz1*rsq1_diff/rsq1)/rsq1-(dz2_diff-dz2*rsq2_diff/
     +      rsq2)/rsq2))
          vy = vy + hpi*(gams(jv)*temp)
          temp = dy2/rsq2 - dy1/rsq1
          vz_diff = vz_diff + hpi*(temp*gams_diff(jv)+gams(jv)*((
     +      dy2_diff-dy2*rsq2_diff/rsq2)/rsq2-(dy1_diff-dy1*rsq1_diff/
     +      rsq1)/rsq1))
          vz = vz + hpi*(gams(jv)*temp)
          DO n=1,numax
            vy_u(n) = vy_u(n) + hpi*gams_u(jv, n)*(dz1/rsq1-dz2/rsq2)
            vz_u(n) = vz_u(n) + hpi*gams_u(jv, n)*(-(dy1/rsq1)+dy2/rsq2)
          ENDDO
          DO n=1,ncontrol
            vy_d(n) = vy_d(n) + hpi*gams_d(jv, n)*(dz1/rsq1-dz2/rsq2)
            vz_d(n) = vz_d(n) + hpi*gams_d(jv, n)*(-(dy1/rsq1)+dy2/rsq2)
          ENDDO
          DO n=1,ndesign
            vy_g(n) = vy_g(n) + hpi*gams_g(jv, n)*(dz1/rsq1-dz2/rsq2)
            vz_g(n) = vz_g(n) + hpi*gams_g(jv, n)*(-(dy1/rsq1)+dy2/rsq2)
          ENDDO
C
          IF (izsym .NE. 0) THEN
            dy1_diff = ycntr_diff - rt1_diff(2, jv)
            dy1 = ycntr - rt1(2, jv)
            dy2_diff = ycntr_diff - rt2_diff(2, jv)
            dy2 = ycntr - rt2(2, jv)
            dz1_diff = zcntr_diff + rt1_diff(3, jv)
            dz1 = zcntr - (zoff-rt1(3, jv))
            dz2_diff = zcntr_diff + rt2_diff(3, jv)
            dz2 = zcntr - (zoff-rt2(3, jv))
CCC         DZ1 = ZCNTR - (ZOFF-RT1(3,JV)+ALFA*RT1(1,JV))
CCC         DZ2 = ZCNTR - (ZOFF-RT2(3,JV)+ALFA*RT2(1,JV))
            rsq1_diff = 2*dy1*dy1_diff + 2*dz1*dz1_diff
            rsq1 = dy1*dy1 + dz1*dz1
            rsq2_diff = 2*dy2*dy2_diff + 2*dz2*dz2_diff
            rsq2 = dy2*dy2 + dz2*dz2
            temp = dz1/rsq1 - dz2/rsq2
            vy_diff = vy_diff - hpi*izsym*(temp*gams_diff(jv)+gams(jv)*(
     +        (dz1_diff-dz1*rsq1_diff/rsq1)/rsq1-(dz2_diff-dz2*rsq2_diff
     +        /rsq2)/rsq2))
            vy = vy - hpi*izsym*(gams(jv)*temp)
            temp = dy2/rsq2 - dy1/rsq1
            vz_diff = vz_diff - hpi*izsym*(temp*gams_diff(jv)+gams(jv)*(
     +        (dy2_diff-dy2*rsq2_diff/rsq2)/rsq2-(dy1_diff-dy1*rsq1_diff
     +        /rsq1)/rsq1))
            vz = vz - hpi*izsym*(gams(jv)*temp)
            DO n=1,numax
              vy_u(n) = vy_u(n) - hpi*gams_u(jv, n)*(dz1/rsq1-dz2/rsq2)*
     +          izsym
              vz_u(n) = vz_u(n) - hpi*gams_u(jv, n)*(-(dy1/rsq1)+dy2/
     +          rsq2)*izsym
            ENDDO
            DO n=1,ncontrol
              vy_d(n) = vy_d(n) - hpi*gams_d(jv, n)*(dz1/rsq1-dz2/rsq2)*
     +          izsym
              vz_d(n) = vz_d(n) - hpi*gams_d(jv, n)*(-(dy1/rsq1)+dy2/
     +          rsq2)*izsym
            ENDDO
            DO n=1,ndesign
              vy_g(n) = vy_g(n) - hpi*gams_g(jv, n)*(dz1/rsq1-dz2/rsq2)*
     +          izsym
              vz_g(n) = vz_g(n) - hpi*gams_g(jv, n)*(-(dy1/rsq1)+dy2/
     +          rsq2)*izsym
            ENDDO
          END IF
C
          IF (iysym .NE. 0) THEN
            dy1_diff = ycntr_diff + rt1_diff(2, jv)
            dy1 = ycntr - (yoff-rt1(2, jv))
            dy2_diff = ycntr_diff + rt2_diff(2, jv)
            dy2 = ycntr - (yoff-rt2(2, jv))
            dz1_diff = zcntr_diff - rt1_diff(3, jv)
            dz1 = zcntr - rt1(3, jv)
            dz2_diff = zcntr_diff - rt2_diff(3, jv)
            dz2 = zcntr - rt2(3, jv)
            rsq1_diff = 2*dy1*dy1_diff + 2*dz1*dz1_diff
            rsq1 = dy1*dy1 + dz1*dz1
            rsq2_diff = 2*dy2*dy2_diff + 2*dz2*dz2_diff
            rsq2 = dy2*dy2 + dz2*dz2
            temp = dz1/rsq1 - dz2/rsq2
            vy_diff = vy_diff - hpi*iysym*(temp*gams_diff(jv)+gams(jv)*(
     +        (dz1_diff-dz1*rsq1_diff/rsq1)/rsq1-(dz2_diff-dz2*rsq2_diff
     +        /rsq2)/rsq2))
            vy = vy - hpi*iysym*(gams(jv)*temp)
            temp = dy2/rsq2 - dy1/rsq1
            vz_diff = vz_diff - hpi*iysym*(temp*gams_diff(jv)+gams(jv)*(
     +        (dy2_diff-dy2*rsq2_diff/rsq2)/rsq2-(dy1_diff-dy1*rsq1_diff
     +        /rsq1)/rsq1))
            vz = vz - hpi*iysym*(gams(jv)*temp)
            DO n=1,numax
              vy_u(n) = vy_u(n) - hpi*gams_u(jv, n)*(dz1/rsq1-dz2/rsq2)*
     +          iysym
              vz_u(n) = vz_u(n) - hpi*gams_u(jv, n)*(-(dy1/rsq1)+dy2/
     +          rsq2)*iysym
            ENDDO
            DO n=1,ncontrol
              vy_d(n) = vy_d(n) - hpi*gams_d(jv, n)*(dz1/rsq1-dz2/rsq2)*
     +          iysym
              vz_d(n) = vz_d(n) - hpi*gams_d(jv, n)*(-(dy1/rsq1)+dy2/
     +          rsq2)*iysym
            ENDDO
            DO n=1,ndesign
              vy_g(n) = vy_g(n) - hpi*gams_g(jv, n)*(dz1/rsq1-dz2/rsq2)*
     +          iysym
              vz_g(n) = vz_g(n) - hpi*gams_g(jv, n)*(-(dy1/rsq1)+dy2/
     +          rsq2)*iysym
            ENDDO
C
            IF (izsym .NE. 0) THEN
              dy1_diff = ycntr_diff + rt1_diff(2, jv)
              dy1 = ycntr - (yoff-rt1(2, jv))
              dy2_diff = ycntr_diff + rt2_diff(2, jv)
              dy2 = ycntr - (yoff-rt2(2, jv))
              dz1_diff = zcntr_diff + rt1_diff(3, jv)
              dz1 = zcntr - (zoff-rt1(3, jv))
              dz2_diff = zcntr_diff + rt2_diff(3, jv)
              dz2 = zcntr - (zoff-rt2(3, jv))
CCC           DZ1 = ZCNTR - (ZOFF-RT1(3,JV)+ALFA*RT1(1,JV))
CCC           DZ2 = ZCNTR - (ZOFF-RT2(3,JV)+ALFA*RT2(1,JV))
              rsq1_diff = 2*dy1*dy1_diff + 2*dz1*dz1_diff
              rsq1 = dy1*dy1 + dz1*dz1
              rsq2_diff = 2*dy2*dy2_diff + 2*dz2*dz2_diff
              rsq2 = dy2*dy2 + dz2*dz2
              temp = hpi*iysym*izsym
              temp0 = dz1/rsq1 - dz2/rsq2
              vy_diff = vy_diff + temp*(temp0*gams_diff(jv)+gams(jv)*((
     +          dz1_diff-dz1*rsq1_diff/rsq1)/rsq1-(dz2_diff-dz2*
     +          rsq2_diff/rsq2)/rsq2))
              vy = vy + temp*(gams(jv)*temp0)
              temp0 = hpi*iysym*izsym
              temp = dy2/rsq2 - dy1/rsq1
              vz_diff = vz_diff + temp0*(temp*gams_diff(jv)+gams(jv)*((
     +          dy2_diff-dy2*rsq2_diff/rsq2)/rsq2-(dy1_diff-dy1*
     +          rsq1_diff/rsq1)/rsq1))
              vz = vz + temp0*(gams(jv)*temp)
              DO n=1,numax
                vy_u(n) = vy_u(n) - hpi*gams_u(jv, n)*(dz1/rsq1-dz2/rsq2
     +            )*iysym*izsym
                vz_u(n) = vz_u(n) - hpi*gams_u(jv, n)*(-(dy1/rsq1)+dy2/
     +            rsq2)*iysym*izsym
              ENDDO
              DO n=1,ncontrol
                vy_d(n) = vy_d(n) - hpi*gams_d(jv, n)*(dz1/rsq1-dz2/rsq2
     +            )*iysym*izsym
                vz_d(n) = vz_d(n) - hpi*gams_d(jv, n)*(-(dy1/rsq1)+dy2/
     +            rsq2)*iysym*izsym
              ENDDO
              DO n=1,ndesign
                vy_g(n) = vy_g(n) - hpi*gams_g(jv, n)*(dz1/rsq1-dz2/rsq2
     +            )*iysym*izsym
                vz_g(n) = vz_g(n) - hpi*gams_g(jv, n)*(-(dy1/rsq1)+dy2/
     +            rsq2)*iysym*izsym
              ENDDO
            END IF
          END IF
        ENDDO
C
C
C...Trefftz-plane drag is kinetic energy in crossflow
        dwwake(jc) = -(ny*vy+nz*vz)
C
        temp1 = dyt/sref
        clff_diff = clff_diff + 2.0*(temp1*gams_diff(jc)+gams(jc)*(
     +    dyt_diff-temp1*sref_diff)/sref)
        clff = clff + 2.0*(gams(jc)*temp1)
        temp1 = dzt/sref
        cyff_diff = cyff_diff - 2.0*(temp1*gams_diff(jc)+gams(jc)*(
     +    dzt_diff-temp1*sref_diff)/sref)
        cyff = cyff - 2.0*(gams(jc)*temp1)
        temp0 = dzt*vy - dyt*vz
        temp1 = gams(jc)/sref
        cdff_diff = cdff_diff + temp0*(gams_diff(jc)-temp1*sref_diff)/
     +    sref + temp1*(vy*dzt_diff+dzt*vy_diff-vz*dyt_diff-dyt*vz_diff)
        cdff = cdff + temp1*temp0
        DO n=1,numax
          clff_u(n) = clff_u(n) + 2.0*gams_u(jc, n)*dyt/sref
          cyff_u(n) = cyff_u(n) - 2.0*gams_u(jc, n)*dzt/sref
          cdff_u(n) = cdff_u(n) + (gams_u(jc, n)*(dzt*vy-dyt*vz)+gams(jc
     +      )*(dzt*vy_u(n)-dyt*vz_u(n)))/sref
        ENDDO
        DO n=1,ncontrol
          clff_d(n) = clff_d(n) + 2.0*gams_d(jc, n)*dyt/sref
          cyff_d(n) = cyff_d(n) - 2.0*gams_d(jc, n)*dzt/sref
          cdff_d(n) = cdff_d(n) + (gams_d(jc, n)*(dzt*vy-dyt*vz)+gams(jc
     +      )*(dzt*vy_d(n)-dyt*vz_d(n)))/sref
        ENDDO
        DO n=1,ndesign
          clff_g(n) = clff_g(n) + 2.0*gams_g(jc, n)*dyt/sref
          cyff_g(n) = cyff_g(n) - 2.0*gams_g(jc, n)*dzt/sref
          cdff_g(n) = cdff_g(n) + (gams_g(jc, n)*(dzt*vy-dyt*vz)+gams(jc
     +      )*(dzt*vy_g(n)-dyt*vz_g(n)))/sref
        ENDDO
      ENDDO
C
C---- Double the X,Z forces, zero Y force for a Y symmetric case
      IF (iysym .EQ. 1) THEN
        clff_diff = 2.0*clff_diff
        clff = 2.0*clff
        cyff = 0.0
        cdff_diff = 2.0*cdff_diff
        cdff = 2.0*cdff
        DO n=1,numax
          clff_u(n) = 2.0*clff_u(n)
          cyff_u(n) = 0.0
          cdff_u(n) = 2.0*cdff_u(n)
        ENDDO
        DO n=1,ncontrol
          clff_d(n) = 2.0*clff_d(n)
          cyff_d(n) = 0.0
          cdff_d(n) = 2.0*cdff_d(n)
        ENDDO
        DO n=1,ndesign
          clff_g(n) = 2.0*clff_g(n)
          cyff_g(n) = 0.0
          cdff_g(n) = 2.0*cdff_g(n)
        ENDDO
        cyff_diff = 0.D0
      END IF
C
C---- aspect ratio
      temp2 = bref*bref/sref
      ar_diff = (2*bref*bref_diff-temp2*sref_diff)/sref
      ar = temp2
C
C---- span efficiency
      IF (cdff .EQ. 0.0) THEN
        spanef = 0.
        spanef_a = 0.
        DO n=1,numax
          spanef_u(n) = 0.
        ENDDO
        DO n=1,ncontrol
          spanef_d(n) = 0.
        ENDDO
        DO n=1,ndesign
          spanef_g(n) = 0.
        ENDDO
        spanef_diff = 0.D0
      ELSE
C
        temp1 = pi*ar*cdff
        temp3 = (clff*clff+cyff*cyff)/temp1
        spanef_diff = (2*clff*clff_diff+2*cyff*cyff_diff-temp3*(cdff*pi*
     +    ar_diff+pi*ar*cdff_diff))/temp1
        spanef = temp3
        spanef_cl = 2.0*clff/(pi*ar*cdff)
        spanef_cy = 2.0*cyff/(pi*ar*cdff)
        spanef_cd = -(spanef/cdff)
C
        spanef_a = 0.
        DO n=1,numax
          spanef_u(n) = spanef_cl*clff_u(n) + spanef_cy*cyff_u(n) + 
     +      spanef_cd*cdff_u(n)
        ENDDO
        DO n=1,ncontrol
          spanef_d(n) = spanef_cl*clff_d(n) + spanef_cy*cyff_d(n) + 
     +      spanef_cd*cdff_d(n)
        ENDDO
        DO n=1,ndesign
          spanef_g(n) = spanef_cl*clff_g(n) + spanef_cy*cyff_g(n) + 
     +      spanef_cd*cdff_g(n)
        ENDDO
      END IF
C
      RETURN
      END

