C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) - 15 Jan 2021 14:26
C
C  Differentiation of update_surfaces in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: rle chord rle1 chord1 rle2
C                chord2 wstrip ess ensy ensz xsref ysref zsref
C                rv1 rv2 rv rc rs dxv chordv enc env enc_d
C   with respect to varying inputs: xyzscal xyztran addinc xyzles
C                chords aincs xasec sasec claf
C   RW status of diff variables: xyzscal:in xyztran:in addinc:in
C                xyzles:in chords:in aincs:in xasec:in sasec:in
C                claf:in rle:out chord:out rle1:out chord1:out
C                rle2:out chord2:out wstrip:out ess:out ensy:out
C                ensz:out xsref:out ysref:out zsref:out rv1:out
C                rv2:out rv:out rc:out rs:out dxv:out chordv:out
C                enc:out env:out enc_d:out
C MAKESURF
      SUBROUTINE UPDATE_SURFACES_D()
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
      INTEGER isurf
      INTEGER ii3
      INTEGER ii2
      INTEGER ii1
      nstrip = 0
      nvor = 0
      DO ii1=1,nsmax
        DO ii2=1,3
          rle_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nsmax
        chord_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        DO ii2=1,3
          rle1_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nsmax
        chord1_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        DO ii2=1,3
          rle2_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nsmax
        chord2_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        wstrip_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        ainc_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,ngmax
        DO ii2=1,nsmax
          ainc_g_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvmax
        DO ii2=1,3
          rv1_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvmax
        DO ii2=1,3
          rv2_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvmax
        DO ii2=1,3
          rv_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvmax
        DO ii2=1,3
          rc_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvmax
        DO ii2=1,3
          rs_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvmax
        dxv_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nvmax
        chordv_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nvmax
        slopev_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nvmax
        slopec_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nvmax
          dcontrol_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nsmax
          DO ii3=1,3
            vhinge_diff(ii3, ii2, ii1) = 0.D0
          ENDDO
        ENDDO
      ENDDO
      DO 100 isurf=1,nsurf
        IF (lverbose) WRITE(*, *) 'Updating surface ', isurf
        IF (isurf .NE. 1) THEN
          IF (ldupl(isurf-1)) THEN
            GOTO 100
          ELSE
C this surface has already been created
C it was probably duplicated from the previous one
            CALL MAKESURF_D(isurf)
          END IF
        ELSE
          CALL MAKESURF_D(isurf)
        END IF
        IF (ldupl(isurf)) CALL SDUPL_D(isurf, ydupl(isurf), 'ydup')
 100  CONTINUE
      CALL ENCALC_D()
      laic = .false.
      lsrd = .false.
      lvel = .false.
      lsol = .false.
      lsen = .false.
      END

C  Differentiation of makesurf in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: rle chord rle1 chord1 rle2
C                chord2 wstrip ainc ainc_g rv1 rv2 rv rc rs dxv
C                chordv slopev slopec dcontrol vhinge
C   with respect to varying inputs: xyzscal xyztran addinc xyzles
C                chords aincs xasec sasec claf rle chord rle1 chord1
C                rle2 chord2 wstrip ainc ainc_g rv1 rv2 rv rc rs
C                dxv chordv slopev slopec dcontrol vhinge
C***********************************************************************
C    Module:  amake.f
C 
C    Copyright (C) 2002 Mark Drela, Harold Youngren
C 
C    This program is free software; you can redistribute it and/or modify
C    it under the terms of the GNU General Public License as published by
C    the Free Software Foundation; either version 2 of the License, or
C    (at your option) any later version.
C
C    This program is distributed in the hope that it will be useful,
C    but WITHOUT ANY WARRANTY; without even the implied warranty of
C    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
C    GNU General Public License for more details.
C
C    You should have received a copy of the GNU General Public License
C    along with this program; if not, write to the Free Software
C    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
C***********************************************************************
C
      SUBROUTINE MAKESURF_D(isurf)
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
C
C
      REAL xyzlel(3), xyzler(3)
      REAL xyzlel_diff(3), xyzler_diff(3)
      INTEGER kcmax
      INTEGER ksmax
      PARAMETER (kcmax=50, ksmax=500)
      REAL xpt0(kcmax), xcp0(kcmax), xvr0(kcmax), xsr0(kcmax), xpt1(
     +     kcmax), xcp1(kcmax), xvr1(kcmax), xsr1(kcmax), xpt2(kcmax), 
     +     xcp2(kcmax), xvr2(kcmax), xsr2(kcmax)
      REAL xpt(kcmax), xcp(kcmax), xvr(kcmax), xsr(kcmax), ypt(ksmax), 
     +     ycp(ksmax)
      REAL xcp_diff(kcmax), xvr_diff(kcmax), ypt_diff(ksmax), ycp_diff(
     +     ksmax)
      REAL yzlen(ksmax)
      REAL yzlen_diff(ksmax)
      INTEGER iptloc(ksmax)
      INTEGER kpmax
      PARAMETER (kpmax=2*kcmax+2*ksmax)
      REAL fspace(kpmax)
C
      REAL chsinl_g(ngmax), chcosl_g(ngmax), chsinr_g(ngmax), chcosr_g(
     +     ngmax)
      REAL chsinl_g_diff(ngmax), chcosl_g_diff(ngmax), chsinr_g_diff(
     +     ngmax), chcosr_g_diff(ngmax)
      INTEGER isconl(ndmax), isconr(ndmax)
      REAL xled(ndmax), xted(ndmax), gainda(ndmax)
      REAL xled_diff(ndmax), xted_diff(ndmax), gainda_diff(ndmax)
      INTEGER idx_vor, idx_strip
      INTEGER isec
      REAL dy
      REAL dy_diff
      REAL dz
      REAL dz_diff
      INTRINSIC SQRT
      REAL dyzlen
      REAL dyzlen_diff
      INTEGER nvint
      INTEGER nspace
      INTEGER n
      INTEGER ivs
      INTEGER npt
      REAL yptloc
      INTEGER ipt
      REAL yptdel
      INTRINSIC ABS
      INTEGER ipt1
      INTEGER ipt2
      REAL ypt1
      REAL ypt1_diff
      REAL yscale
      REAL yscale_diff
      INTEGER ii
      REAL width
      REAL width_diff
      REAL chordl
      REAL chordl_diff
      REAL chordr
      REAL chordr_diff
      REAL clafl
      REAL clafl_diff
      REAL clafr
      REAL clafr_diff
      REAL aincl
      REAL aincl_diff
      REAL aincr
      REAL aincr_diff
      REAL chsinl
      REAL chsinl_diff
      INTRINSIC SIN
      REAL chsinr
      REAL chsinr_diff
      REAL chcosl
      REAL chcosl_diff
      INTRINSIC COS
      REAL chcosr
      REAL chcosr_diff
      INTEGER iscon
      INTEGER isdes
      INTEGER iptl
      INTEGER iptr
      INTEGER nspan
      INTEGER ispan
      REAL f1
      REAL f1_diff
      REAL f2
      REAL f2_diff
      REAL fc
      REAL fc_diff
      REAL chsin
      REAL chsin_diff
      REAL chcos
      REAL chcos_diff
      INTRINSIC ATAN2
      REAL chsin_g
      REAL chsin_g_diff
      REAL chcos_g
      REAL chcos_g_diff
      INTEGER icl
      INTEGER icr
      REAL xhd
      REAL xhd_diff
      REAL vhx
      REAL vhx_diff
      REAL vhy
      REAL vhy_diff
      REAL vhz
      REAL vhz_diff
      REAL vsq
      REAL vsq_diff
      REAL vmod
      REAL vmod_diff
      INTEGER l
      INTEGER nsl
      INTEGER nsr
      REAL chordc
      REAL chordc_diff
      REAL clafc
      REAL clafc_diff
      INTEGER ivc
      REAL slopel
      REAL slopel_diff
      REAL dsdx
      REAL sloper
      REAL sloper_diff
      REAL dxoc
      REAL fracle
      REAL fracle_diff
      REAL fracte
      REAL fracte_diff
      INTRINSIC MAX
      INTRINSIC MIN
      REAL zl
      REAL zu
      REAL sum
      REAL wtot
      INTEGER jj
      INTEGER j
      REAL astrp
      INTEGER nst
      EXTERNAL STRIP
      REAL y1
      REAL y1_diff
      REAL y2
      REAL y2_diff
      REAL abs0
      REAL abs0_diff
      REAL(kind=avl_real) abs1
      REAL(kind=avl_real) abs1_diff
      REAL(kind=avl_real) abs2
      REAL(kind=avl_real) abs2_diff
      REAL arg1
      REAL arg1_diff
      REAL result1
      REAL result1_diff
      REAL temp
      INTEGER ii1
      REAL temp0
      INTEGER isurf
C
C
      IF (nsec(isurf) .LT. 2) THEN
        WRITE(*, *) '*** Need at least 2 sections per surface.'
        STOP
      ELSE
C
C
        IF (nvc(isurf) .GT. kcmax) THEN
          WRITE(*, *) '* MAKESURF: Array overflow.  Increase KCMAX to', 
     +          nvc(isurf)
          nvc(isurf) = kcmax
        END IF
C
        IF (nvs(isurf) .GT. ksmax) THEN
          WRITE(*, *) '* MAKESURF: Array overflow.  Increase KSMAX to', 
     +          nvs(isurf)
          nvs(isurf) = ksmax
        END IF
C
C--- Image flag set to indicate section definition direction
C    IMAGS= 1  defines edge 1 located at surface root edge 
C    IMAGS=-1  defines edge 2 located at surface root edge (reflected surfaces)
        imags(isurf) = 1
C write(*,*) 'IFRST(ISURF)', IFRST(ISURF)
C IFRST(ISURF) = NVOR   + 1 
C write(*,*) 'IFRST(ISURF) 2', IFRST(ISURF)
C JFRST(ISURF) = NSTRIP + 1
        IF (isurf .EQ. 1) THEN
          ifrst(isurf) = 1
        ELSE
          ifrst(isurf) = ifrst(isurf-1) + nk(isurf-1)*nj(isurf-1)
        END IF
        IF (isurf .EQ. 1) THEN
          jfrst(isurf) = 1
        ELSE
          jfrst(isurf) = jfrst(isurf-1) + nj(isurf-1)
        END IF
        nk(isurf) = nvc(isurf)
        idx_strip = jfrst(isurf)
C
C-----------------------------------------------------------------
C---- Arc length positions of sections in wing trace in y-z plane
        yzlen(1) = 0.
        DO ii1=1,ksmax
          yzlen_diff(ii1) = 0.D0
        ENDDO
        DO isec=2,nsec(isurf)
          dy_diff = xyzles_diff(2, isec, isurf) - xyzles_diff(2, isec-1
     +      , isurf)
          dy = xyzles(2, isec, isurf) - xyzles(2, isec-1, isurf)
          dz_diff = xyzles_diff(3, isec, isurf) - xyzles_diff(3, isec-1
     +      , isurf)
          dz = xyzles(3, isec, isurf) - xyzles(3, isec-1, isurf)
          arg1_diff = 2*dy*dy_diff + 2*dz*dz_diff
          arg1 = dy*dy + dz*dz
          temp = SQRT(arg1)
          IF (arg1 .EQ. 0.D0) THEN
            result1_diff = 0.D0
          ELSE
            result1_diff = arg1_diff/(2.0*temp)
          END IF
          result1 = temp
          yzlen_diff(isec) = yzlen_diff(isec-1) + result1_diff
          yzlen(isec) = yzlen(isec-1) + result1
        ENDDO
C we can not rely on the original condition becuase NVS(ISURF) is filled 
C and we may want to rebuild the surface later
C IF(NVS(ISURF).EQ.0) THEN
C
        IF (lsurfspacing(isurf) .EQV. .false.) THEN
C----- set spanwise spacing using spacing parameters for each section interval
          DO isec=1,nsec(isurf)-1
            nvs(isurf) = nvs(isurf) + nspans(isec, isurf)
          ENDDO
          IF (nvs(isurf) .GT. ksmax) THEN
            WRITE(*, *) 
     +            '*** MAKESURF: Array overflow. Increase KSMAX to', nvs
     +            (isurf)
            STOP
          ELSE
C
            nvs(isurf) = 0
            DO ii1=1,ksmax
              ypt_diff(ii1) = 0.D0
            ENDDO
            ypt_diff(1) = yzlen_diff(1)
            ypt(1) = yzlen(1)
            iptloc(1) = 1
            DO ii1=1,ksmax
              ycp_diff(ii1) = 0.D0
            ENDDO
C
            DO isec=1,nsec(isurf)-1
              dyzlen_diff = yzlen_diff(isec+1) - yzlen_diff(isec)
              dyzlen = yzlen(isec+1) - yzlen(isec)
C
              nvint = nspans(isec, isurf)
C
C------- set spanwise spacing array
              nspace = 2*nvint + 1
              IF (nspace .GT. kpmax) THEN
                GOTO 100
              ELSE
                CALL SPACER(nspace, sspaces(isec, isurf), fspace)
C
                DO n=1,nvint
                  ivs = nvs(isurf) + n
                  ycp_diff(ivs) = ypt_diff(nvs(isurf)+1) + fspace(2*n)*
     +              dyzlen_diff
                  ycp(ivs) = ypt(nvs(isurf)+1) + dyzlen*fspace(2*n)
                  ypt_diff(ivs+1) = ypt_diff(nvs(isurf)+1) + fspace(2*n+
     +              1)*dyzlen_diff
                  ypt(ivs+1) = ypt(nvs(isurf)+1) + dyzlen*fspace(2*n+1)
                ENDDO
                iptloc(isec+1) = nvs(isurf) + nvint + 1
C
                nvs(isurf) = nvs(isurf) + nvint
              END IF
            ENDDO
            GOTO 130
 100        WRITE(*, *) 
     +            '*** MAKESURF: Array overflow. Increase KPMAX to', 
     +            nspace
            STOP
          END IF
        ELSE
C
C
C----- Otherwise, set spanwise spacing using the SURFACE spanwise
C      parameters NVS, SSPACE
C
C      This spanwise spacing is modified (fudged) to align vortex edges
C      with SECTIONs as defined.  This allows CONTROLs to be defined
C      without bridging vortex strips
C
          nspace = 2*nvs(isurf) + 1
          IF (nspace .GT. kpmax) THEN
            WRITE(*, *) 
     +            '*** MAKESURF: Array overflow. Increase KPMAX to', 
     +            nspace
            STOP
          ELSE
            CALL SPACER(nspace, sspace(isurf), fspace)
C
            DO ii1=1,ksmax
              ypt_diff(ii1) = 0.D0
            ENDDO
            ypt_diff(1) = yzlen_diff(1)
            ypt(1) = yzlen(1)
            DO ii1=1,ksmax
              ycp_diff(ii1) = 0.D0
            ENDDO
            DO ivs=1,nvs(isurf)
              ycp_diff(ivs) = yzlen_diff(1) + fspace(2*ivs)*(yzlen_diff(
     +          nsec(isurf))-yzlen_diff(1))
              ycp(ivs) = yzlen(1) + (yzlen(nsec(isurf))-yzlen(1))*fspace
     +          (2*ivs)
              ypt_diff(ivs+1) = yzlen_diff(1) + fspace(2*ivs+1)*(
     +          yzlen_diff(nsec(isurf))-yzlen_diff(1))
              ypt(ivs+1) = yzlen(1) + (yzlen(nsec(isurf))-yzlen(1))*
     +          fspace(2*ivs+1)
            ENDDO
C
            npt = nvs(isurf) + 1
C
C----- find node nearest each section
            DO isec=2,nsec(isurf)-1
              yptloc = 1.0e9
              iptloc(isec) = 1
              DO ipt=1,npt
                IF (yzlen(isec) - ypt(ipt) .GE. 0.) THEN
                  yptdel = yzlen(isec) - ypt(ipt)
                ELSE
                  yptdel = -(yzlen(isec)-ypt(ipt))
                END IF
                IF (yptdel .LT. yptloc) THEN
                  yptloc = yptdel
                  iptloc(isec) = ipt
                END IF
              ENDDO
            ENDDO
            iptloc(1) = 1
            iptloc(nsec(isurf)) = npt
C
C----- fudge spacing array to make nodes match up exactly with interior sections
            DO isec=2,nsec(isurf)-1
              ipt1 = iptloc(isec-1)
              ipt2 = iptloc(isec)
              IF (ipt1 .EQ. ipt2) THEN
                GOTO 110
              ELSE
C
C----- fudge spacing to this section so that nodes match up exactly with section
                ypt1_diff = ypt_diff(ipt1)
                ypt1 = ypt(ipt1)
                temp = (yzlen(isec)-yzlen(isec-1))/(ypt(ipt2)-ypt(ipt1))
                yscale_diff = (yzlen_diff(isec)-yzlen_diff(isec-1)-temp*
     +            (ypt_diff(ipt2)-ypt_diff(ipt1)))/(ypt(ipt2)-ypt(ipt1))
                yscale = temp
                DO ipt=ipt1,ipt2-1
                  ypt_diff(ipt) = yzlen_diff(isec-1) + (ypt(ipt)-ypt1)*
     +              yscale_diff + yscale*(ypt_diff(ipt)-ypt1_diff)
                  ypt(ipt) = yzlen(isec-1) + yscale*(ypt(ipt)-ypt1)
                ENDDO
                DO ivs=ipt1,ipt2-1
                  ycp_diff(ivs) = yzlen_diff(isec-1) + (ycp(ivs)-ypt1)*
     +              yscale_diff + yscale*(ycp_diff(ivs)-ypt1_diff)
                  ycp(ivs) = yzlen(isec-1) + yscale*(ycp(ivs)-ypt1)
                ENDDO
C
C----- check for unique spacing node for next section, if not we need more nodes
                ipt1 = iptloc(isec)
                ipt2 = iptloc(isec+1)
                IF (ipt1 .EQ. ipt2) THEN
                  GOTO 120
                ELSE
C
C----- fudge spacing to this section so that nodes match up exactly with section
                  ypt1_diff = ypt_diff(ipt1)
                  ypt1 = ypt(ipt1)
                  temp = (ypt(ipt2)-yzlen(isec))/(ypt(ipt2)-ypt(ipt1))
                  yscale_diff = (ypt_diff(ipt2)-yzlen_diff(isec)-temp*(
     +              ypt_diff(ipt2)-ypt_diff(ipt1)))/(ypt(ipt2)-ypt(ipt1)
     +              )
                  yscale = temp
                  DO ipt=ipt1,ipt2-1
                    ypt_diff(ipt) = yzlen_diff(isec) + (ypt(ipt)-ypt1)*
     +                yscale_diff + yscale*(ypt_diff(ipt)-ypt1_diff)
                    ypt(ipt) = yzlen(isec) + yscale*(ypt(ipt)-ypt1)
                  ENDDO
                  DO ivs=ipt1,ipt2-1
                    ycp_diff(ivs) = yzlen_diff(isec) + (ycp(ivs)-ypt1)*
     +                yscale_diff + yscale*(ycp_diff(ivs)-ypt1_diff)
                    ycp(ivs) = yzlen(isec) + yscale*(ycp(ivs)-ypt1)
                  ENDDO
                END IF
              END IF
            ENDDO
            GOTO 130
 110        CALL STRIP(stitle(isurf), nst)
            WRITE(*, 7000) isec, stitle(isurf)(1:nst)
            STOP
 120        CALL STRIP(stitle(isurf), nst)
            WRITE(*, 7000) isec, stitle(isurf)(1:nst)
            STOP
          END IF
        END IF
C
Cc#ifdef USE_CPOML
C...  store section counters
 130    IF (isurf .EQ. 1) THEN
          icntfrst(isurf) = 1
        ELSE
          icntfrst(isurf) = icntfrst(isurf-1) + ncntsec(isurf-1)
        END IF
        ncntsec(isurf) = nsec(isurf)
        DO isec=1,nsec(isurf)
          ii = icntfrst(isurf) + (isec-1)
          icntsec(ii) = iptloc(isec)
        ENDDO
Cc#endif
C
C
C====================================================
C---- define strips between input sections
C
        nj(isurf) = 0
C
        IF (ncontrol .GT. ndmax) THEN
          WRITE(*, *) 
     +          '*** Too many control variables.  Increase NDMAX to', 
     +          ncontrol
          STOP
        ELSE IF (ndesign .GT. ngmax) THEN
C
          WRITE(*, *) 
     +          '*** Too many design variables.  Increase NGMAX to', 
     +          ndesign
          STOP
        ELSE
          DO ii1=1,3
            xyzler_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,kcmax
            xcp_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ngmax
            chcosl_g_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ngmax
            chsinr_g_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ndmax
            xted_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ndmax
            xled_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ngmax
            chsinl_g_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ndmax
            gainda_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,ngmax
            chcosr_g_diff(ii1) = 0.D0
          ENDDO
          DO ii1=1,3
            xyzlel_diff(ii1) = 0.D0
          ENDDO
C
C---- go over section intervals
          DO isec=1,nsec(isurf)-1
            xyzlel_diff(1) = xyzles(1, isec, isurf)*xyzscal_diff(1, 
     +        isurf) + xyzscal(1, isurf)*xyzles_diff(1, isec, isurf) + 
     +        xyztran_diff(1, isurf)
            xyzlel(1) = xyzscal(1, isurf)*xyzles(1, isec, isurf) + 
     +        xyztran(1, isurf)
            xyzlel_diff(2) = xyzles(2, isec, isurf)*xyzscal_diff(2, 
     +        isurf) + xyzscal(2, isurf)*xyzles_diff(2, isec, isurf) + 
     +        xyztran_diff(2, isurf)
            xyzlel(2) = xyzscal(2, isurf)*xyzles(2, isec, isurf) + 
     +        xyztran(2, isurf)
            xyzlel_diff(3) = xyzles(3, isec, isurf)*xyzscal_diff(3, 
     +        isurf) + xyzscal(3, isurf)*xyzles_diff(3, isec, isurf) + 
     +        xyztran_diff(3, isurf)
            xyzlel(3) = xyzscal(3, isurf)*xyzles(3, isec, isurf) + 
     +        xyztran(3, isurf)
            xyzler_diff(1) = xyzles(1, isec+1, isurf)*xyzscal_diff(1, 
     +        isurf) + xyzscal(1, isurf)*xyzles_diff(1, isec+1, isurf) +
     +        xyztran_diff(1, isurf)
            xyzler(1) = xyzscal(1, isurf)*xyzles(1, isec+1, isurf) + 
     +        xyztran(1, isurf)
            xyzler_diff(2) = xyzles(2, isec+1, isurf)*xyzscal_diff(2, 
     +        isurf) + xyzscal(2, isurf)*xyzles_diff(2, isec+1, isurf) +
     +        xyztran_diff(2, isurf)
            xyzler(2) = xyzscal(2, isurf)*xyzles(2, isec+1, isurf) + 
     +        xyztran(2, isurf)
            xyzler_diff(3) = xyzles(3, isec+1, isurf)*xyzscal_diff(3, 
     +        isurf) + xyzscal(3, isurf)*xyzles_diff(3, isec+1, isurf) +
     +        xyztran_diff(3, isurf)
            xyzler(3) = xyzscal(3, isurf)*xyzles(3, isec+1, isurf) + 
     +        xyztran(3, isurf)
C
            arg1_diff = 2*(xyzler(2)-xyzlel(2))*(xyzler_diff(2)-
     +        xyzlel_diff(2)) + 2*(xyzler(3)-xyzlel(3))*(xyzler_diff(3)-
     +        xyzlel_diff(3))
            arg1 = (xyzler(2)-xyzlel(2))**2 + (xyzler(3)-xyzlel(3))**2
            temp = SQRT(arg1)
            IF (arg1 .EQ. 0.D0) THEN
              width_diff = 0.D0
            ELSE
              width_diff = arg1_diff/(2.0*temp)
            END IF
            width = temp
C
            chordl_diff = chords(isec, isurf)*xyzscal_diff(1, isurf) + 
     +        xyzscal(1, isurf)*chords_diff(isec, isurf)
            chordl = xyzscal(1, isurf)*chords(isec, isurf)
            chordr_diff = chords(isec+1, isurf)*xyzscal_diff(1, isurf) +
     +        xyzscal(1, isurf)*chords_diff(isec+1, isurf)
            chordr = xyzscal(1, isurf)*chords(isec+1, isurf)
C
            clafl_diff = claf_diff(isec, isurf)
            clafl = claf(isec, isurf)
            clafr_diff = claf_diff(isec+1, isurf)
            clafr = claf(isec+1, isurf)
C
C------ removed CLAF influence on zero-lift angle  (MD  21 Mar 08)
            aincl_diff = dtr*aincs_diff(isec, isurf) + dtr*addinc_diff(
     +        isurf)
            aincl = aincs(isec, isurf)*dtr + addinc(isurf)*dtr
            aincr_diff = dtr*aincs_diff(isec+1, isurf) + dtr*addinc_diff
     +        (isurf)
            aincr = aincs(isec+1, isurf)*dtr + addinc(isurf)*dtr
Cc      AINCL = AINCS(ISEC)   + ADDINC(ISURF) - 4.0*DTR*(CLAFL-1.0)
Cc      AINCR = AINCS(ISEC+1) + ADDINC(ISURF) - 4.0*DTR*(CLAFR-1.0)
C
            temp = SIN(aincl)
            chsinl_diff = temp*chordl_diff + chordl*COS(aincl)*
     +        aincl_diff
            chsinl = chordl*temp
            temp = SIN(aincr)
            chsinr_diff = temp*chordr_diff + chordr*COS(aincr)*
     +        aincr_diff
            chsinr = chordr*temp
            temp = COS(aincl)
            chcosl_diff = temp*chordl_diff - chordl*SIN(aincl)*
     +        aincl_diff
            chcosl = chordl*temp
            temp = COS(aincr)
            chcosr_diff = temp*chordr_diff - chordr*SIN(aincr)*
     +        aincr_diff
            chcosr = chordr*temp
C
C------ set control-declaration lines for each control variable
            DO n=1,ncontrol
              isconl(n) = 0
              isconr(n) = 0
              DO iscon=1,nscon(isec, isurf)
                IF (icontd(iscon, isec, isurf) .EQ. n) isconl(n) = iscon
              ENDDO
              DO iscon=1,nscon(isec+1, isurf)
                IF (icontd(iscon, isec+1, isurf) .EQ. n) isconr(n) = 
     +              iscon
              ENDDO
            ENDDO
C
C------ set design-variable sensitivities of CHSIN and CHCOS
            DO n=1,ndesign
              chsinl_g_diff(n) = 0.D0
              chsinl_g(n) = 0.
              chsinr_g_diff(n) = 0.D0
              chsinr_g(n) = 0.
              chcosl_g_diff(n) = 0.D0
              chcosl_g(n) = 0.
              chcosr_g_diff(n) = 0.D0
              chcosr_g(n) = 0.
C
              DO isdes=1,nsdes(isec, isurf)
                IF (idestd(isdes, isec, isurf) .EQ. n) THEN
                  chsinl_g_diff(n) = gaing(isdes, isec, isurf)*dtr*
     +              chcosl_diff
                  chsinl_g(n) = chcosl*gaing(isdes, isec, isurf)*dtr
                  chcosl_g_diff(n) = -(gaing(isdes, isec, isurf)*dtr*
     +              chsinl_diff)
                  chcosl_g(n) = -(chsinl*gaing(isdes, isec, isurf)*dtr)
                END IF
              ENDDO
C
              DO isdes=1,nsdes(isec+1, isurf)
                IF (idestd(isdes, isec+1, isurf) .EQ. n) THEN
                  chsinr_g_diff(n) = gaing(isdes, isec+1, isurf)*dtr*
     +              chcosr_diff
                  chsinr_g(n) = chcosr*gaing(isdes, isec+1, isurf)*dtr
                  chcosr_g_diff(n) = -(gaing(isdes, isec+1, isurf)*dtr*
     +              chsinr_diff)
                  chcosr_g(n) = -(chsinr*gaing(isdes, isec+1, isurf)*dtr
     +              )
                END IF
              ENDDO
            ENDDO
C
C
C------ go over chord strips
            iptl = iptloc(isec)
            iptr = iptloc(isec+1)
            nspan = iptr - iptl
            nj(isurf) = nj(isurf) + nspan
C
            DO ispan=1,nspan
C-------- define left and right edges of vortex strip
C-          note that incidence angle is set by ATAN of chord projections,
C-          not by linear interpolation of AINC
              ipt1 = iptl + ispan - 1
              ipt2 = iptl + ispan
              ivs = iptl + ispan - 1
              temp = (ypt(ipt1)-ypt(iptl))/(ypt(iptr)-ypt(iptl))
              f1_diff = (ypt_diff(ipt1)-ypt_diff(iptl)-temp*(ypt_diff(
     +          iptr)-ypt_diff(iptl)))/(ypt(iptr)-ypt(iptl))
              f1 = temp
              temp = (ypt(ipt2)-ypt(iptl))/(ypt(iptr)-ypt(iptl))
              f2_diff = (ypt_diff(ipt2)-ypt_diff(iptl)-temp*(ypt_diff(
     +          iptr)-ypt_diff(iptl)))/(ypt(iptr)-ypt(iptl))
              f2 = temp
C     NSTRIP = NSTRIP + 1
C     NJ(ISURF) = NJ(ISURF) + 1
              temp = (ycp(ivs)-ypt(iptl))/(ypt(iptr)-ypt(iptl))
              fc_diff = (ycp_diff(ivs)-ypt_diff(iptl)-temp*(ypt_diff(
     +          iptr)-ypt_diff(iptl)))/(ypt(iptr)-ypt(iptl))
              fc = temp
C
C-------- store strip in global data arrays
C
              rle1_diff(1, idx_strip) = (1.0-f1)*xyzlel_diff(1) - (
     +          xyzlel(1)-xyzler(1))*f1_diff + f1*xyzler_diff(1)
              rle1(1, idx_strip) = (1.0-f1)*xyzlel(1) + f1*xyzler(1)
              rle1_diff(2, idx_strip) = (1.0-f1)*xyzlel_diff(2) - (
     +          xyzlel(2)-xyzler(2))*f1_diff + f1*xyzler_diff(2)
              rle1(2, idx_strip) = (1.0-f1)*xyzlel(2) + f1*xyzler(2)
              rle1_diff(3, idx_strip) = (1.0-f1)*xyzlel_diff(3) - (
     +          xyzlel(3)-xyzler(3))*f1_diff + f1*xyzler_diff(3)
              rle1(3, idx_strip) = (1.0-f1)*xyzlel(3) + f1*xyzler(3)
              chord1_diff(idx_strip) = (1.0-f1)*chordl_diff - (chordl-
     +          chordr)*f1_diff + f1*chordr_diff
              chord1(idx_strip) = (1.0-f1)*chordl + f1*chordr
C
              rle2_diff(1, idx_strip) = (1.0-f2)*xyzlel_diff(1) - (
     +          xyzlel(1)-xyzler(1))*f2_diff + f2*xyzler_diff(1)
              rle2(1, idx_strip) = (1.0-f2)*xyzlel(1) + f2*xyzler(1)
              rle2_diff(2, idx_strip) = (1.0-f2)*xyzlel_diff(2) - (
     +          xyzlel(2)-xyzler(2))*f2_diff + f2*xyzler_diff(2)
              rle2(2, idx_strip) = (1.0-f2)*xyzlel(2) + f2*xyzler(2)
              rle2_diff(3, idx_strip) = (1.0-f2)*xyzlel_diff(3) - (
     +          xyzlel(3)-xyzler(3))*f2_diff + f2*xyzler_diff(3)
              rle2(3, idx_strip) = (1.0-f2)*xyzlel(3) + f2*xyzler(3)
              chord2_diff(idx_strip) = (1.0-f2)*chordl_diff - (chordl-
     +          chordr)*f2_diff + f2*chordr_diff
              chord2(idx_strip) = (1.0-f2)*chordl + f2*chordr
C
              rle_diff(1, idx_strip) = (1.0-fc)*xyzlel_diff(1) - (xyzlel
     +          (1)-xyzler(1))*fc_diff + fc*xyzler_diff(1)
              rle(1, idx_strip) = (1.0-fc)*xyzlel(1) + fc*xyzler(1)
              rle_diff(2, idx_strip) = (1.0-fc)*xyzlel_diff(2) - (xyzlel
     +          (2)-xyzler(2))*fc_diff + fc*xyzler_diff(2)
              rle(2, idx_strip) = (1.0-fc)*xyzlel(2) + fc*xyzler(2)
              rle_diff(3, idx_strip) = (1.0-fc)*xyzlel_diff(3) - (xyzlel
     +          (3)-xyzler(3))*fc_diff + fc*xyzler_diff(3)
              rle(3, idx_strip) = (1.0-fc)*xyzlel(3) + fc*xyzler(3)
              chord_diff(idx_strip) = (1.0-fc)*chordl_diff - (chordl-
     +          chordr)*fc_diff + fc*chordr_diff
              chord(idx_strip) = (1.0-fc)*chordl + fc*chordr
              IF (f2 - f1 .GE. 0.) THEN
                abs0_diff = f2_diff - f1_diff
                abs0 = f2 - f1
              ELSE
                abs0_diff = f1_diff - f2_diff
                abs0 = -(f2-f1)
              END IF
C
              wstrip_diff(idx_strip) = width*abs0_diff + abs0*width_diff
              wstrip(idx_strip) = abs0*width
              tanle(idx_strip) = (xyzler(1)-xyzlel(1))/width
              tante(idx_strip) = (xyzler(1)+chordr-xyzlel(1)-chordl)/
     +          width
C
Cc#ifdef USE_CPOML
              chsin = chsinl + f1*(chsinr-chsinl)
              chcos = chcosl + f1*(chcosr-chcosl)
              ainc1(idx_strip) = ATAN2(chsin, chcos)
              chsin = chsinl + f2*(chsinr-chsinl)
              chcos = chcosl + f2*(chcosr-chcosl)
              ainc2(idx_strip) = ATAN2(chsin, chcos)
C
Cc#endif
              chsin_diff = chsinl_diff + (chsinr-chsinl)*fc_diff + fc*(
     +          chsinr_diff-chsinl_diff)
              chsin = chsinl + fc*(chsinr-chsinl)
              chcos_diff = chcosl_diff + (chcosr-chcosl)*fc_diff + fc*(
     +          chcosr_diff-chcosl_diff)
              chcos = chcosl + fc*(chcosr-chcosl)
              ainc_diff(idx_strip) = chcos*chsin_diff/(chsin**2+chcos**2
     +          ) - chsin*chcos_diff/(chsin**2+chcos**2)
              ainc(idx_strip) = ATAN2(chsin, chcos)
C
              DO n=1,ndesign
                chsin_g_diff = (1.0-fc)*chsinl_g_diff(n) - (chsinl_g(n)-
     +            chsinr_g(n))*fc_diff + fc*chsinr_g_diff(n)
                chsin_g = (1.0-fc)*chsinl_g(n) + fc*chsinr_g(n)
                chcos_g_diff = (1.0-fc)*chcosl_g_diff(n) - (chcosl_g(n)-
     +            chcosr_g(n))*fc_diff + fc*chcosr_g_diff(n)
                chcos_g = (1.0-fc)*chcosl_g(n) + fc*chcosr_g(n)
                temp = chsin*chsin + chcos*chcos
                temp0 = (chcos*chsin_g-chsin*chcos_g)/temp
                ainc_g_diff(idx_strip, n) = (chsin_g*chcos_diff+chcos*
     +            chsin_g_diff-chcos_g*chsin_diff-chsin*chcos_g_diff-
     +            temp0*(2*chsin*chsin_diff+2*chcos*chcos_diff))/temp
                ainc_g(idx_strip, n) = temp0
              ENDDO
C
              DO n=1,ncontrol
                icl = isconl(n)
                icr = isconr(n)
C
                IF (icl .EQ. 0 .OR. icr .EQ. 0) THEN
C----------- no control effect here
                  gainda_diff(n) = 0.D0
                  gainda(n) = 0.
                  xled_diff(n) = 0.D0
                  xled(n) = 0.
                  xted_diff(n) = 0.D0
                  xted(n) = 0.
C
                  vhinge_diff(1, idx_strip, n) = 0.D0
                  vhinge(1, idx_strip, n) = 0.
                  vhinge_diff(2, idx_strip, n) = 0.D0
                  vhinge(2, idx_strip, n) = 0.
                  vhinge_diff(3, idx_strip, n) = 0.D0
                  vhinge(3, idx_strip, n) = 0.
C
                  vrefl(idx_strip, n) = 0.
C
                  phinge(1, idx_strip, n) = 0.
                  phinge(2, idx_strip, n) = 0.
                  phinge(3, idx_strip, n) = 0.
C
                ELSE
C----------- control variable # N is active here
                  gainda_diff(n) = (gaind(icr, isec+1, isurf)-gaind(icl
     +              , isec, isurf))*fc_diff
                  gainda(n) = gaind(icl, isec, isurf)*(1.0-fc) + gaind(
     +              icr, isec+1, isurf)*fc
C
                  xhd_diff = xhinged(icl, isec, isurf)*((1.0-fc)*
     +              chordl_diff-chordl*fc_diff) + xhinged(icr, isec+1, 
     +              isurf)*(fc*chordr_diff+chordr*fc_diff)
                  xhd = chordl*xhinged(icl, isec, isurf)*(1.0-fc) + 
     +              chordr*xhinged(icr, isec+1, isurf)*fc
                  IF (xhd .GE. 0.0) THEN
C------------ TE control surface, with hinge at XHD
                    xled_diff(n) = xhd_diff
                    xled(n) = xhd
                    xted_diff(n) = chord_diff(idx_strip)
                    xted(n) = chord(idx_strip)
                  ELSE
C------------ LE control surface, with hinge at -XHD
                    xled_diff(n) = 0.D0
                    xled(n) = 0.0
                    xted_diff(n) = -xhd_diff
                    xted(n) = -xhd
                  END IF
C
                  vhx_diff = vhinged(1, icl, isec, isurf)*xyzscal_diff(1
     +              , isurf)
                  vhx = vhinged(1, icl, isec, isurf)*xyzscal(1, isurf)
                  vhy_diff = vhinged(2, icl, isec, isurf)*xyzscal_diff(2
     +              , isurf)
                  vhy = vhinged(2, icl, isec, isurf)*xyzscal(2, isurf)
                  vhz_diff = vhinged(3, icl, isec, isurf)*xyzscal_diff(3
     +              , isurf)
                  vhz = vhinged(3, icl, isec, isurf)*xyzscal(3, isurf)
                  vsq_diff = 2*vhx*vhx_diff + 2*vhy*vhy_diff + 2*vhz*
     +              vhz_diff
                  vsq = vhx**2 + vhy**2 + vhz**2
                  IF (vsq .EQ. 0.0) THEN
                    IF (chordr*xhinged(icr, isec+1, isurf) .GE. 0.) THEN
                      abs1_diff = xhinged(icr, isec+1, isurf)*
     +                  chordr_diff
                      abs1 = chordr*xhinged(icr, isec+1, isurf)
                    ELSE
                      abs1_diff = -(xhinged(icr, isec+1, isurf)*
     +                  chordr_diff)
                      abs1 = -(chordr*xhinged(icr, isec+1, isurf))
                    END IF
                    IF (chordl*xhinged(icl, isec, isurf) .GE. 0.) THEN
                      abs2_diff = xhinged(icl, isec, isurf)*chordl_diff
                      abs2 = chordl*xhinged(icl, isec, isurf)
                    ELSE
                      abs2_diff = -(xhinged(icl, isec, isurf)*
     +                  chordl_diff)
                      abs2 = -(chordl*xhinged(icl, isec, isurf))
                    END IF
C------------ default: set hinge vector along hingeline
                    vhx_diff = xyzles_diff(1, isec+1, isurf) + abs1_diff
     +                - xyzles_diff(1, isec, isurf) - abs2_diff
                    vhx = xyzles(1, isec+1, isurf) + abs1 - xyzles(1, 
     +                isec, isurf) - abs2
                    vhy_diff = xyzles_diff(2, isec+1, isurf) - 
     +                xyzles_diff(2, isec, isurf)
                    vhy = xyzles(2, isec+1, isurf) - xyzles(2, isec, 
     +                isurf)
                    vhz_diff = xyzles_diff(3, isec+1, isurf) - 
     +                xyzles_diff(3, isec, isurf)
                    vhz = xyzles(3, isec+1, isurf) - xyzles(3, isec, 
     +                isurf)
                    vhx_diff = xyzscal(1, isurf)*vhx_diff + vhx*
     +                xyzscal_diff(1, isurf)
                    vhx = vhx*xyzscal(1, isurf)
                    vhy_diff = xyzscal(2, isurf)*vhy_diff + vhy*
     +                xyzscal_diff(2, isurf)
                    vhy = vhy*xyzscal(2, isurf)
                    vhz_diff = xyzscal(3, isurf)*vhz_diff + vhz*
     +                xyzscal_diff(3, isurf)
                    vhz = vhz*xyzscal(3, isurf)
                    vsq_diff = 2*vhx*vhx_diff + 2*vhy*vhy_diff + 2*vhz*
     +                vhz_diff
                    vsq = vhx**2 + vhy**2 + vhz**2
                  END IF
C
                  temp0 = SQRT(vsq)
                  IF (vsq .EQ. 0.D0) THEN
                    vmod_diff = 0.D0
                  ELSE
                    vmod_diff = vsq_diff/(2.0*temp0)
                  END IF
                  vmod = temp0
                  vhinge_diff(1, idx_strip, n) = (vhx_diff-vhx*vmod_diff
     +              /vmod)/vmod
                  vhinge(1, idx_strip, n) = vhx/vmod
                  vhinge_diff(2, idx_strip, n) = (vhy_diff-vhy*vmod_diff
     +              /vmod)/vmod
                  vhinge(2, idx_strip, n) = vhy/vmod
                  vhinge_diff(3, idx_strip, n) = (vhz_diff-vhz*vmod_diff
     +              /vmod)/vmod
                  vhinge(3, idx_strip, n) = vhz/vmod
C
                  vrefl(idx_strip, n) = refld(icl, isec, isurf)
C
                  IF (xhd .GE. 0.0) THEN
                    phinge(1, idx_strip, n) = rle(1, idx_strip) + xhd
                    phinge(2, idx_strip, n) = rle(2, idx_strip)
                    phinge(3, idx_strip, n) = rle(3, idx_strip)
                  ELSE
                    phinge(1, idx_strip, n) = rle(1, idx_strip) - xhd
                    phinge(2, idx_strip, n) = rle(2, idx_strip)
                    phinge(3, idx_strip, n) = rle(3, idx_strip)
                  END IF
                END IF
              ENDDO
C
C
C--- Interpolate CD-CL polar defining data from input sections to strips
              DO l=1,6
                clcd(l, idx_strip) = (1.0-fc)*clcdsec(l, isec, isurf) + 
     +            fc*clcdsec(l, isec+1, isurf)
              ENDDO
C--- If the min drag is zero flag the strip as no-viscous data
C     IJFRST(idx_strip) = NVOR + 1
              lviscstrp(idx_strip) = clcd(4, idx_strip) .NE. 0.0
C
C
              IF (idx_strip .EQ. 1) THEN
                ijfrst(idx_strip) = 1
              ELSE
                ijfrst(idx_strip) = ijfrst(idx_strip-1) + nvstrp(
     +            idx_strip-1)
              END IF
              nvstrp(idx_strip) = nvc(isurf)
C           write(*,*) 'IJFRST(idx_strip)', IJFRST(idx_strip),
C      &               'NVSTRP(idx_strip)', IJFRST(idx_strip - 1) + NVC(ISURF)
C
              nsurfs(idx_strip) = isurf
C
              nsl = nasec(isec, isurf)
              nsr = nasec(isec+1, isurf)
C
              chordc_diff = chord_diff(idx_strip)
              chordc = chord(idx_strip)
C
              temp0 = (-fc+1.)/chordc
              temp = clafr/chordc
              clafc_diff = chordl*clafl*(-fc_diff-temp0*chordc_diff)/
     +          chordc + temp0*(clafl*chordl_diff+chordl*clafl_diff) + 
     +          temp*(chordr*fc_diff+fc*chordr_diff) + fc*chordr*(
     +          clafr_diff-temp*chordc_diff)/chordc
              clafc = temp0*(chordl*clafl) + fc*chordr*temp
C
C-------- set chordwise spacing fraction arrays
              CALL CSPACER_D(nvc(isurf), cspace(isurf), clafc, 
     +                       clafc_diff, xpt, xvr, xsr, xcp, xcp_diff)
C
C-------- go over vortices in this strip
              idx_vor = ijfrst(idx_strip)
C NVOR = NVOR + 1
C change all NVOR indices into idx_vor
C change all NSTRIP indices into idx_strip
              DO ivc=1,nvc(isurf)
C
                rv1_diff(1, idx_vor) = rle1_diff(1, idx_strip) + xvr(ivc
     +            )*chord1_diff(idx_strip)
                rv1(1, idx_vor) = rle1(1, idx_strip) + xvr(ivc)*chord1(
     +            idx_strip)
                rv1_diff(2, idx_vor) = rle1_diff(2, idx_strip)
                rv1(2, idx_vor) = rle1(2, idx_strip)
                rv1_diff(3, idx_vor) = rle1_diff(3, idx_strip)
                rv1(3, idx_vor) = rle1(3, idx_strip)
C
                rv2_diff(1, idx_vor) = rle2_diff(1, idx_strip) + xvr(ivc
     +            )*chord2_diff(idx_strip)
                rv2(1, idx_vor) = rle2(1, idx_strip) + xvr(ivc)*chord2(
     +            idx_strip)
                rv2_diff(2, idx_vor) = rle2_diff(2, idx_strip)
                rv2(2, idx_vor) = rle2(2, idx_strip)
                rv2_diff(3, idx_vor) = rle2_diff(3, idx_strip)
                rv2(3, idx_vor) = rle2(3, idx_strip)
C
                rv_diff(1, idx_vor) = rle_diff(1, idx_strip) + xvr(ivc)*
     +            chordc_diff
                rv(1, idx_vor) = rle(1, idx_strip) + xvr(ivc)*chordc
                rv_diff(2, idx_vor) = rle_diff(2, idx_strip)
                rv(2, idx_vor) = rle(2, idx_strip)
                rv_diff(3, idx_vor) = rle_diff(3, idx_strip)
                rv(3, idx_vor) = rle(3, idx_strip)
C
                rc_diff(1, idx_vor) = rle_diff(1, idx_strip) + chordc*
     +            xcp_diff(ivc) + xcp(ivc)*chordc_diff
                rc(1, idx_vor) = rle(1, idx_strip) + xcp(ivc)*chordc
                rc_diff(2, idx_vor) = rle_diff(2, idx_strip)
                rc(2, idx_vor) = rle(2, idx_strip)
                rc_diff(3, idx_vor) = rle_diff(3, idx_strip)
                rc(3, idx_vor) = rle(3, idx_strip)
C
                rs_diff(1, idx_vor) = rle_diff(1, idx_strip) + xsr(ivc)*
     +            chordc_diff
                rs(1, idx_vor) = rle(1, idx_strip) + xsr(ivc)*chordc
                rs_diff(2, idx_vor) = rle_diff(2, idx_strip)
                rs(2, idx_vor) = rle(2, idx_strip)
                rs_diff(3, idx_vor) = rle_diff(3, idx_strip)
                rs(3, idx_vor) = rle(3, idx_strip)
C
                CALL AKIMA_D(xasec(1, isec, isurf), xasec_diff(1, isec, 
     +                       isurf), sasec(1, isec, isurf), sasec_diff(1
     +                       , isec, isurf), nsl, xcp(ivc), xcp_diff(ivc
     +                       ), slopel, slopel_diff, dsdx)
                CALL AKIMA_D(xasec(1, isec+1, isurf), xasec_diff(1, isec
     +                       +1, isurf), sasec(1, isec+1, isurf), 
     +                       sasec_diff(1, isec+1, isurf), nsr, xcp(ivc)
     +                       , xcp_diff(ivc), sloper, sloper_diff, dsdx)
                temp0 = (-fc+1.)/chordc
                temp = sloper/chordc
                slopec_diff(idx_vor) = chordl*slopel*(-fc_diff-temp0*
     +            chordc_diff)/chordc + temp0*(slopel*chordl_diff+chordl
     +            *slopel_diff) + temp*(chordr*fc_diff+fc*chordr_diff) +
     +            fc*chordr*(sloper_diff-temp*chordc_diff)/chordc
                slopec(idx_vor) = temp0*(chordl*slopel) + fc*chordr*temp
C
                DO ii1=1,kcmax
                  xvr_diff(ii1) = 0.D0
                ENDDO
                CALL AKIMA_D(xasec(1, isec, isurf), xasec_diff(1, isec, 
     +                       isurf), sasec(1, isec, isurf), sasec_diff(1
     +                       , isec, isurf), nsl, xvr(ivc), xvr_diff(ivc
     +                       ), slopel, slopel_diff, dsdx)
                DO ii1=1,kcmax
                  xvr_diff(ii1) = 0.D0
                ENDDO
                CALL AKIMA_D(xasec(1, isec+1, isurf), xasec_diff(1, isec
     +                       +1, isurf), sasec(1, isec+1, isurf), 
     +                       sasec_diff(1, isec+1, isurf), nsr, xvr(ivc)
     +                       , xvr_diff(ivc), sloper, sloper_diff, dsdx)
                temp0 = (-fc+1.)/chordc
                temp = sloper/chordc
                slopev_diff(idx_vor) = chordl*slopel*(-fc_diff-temp0*
     +            chordc_diff)/chordc + temp0*(slopel*chordl_diff+chordl
     +            *slopel_diff) + temp*(chordr*fc_diff+fc*chordr_diff) +
     +            fc*chordr*(sloper_diff-temp*chordc_diff)/chordc
                slopev(idx_vor) = temp0*(chordl*slopel) + fc*chordr*temp
C
                dxoc = xpt(ivc+1) - xpt(ivc)
                dxv_diff(idx_vor) = dxoc*chordc_diff
                dxv(idx_vor) = dxoc*chordc
                chordv_diff(idx_vor) = chordc_diff
                chordv(idx_vor) = chordc
                nsurfv(idx_vor) = lscomp(isurf)
C
                lvnc(idx_vor) = .true.
C
C---------- element inherits alpha,beta flag from surface
                lvalbe(idx_vor) = lfalbe(isurf)
C
                DO n=1,ncontrol
C------------ scale control gain by factor 0..1, (fraction of element on control surface)
                  temp0 = xled(n)/chordc
                  fracle_diff = (xled_diff(n)-temp0*chordc_diff)/(dxoc*
     +              chordc)
                  fracle = (temp0-xpt(ivc))/dxoc
                  temp0 = xted(n)/chordc
                  fracte_diff = (xted_diff(n)-temp0*chordc_diff)/(dxoc*
     +              chordc)
                  fracte = (temp0-xpt(ivc))/dxoc
                  IF (0.0 .LT. fracle) THEN
                    y1_diff = fracle_diff
                    y1 = fracle
                  ELSE
                    y1 = 0.0
                    y1_diff = 0.D0
                  END IF
                  IF (1.0 .GT. y1) THEN
                    fracle_diff = y1_diff
                    fracle = y1
                  ELSE
                    fracle = 1.0
                    fracle_diff = 0.D0
                  END IF
                  IF (0.0 .LT. fracte) THEN
                    y2_diff = fracte_diff
                    y2 = fracte
                  ELSE
                    y2 = 0.0
                    y2_diff = 0.D0
                  END IF
                  IF (1.0 .GT. y2) THEN
                    fracte_diff = y2_diff
                    fracte = y2
                  ELSE
                    fracte = 1.0
                    fracte_diff = 0.D0
                  END IF
C
                  dcontrol_diff(idx_vor, n) = (fracte-fracle)*
     +              gainda_diff(n) + gainda(n)*(fracte_diff-fracle_diff)
                  dcontrol(idx_vor, n) = gainda(n)*(fracte-fracle)
                ENDDO
C
C---------- TE control point used only if surface sheds a wake
                lvnc(idx_vor) = lfwake(isurf)
C
Cc#ifdef USE_CPOML
C...        nodal grid associated with vortex strip (aft-panel nodes)
C...        NOTE: airfoil in plane of wing, but not rotated perpendicular to dihedral;
C...        retained in (x,z) plane at this point
                CALL AKIMA(xlasec(1, isec, isurf), zlasec(1, isec, isurf
     +                     ), nsl, xpt(ivc+1), zl, dsdx)
                CALL AKIMA(xuasec(1, isec, isurf), zuasec(1, isec, isurf
     +                     ), nsl, xpt(ivc+1), zu, dsdx)
C
                xyn1(1, idx_vor) = rle1(1, idx_strip) + xpt(ivc+1)*
     +            chord1(idx_strip)
                xyn1(2, idx_vor) = rle1(2, idx_strip)
                zlon1(idx_vor) = rle1(3, idx_strip) + zl*chord1(
     +            idx_strip)
                zupn1(idx_vor) = rle1(3, idx_strip) + zu*chord1(
     +            idx_strip)
C
                CALL AKIMA(xlasec(1, isec+1, isurf), zlasec(1, isec+1, 
     +                     isurf), nsl, xpt(ivc+1), zl, dsdx)
                CALL AKIMA(xuasec(1, isec+1, isurf), zuasec(1, isec+1, 
     +                     isurf), nsl, xpt(ivc+1), zu, dsdx)
C
                xyn2(1, idx_vor) = rle2(1, idx_strip) + xpt(ivc+1)*
     +            chord2(idx_strip)
                xyn2(2, idx_vor) = rle2(2, idx_strip)
                zlon2(idx_vor) = rle2(3, idx_strip) + zl*chord2(
     +            idx_strip)
                zupn2(idx_vor) = rle2(3, idx_strip) + zu*chord2(
     +            idx_strip)
C
Cc#endif
                idx_vor = idx_vor + 1
              ENDDO
C           
              idx_strip = idx_strip + 1
            ENDDO
          ENDDO
C
C
C---- Find wetted surface area (one side)
          sum = 0.0
          wtot = 0.0
          DO jj=1,nj(isurf)
            j = jfrst(isurf) + jj - 1
            astrp = wstrip(j)*chord(j)
            sum = sum + astrp
            wtot = wtot + wstrip(j)
          ENDDO
          ssurf(isurf) = sum
C
          IF (wtot .EQ. 0.0) THEN
            cavesurf(isurf) = 0.0
          ELSE
            cavesurf(isurf) = sum/wtot
          END IF
C     add number of strips to the global count
          nstrip = nstrip + nj(isurf)
C     add number of of votrices
          nvor = nvor + nk(isurf)*nj(isurf)
C
          RETURN
        END IF
      END IF
C
 7000 FORMAT(/' *** Cannot adjust spanwise spacing at section',i3,
     +       ', on surface ',a/
     +      ' *** Insufficient number of spanwise vortices to work with'
     +      )
      END

C  Differentiation of sdupl in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: rle chord rle1 chord1 rle2
C                chord2 wstrip ainc ainc_g rv1 rv2 rv rc dxv chordv
C                slopev slopec dcontrol vhinge
C   with respect to varying inputs: rle chord rle1 chord1 rle2
C                chord2 wstrip ainc ainc_g rv1 rv2 rv rc dxv chordv
C                slopev slopec dcontrol vhinge
C MAKEBODY
C
C
C
C
      SUBROUTINE SDUPL_D(nn, ypt, msg)
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
      CHARACTER*(*) msg
      INTEGER idx_vor
      INTEGER nni
      INTEGER klen
      INTRINSIC LEN
      INTEGER k
      INTEGER isec
      INTEGER idup
      INTEGER iorg
      REAL yoff
      INTEGER idx_strip
      INTEGER ivs
      INTEGER jji
      INTEGER jj
      INTEGER n
      INTEGER l
      INTEGER ivc
      INTEGER iii
      INTEGER ii
      REAL rsgn
      INTEGER nn
      REAL ypt
C
C     
      nni = nn + 1
      IF (nni .GT. nfmax) THEN
        WRITE(*, *) 'SDUPL: Surface array overflow. Increase NFMAX', 
     +        ' currently ', nfmax
        STOP
      ELSE
C
        klen = LEN(stitle(nn))
        DO k=klen,1,-1
          IF (stitle(nn)(k:k) .NE. ' ') EXIT
        ENDDO
        stitle(nni) = stitle(nn)(1:k)//' ('//msg//')'
        IF (lverbose) THEN
          WRITE(*, *) ' '
          WRITE(*, *) '  Building duplicate image-surface: ', stitle(nni
     +          )
        END IF
C
C---- duplicate surface is assumed to be the same logical component surface
        lscomp(nni) = lscomp(nn)
C
C---- same various logical flags
        lfwake(nni) = lfwake(nn)
        lfalbe(nni) = lfalbe(nn)
        lfload(nni) = lfload(nn)
        lrange(nni) = lrange(nn)
C IFRST(NNI) = NVOR   + 1
        lsurfspacing(nni) = lsurfspacing(nn)
C
C---- accumulate stuff for new image surface 
        ifrst(nni) = ifrst(nni-1) + nk(nni-1)*nj(nni-1)
C JFRST(NNI) = NSTRIP + 1
        jfrst(nni) = jfrst(nni-1) + nj(nni-1)
        nj(nni) = nj(nn)
        nk(nni) = nk(nn)
C
        nvc(nni) = nk(nni)
        nvs(nni) = nj(nni)
C
        ssurf(nni) = ssurf(nn)
        cavesurf(nni) = cavesurf(nn)
C--- Note hinge axis is flipped to reverse the Y component of the hinge
C    vector.   This means that deflections need to be reversed for image
C    surfaces.
C
C--- Image flag reversed (set to -IMAGS) for imaged surfaces
        imags(nni) = -imags(nn)
C
Cc#ifdef USE_CPOML
        icntfrst(nni) = icntfrst(nn) + ncntsec(nn)
        ncntsec(nni) = ncntsec(nn)
        DO isec=1,ncntsec(nni)
          idup = icntfrst(nni) + (isec-1)
          iorg = icntfrst(nn) + (isec-1)
          icntsec(idup) = icntsec(iorg)
        ENDDO
Cc#endif
C
        yoff = 2.0*ypt
C
C--- Create image strips, to maintain the same sense of positive GAMMA
C    these have the 1 and 2 strip edges reversed (i.e. root is edge 2, 
C    not edge 1 as for a strip with IMAGS=1
        idx_strip = jfrst(nni)
C   NSTRIP = NSTRIP + 1
        DO ivs=1,nvs(nni)
          IF (idx_strip .GT. nsmax) THEN
            GOTO 100
          ELSE
C
            jji = jfrst(nni) + ivs - 1
            jj = jfrst(nn) + ivs - 1
            rle1_diff(1, jji) = rle2_diff(1, jj)
            rle1(1, jji) = rle2(1, jj)
            rle1_diff(2, jji) = -rle2_diff(2, jj)
            rle1(2, jji) = -rle2(2, jj) + yoff
            rle1_diff(3, jji) = rle2_diff(3, jj)
            rle1(3, jji) = rle2(3, jj)
            chord1_diff(jji) = chord2_diff(jj)
            chord1(jji) = chord2(jj)
            rle2_diff(1, jji) = rle1_diff(1, jj)
            rle2(1, jji) = rle1(1, jj)
            rle2_diff(2, jji) = -rle1_diff(2, jj)
            rle2(2, jji) = -rle1(2, jj) + yoff
            rle2_diff(3, jji) = rle1_diff(3, jj)
            rle2(3, jji) = rle1(3, jj)
            chord2_diff(jji) = chord1_diff(jj)
            chord2(jji) = chord1(jj)
            rle_diff(1, jji) = rle_diff(1, jj)
            rle(1, jji) = rle(1, jj)
            rle_diff(2, jji) = -rle_diff(2, jj)
            rle(2, jji) = -rle(2, jj) + yoff
            rle_diff(3, jji) = rle_diff(3, jj)
            rle(3, jji) = rle(3, jj)
            chord_diff(jji) = chord_diff(jj)
            chord(jji) = chord(jj)
            wstrip_diff(jji) = wstrip_diff(jj)
            wstrip(jji) = wstrip(jj)
            tanle(jji) = -tanle(jj)
            ainc_diff(jji) = ainc_diff(jj)
            ainc(jji) = ainc(jj)
C
Cc#ifdef USE_CPOML
            ainc1(jji) = ainc2(jj)
            ainc2(jji) = ainc1(jj)
C
Cc#endif
            nsurfs(idx_strip) = nni
C
            DO n=1,ndesign
              ainc_g_diff(jji, n) = ainc_g_diff(jj, n)
              ainc_g(jji, n) = ainc_g(jj, n)
            ENDDO
C
            DO n=1,ncontrol
              vrefl(jji, n) = vrefl(jj, n)
C
              vhinge_diff(1, jji, n) = vhinge_diff(1, jj, n)
              vhinge(1, jji, n) = vhinge(1, jj, n)
              vhinge_diff(2, jji, n) = -vhinge_diff(2, jj, n)
              vhinge(2, jji, n) = -vhinge(2, jj, n)
              vhinge_diff(3, jji, n) = vhinge_diff(3, jj, n)
              vhinge(3, jji, n) = vhinge(3, jj, n)
C
              phinge(1, jji, n) = phinge(1, jj, n)
              phinge(2, jji, n) = -phinge(2, jj, n) + yoff
              phinge(3, jji, n) = phinge(3, jj, n)
            ENDDO
C   IJFRST(JJI)  = NVOR + 1
C   IJFRST(JJI) = IJFRST(NSTRIP - 1) + NVC(NNI)
C
C--- The defined section for image strip is flagged with (-)
            ijfrst(jji) = ijfrst(jji-1) + nvstrp(jji-1)
C
            nvstrp(jji) = nvc(nni)
            DO l=1,6
              clcd(l, jji) = clcd(l, jj)
            ENDDO
            lviscstrp(jji) = lviscstrp(jj)
C
            idx_vor = ijfrst(jji)
C
C     NVOR = NVOR + 1
            DO ivc=1,nvc(nni)
              IF (idx_vor .GT. nvmax) THEN
                GOTO 110
              ELSE
C
                iii = ijfrst(jji) + ivc - 1
                ii = ijfrst(jj) + ivc - 1
                rv1_diff(1, iii) = rv2_diff(1, ii)
                rv1(1, iii) = rv2(1, ii)
                rv1_diff(2, iii) = -rv2_diff(2, ii)
                rv1(2, iii) = -rv2(2, ii) + yoff
                rv1_diff(3, iii) = rv2_diff(3, ii)
                rv1(3, iii) = rv2(3, ii)
                rv2_diff(1, iii) = rv1_diff(1, ii)
                rv2(1, iii) = rv1(1, ii)
                rv2_diff(2, iii) = -rv1_diff(2, ii)
                rv2(2, iii) = -rv1(2, ii) + yoff
                rv2_diff(3, iii) = rv1_diff(3, ii)
                rv2(3, iii) = rv1(3, ii)
                rv_diff(1, iii) = rv_diff(1, ii)
                rv(1, iii) = rv(1, ii)
                rv_diff(2, iii) = -rv_diff(2, ii)
                rv(2, iii) = -rv(2, ii) + yoff
                rv_diff(3, iii) = rv_diff(3, ii)
                rv(3, iii) = rv(3, ii)
                rc_diff(1, iii) = rc_diff(1, ii)
                rc(1, iii) = rc(1, ii)
                rc_diff(2, iii) = -rc_diff(2, ii)
                rc(2, iii) = -rc(2, ii) + yoff
                rc_diff(3, iii) = rc_diff(3, ii)
                rc(3, iii) = rc(3, ii)
                slopec_diff(iii) = slopec_diff(ii)
                slopec(iii) = slopec(ii)
                slopev_diff(iii) = slopev_diff(ii)
                slopev(iii) = slopev(ii)
                dxv_diff(iii) = dxv_diff(ii)
                dxv(iii) = dxv(ii)
                chordv_diff(iii) = chordv_diff(ii)
                chordv(iii) = chordv(ii)
                nsurfv(iii) = lscomp(nni)
                lvalbe(iii) = lvalbe(ii)
                lvnc(iii) = lvnc(ii)
C
                DO n=1,ncontrol
Ccc         RSGN = SIGN( 1.0 , VREFL(JJ,N) )
                  rsgn = vrefl(jj, n)
                  dcontrol_diff(iii, n) = -(rsgn*dcontrol_diff(ii, n))
                  dcontrol(iii, n) = -(dcontrol(ii, n)*rsgn)
                ENDDO
C          
Cc#ifdef USE_CPOML
C...      nodal grid associated with vortex strip
                xyn1(1, iii) = xyn2(1, ii)
                xyn1(2, iii) = -xyn2(2, ii) + yoff
                xyn2(1, iii) = xyn1(1, ii)
                xyn2(2, iii) = -xyn1(2, ii) + yoff
C
                zlon1(iii) = zlon2(ii)
                zupn1(iii) = zupn2(ii)
                zlon2(iii) = zlon1(ii)
                zupn2(iii) = zupn1(ii)
Cc#endif
                idx_vor = idx_vor + 1
              END IF
            ENDDO
C
            idx_strip = idx_strip + 1
          END IF
        ENDDO
C
C
C
        nstrip = nstrip + nj(nni)
        nvor = nvor + nk(nni)*nj(nni)
C
        RETURN
 100    WRITE(*, *) 'SDUPL: Strip array overflow. Increase NSMAX', 
     +        ' currently ', nsmax
        STOP
 110    WRITE(*, *) 'SDUPL: Vortex array overflow. Increase NVMAX', 
     +        ' currently ', nvmax
        STOP
      END IF
      END

C  Differentiation of encalc in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: ess ensy ensz xsref ysref zsref
C                enc env enc_d
C   with respect to varying inputs: ainc ainc_g rv1 rv2 rv slopev
C                slopec dcontrol vhinge
C BDUPL
C
C
C
C
      SUBROUTINE ENCALC_D()
      INCLUDE 'AVL.INC'
      INCLUDE 'AVL_ad_seeds.inc'
C
      REAL ep(3), eq(3), es(3), eb(3), ec(3), ecxb(3)
      REAL ep_diff(3), eq_diff(3), es_diff(3), eb_diff(3), ec_diff(3), 
     +     ecxb_diff(3)
      REAL ec_g(3, ndmax), ecxb_g(3)
      INTEGER j
      INTEGER i
      REAL dxle
      REAL dxle_diff
      REAL dyle
      REAL dyle_diff
      REAL dzle
      REAL dzle_diff
      REAL axle
      REAL axle_diff
      REAL ayle
      REAL ayle_diff
      REAL azle
      REAL azle_diff
      REAL dxte
      REAL dxte_diff
      REAL dyte
      REAL dyte_diff
      REAL dzte
      REAL dzte_diff
      REAL axte
      REAL axte_diff
      REAL ayte
      REAL ayte_diff
      REAL azte
      REAL azte_diff
      REAL dxt
      REAL dxt_diff
      REAL dyt
      REAL dyt_diff
      REAL dzt
      REAL dzt_diff
      INTRINSIC SQRT
      INTEGER nv
      INTEGER ii
      INTEGER n
      REAL dxb
      REAL dxb_diff
      REAL dyb
      REAL dyb_diff
      REAL dzb
      REAL dzb_diff
      REAL emag
      REAL emag_diff
      REAL ang
      REAL ang_diff
      INTRINSIC ATAN
      REAL sinc
      REAL sinc_diff
      INTRINSIC SIN
      REAL cosc
      REAL cosc_diff
      INTRINSIC COS
      REAL emag_g
      REAL ang_ddc
      REAL ang_ddc_diff
      REAL cosd
      REAL sind
      REAL endot
      REAL endot_diff
      REAL DOT
      REAL DOT_D
      REAL arg1
      REAL arg1_diff
      REAL result1
      REAL result1_diff
      REAL temp
      INTEGER ii1
      INTEGER ii3
      INTEGER ii2
      DO ii1=1,nsmax
        DO ii2=1,3
          ess_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nsmax
        ensy_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        ensz_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        xsref_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        ysref_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nsmax
        zsref_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,nvmax
        DO ii2=1,3
          enc_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,nvmax
        DO ii2=1,3
          env_diff(ii2, ii1) = 0.D0
        ENDDO
      ENDDO
      DO ii1=1,ndmax
        DO ii2=1,nvmax
          DO ii3=1,3
            enc_d_diff(ii3, ii2, ii1) = 0.D0
          ENDDO
        ENDDO
      ENDDO
      DO ii1=1,3
        eb_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        ec_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        ep_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        eq_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        es_diff(ii1) = 0.D0
      ENDDO
      DO ii1=1,3
        ecxb_diff(ii1) = 0.D0
      ENDDO
C
C...Calculate the normal vector at control points and bound vortex midpoints
C
      DO j=1,nstrip
C
C...Calculate normal vector for the strip (normal to X axis)
        i = ijfrst(j)
        dxle_diff = rv2_diff(1, i) - rv1_diff(1, i)
        dxle = rv2(1, i) - rv1(1, i)
        dyle_diff = rv2_diff(2, i) - rv1_diff(2, i)
        dyle = rv2(2, i) - rv1(2, i)
        dzle_diff = rv2_diff(3, i) - rv1_diff(3, i)
        dzle = rv2(3, i) - rv1(3, i)
C       AXLE = (RV2(1,I)+RV1(1,I))*0.5
C       AYLE = (RV2(2,I)+RV1(2,I))*0.5
C       AZLE = (RV2(3,I)+RV1(3,I))*0.5
        axle_diff = rv_diff(1, i)
        axle = rv(1, i)
        ayle_diff = rv_diff(2, i)
        ayle = rv(2, i)
        azle_diff = rv_diff(3, i)
        azle = rv(3, i)
C
        i = ijfrst(j) + (nvstrp(j)-1)
        dxte_diff = rv2_diff(1, i) - rv1_diff(1, i)
        dxte = rv2(1, i) - rv1(1, i)
        dyte_diff = rv2_diff(2, i) - rv1_diff(2, i)
        dyte = rv2(2, i) - rv1(2, i)
        dzte_diff = rv2_diff(3, i) - rv1_diff(3, i)
        dzte = rv2(3, i) - rv1(3, i)
C       AXTE = (RV2(1,I)+RV1(1,I))*0.5
C       AYTE = (RV2(2,I)+RV1(2,I))*0.5
C       AZTE = (RV2(3,I)+RV1(3,I))*0.5
        axte_diff = rv_diff(1, i)
        axte = rv(1, i)
        ayte_diff = rv_diff(2, i)
        ayte = rv(2, i)
        azte_diff = rv_diff(3, i)
        azte = rv(3, i)
C
        dxt_diff = (1.0-saxfr)*dxle_diff + saxfr*dxte_diff
        dxt = (1.0-saxfr)*dxle + saxfr*dxte
        dyt_diff = (1.0-saxfr)*dyle_diff + saxfr*dyte_diff
        dyt = (1.0-saxfr)*dyle + saxfr*dyte
        dzt_diff = (1.0-saxfr)*dzle_diff + saxfr*dzte_diff
        dzt = (1.0-saxfr)*dzle + saxfr*dzte
C
        arg1_diff = 2*dxt*dxt_diff + 2*dyt*dyt_diff + 2*dzt*dzt_diff
        arg1 = dxt*dxt + dyt*dyt + dzt*dzt
        temp = SQRT(arg1)
        IF (arg1 .EQ. 0.D0) THEN
          result1_diff = 0.D0
        ELSE
          result1_diff = arg1_diff/(2.0*temp)
        END IF
        result1 = temp
        ess_diff(1, j) = (dxt_diff-dxt*result1_diff/result1)/result1
        ess(1, j) = dxt/result1
        arg1_diff = 2*dxt*dxt_diff + 2*dyt*dyt_diff + 2*dzt*dzt_diff
        arg1 = dxt*dxt + dyt*dyt + dzt*dzt
        temp = SQRT(arg1)
        IF (arg1 .EQ. 0.D0) THEN
          result1_diff = 0.D0
        ELSE
          result1_diff = arg1_diff/(2.0*temp)
        END IF
        result1 = temp
        ess_diff(2, j) = (dyt_diff-dyt*result1_diff/result1)/result1
        ess(2, j) = dyt/result1
        arg1_diff = 2*dxt*dxt_diff + 2*dyt*dyt_diff + 2*dzt*dzt_diff
        arg1 = dxt*dxt + dyt*dyt + dzt*dzt
        temp = SQRT(arg1)
        IF (arg1 .EQ. 0.D0) THEN
          result1_diff = 0.D0
        ELSE
          result1_diff = arg1_diff/(2.0*temp)
        END IF
        result1 = temp
        ess_diff(3, j) = (dzt_diff-dzt*result1_diff/result1)/result1
        ess(3, j) = dzt/result1
C
        arg1_diff = 2*dyt*dyt_diff + 2*dzt*dzt_diff
        arg1 = dyt*dyt + dzt*dzt
        temp = SQRT(arg1)
        IF (arg1 .EQ. 0.D0) THEN
          result1_diff = 0.D0
        ELSE
          result1_diff = arg1_diff/(2.0*temp)
        END IF
        result1 = temp
        ensy_diff(j) = -((dzt_diff-dzt*result1_diff/result1)/result1)
        ensy(j) = -(dzt/result1)
        arg1_diff = 2*dyt*dyt_diff + 2*dzt*dzt_diff
        arg1 = dyt*dyt + dzt*dzt
        temp = SQRT(arg1)
        IF (arg1 .EQ. 0.D0) THEN
          result1_diff = 0.D0
        ELSE
          result1_diff = arg1_diff/(2.0*temp)
        END IF
        result1 = temp
        ensz_diff(j) = (dyt_diff-dyt*result1_diff/result1)/result1
        ensz(j) = dyt/result1
C
        xsref_diff(j) = (1.0-saxfr)*axle_diff + saxfr*axte_diff
        xsref(j) = (1.0-saxfr)*axle + saxfr*axte
        ysref_diff(j) = (1.0-saxfr)*ayle_diff + saxfr*ayte_diff
        ysref(j) = (1.0-saxfr)*ayle + saxfr*ayte
        zsref_diff(j) = (1.0-saxfr)*azle_diff + saxfr*azte_diff
        zsref(j) = (1.0-saxfr)*azle + saxfr*azte
C
C
        es_diff(1) = 0.D0
        es(1) = 0.
        es_diff(2) = ensy_diff(j)
        es(2) = ensy(j)
        es_diff(3) = ensz_diff(j)
        es(3) = ensz(j)
C
        lstripoff(j) = .false.
C
        nv = nvstrp(j)
        DO ii=1,nv
C
          i = ijfrst(j) + (ii-1)
C
          DO n=1,ncontrol
            env_d(1, i, n) = 0.
            env_d(2, i, n) = 0.
            env_d(3, i, n) = 0.
            enc_d_diff(1, i, n) = 0.D0
            enc_d(1, i, n) = 0.
            enc_d_diff(2, i, n) = 0.D0
            enc_d(2, i, n) = 0.
            enc_d_diff(3, i, n) = 0.D0
            enc_d(3, i, n) = 0.
          ENDDO
C
          DO n=1,ndesign
            env_g(1, i, n) = 0.
            env_g(2, i, n) = 0.
            env_g(3, i, n) = 0.
            enc_g(1, i, n) = 0.
            enc_g(2, i, n) = 0.
            enc_g(3, i, n) = 0.
          ENDDO
C
C...Define unit vector along bound leg
C right h.v. pt - left h.v. pt 
          dxb_diff = rv2_diff(1, i) - rv1_diff(1, i)
          dxb = rv2(1, i) - rv1(1, i)
          dyb_diff = rv2_diff(2, i) - rv1_diff(2, i)
          dyb = rv2(2, i) - rv1(2, i)
          dzb_diff = rv2_diff(3, i) - rv1_diff(3, i)
          dzb = rv2(3, i) - rv1(3, i)
          arg1_diff = 2*dxb*dxb_diff + 2*dyb*dyb_diff + 2*dzb*dzb_diff
          arg1 = dxb**2 + dyb**2 + dzb**2
          temp = SQRT(arg1)
          IF (arg1 .EQ. 0.D0) THEN
            emag_diff = 0.D0
          ELSE
            emag_diff = arg1_diff/(2.0*temp)
          END IF
          emag = temp
          eb_diff(1) = (dxb_diff-dxb*emag_diff/emag)/emag
          eb(1) = dxb/emag
          eb_diff(2) = (dyb_diff-dyb*emag_diff/emag)/emag
          eb(2) = dyb/emag
          eb_diff(3) = (dzb_diff-dzb*emag_diff/emag)/emag
          eb(3) = dzb/emag
C
C...Define direction of normal vector at control point 
C   The YZ projection of the normal vector matches the camber slope
C   + section local incidence in the YZ defining plane for the section
          ang_diff = ainc_diff(j) - slopec_diff(i)/(1.0+slopec(i)**2)
          ang = ainc(j) - ATAN(slopec(i))
Cc          IF(LDES) THEN
C--------- add design-variable contribution to angle
          DO n=1,ndesign
            ang_diff = ang_diff + deldes(n)*ainc_g_diff(j, n)
            ang = ang + ainc_g(j, n)*deldes(n)
          ENDDO
Cc          ENDIF
C
          sinc_diff = COS(ang)*ang_diff
          sinc = SIN(ang)
          cosc_diff = -(SIN(ang)*ang_diff)
          cosc = COS(ang)
          ec_diff(1) = cosc_diff
          ec(1) = cosc
          ec_diff(2) = -(es(2)*sinc_diff+sinc*es_diff(2))
          ec(2) = -(sinc*es(2))
C     EC  = rotation of strip normal vector? or along chord?
          ec_diff(3) = -(es(3)*sinc_diff+sinc*es_diff(3))
          ec(3) = -(sinc*es(3))
          DO n=1,ndesign
            ec_g(1, n) = -(sinc*ainc_g(j, n))
            ec_g(2, n) = -(cosc*es(2)*ainc_g(j, n))
            ec_g(3, n) = -(cosc*es(3)*ainc_g(j, n))
          ENDDO
C
C...Normal vector is perpendicular to camberline vector and to the bound leg
          CALL CROSS_D(ec, ec_diff, eb, eb_diff, ecxb, ecxb_diff)
          arg1_diff = 2*ecxb(1)*ecxb_diff(1) + 2*ecxb(2)*ecxb_diff(2) + 
     +      2*ecxb(3)*ecxb_diff(3)
          arg1 = ecxb(1)**2 + ecxb(2)**2 + ecxb(3)**2
          temp = SQRT(arg1)
          IF (arg1 .EQ. 0.D0) THEN
            emag_diff = 0.D0
          ELSE
            emag_diff = arg1_diff/(2.0*temp)
          END IF
          emag = temp
          IF (emag .NE. 0.0) THEN
            temp = ecxb(1)/emag
            enc_diff(1, i) = (ecxb_diff(1)-temp*emag_diff)/emag
            enc(1, i) = temp
            temp = ecxb(2)/emag
            enc_diff(2, i) = (ecxb_diff(2)-temp*emag_diff)/emag
            enc(2, i) = temp
            temp = ecxb(3)/emag
            enc_diff(3, i) = (ecxb_diff(3)-temp*emag_diff)/emag
            enc(3, i) = temp
            DO n=1,ndesign
              CALL CROSS(ec_g(1, n), eb, ecxb_g)
              emag_g = enc(1, i)*ecxb_g(1) + enc(2, i)*ecxb_g(2) + enc(3
     +          , i)*ecxb_g(3)
              enc_g(1, i, n) = (ecxb_g(1)-enc(1, i)*emag_g)/emag
              enc_g(2, i, n) = (ecxb_g(2)-enc(2, i)*emag_g)/emag
              enc_g(3, i, n) = (ecxb_g(3)-enc(3, i)*emag_g)/emag
            ENDDO
          ELSE
            enc_diff(1, i) = es_diff(1)
            enc(1, i) = es(1)
            enc_diff(2, i) = es_diff(2)
            enc(2, i) = es(2)
            enc_diff(3, i) = es_diff(3)
            enc(3, i) = es(3)
          END IF
C
C
C...Define direction of normal vector at vortex mid-point. 
C   The YZ projection of the normal vector matches the camber slope
C   + section local incidence in the YZ defining plane for the section
          ang_diff = ainc_diff(j) - slopev_diff(i)/(1.0+slopev(i)**2)
          ang = ainc(j) - ATAN(slopev(i))
Cc          IF(LDES) THEN
C--------- add design-variable contribution to angle
          DO n=1,ndesign
            ang_diff = ang_diff + deldes(n)*ainc_g_diff(j, n)
            ang = ang + ainc_g(j, n)*deldes(n)
          ENDDO
Cc          ENDIF
C
          sinc_diff = COS(ang)*ang_diff
          sinc = SIN(ang)
          cosc_diff = -(SIN(ang)*ang_diff)
          cosc = COS(ang)
          ec_diff(1) = cosc_diff
          ec(1) = cosc
          ec_diff(2) = -(es(2)*sinc_diff+sinc*es_diff(2))
          ec(2) = -(sinc*es(2))
          ec_diff(3) = -(es(3)*sinc_diff+sinc*es_diff(3))
          ec(3) = -(sinc*es(3))
          DO n=1,ndesign
            ec_g(1, n) = -(sinc*ainc_g(j, n))
            ec_g(2, n) = -(cosc*es(2)*ainc_g(j, n))
            ec_g(3, n) = -(cosc*es(3)*ainc_g(j, n))
          ENDDO
C
C...Normal vector is perpendicular to camberline vector and to the bound leg
          CALL CROSS_D(ec, ec_diff, eb, eb_diff, ecxb, ecxb_diff)
          arg1_diff = 2*ecxb(1)*ecxb_diff(1) + 2*ecxb(2)*ecxb_diff(2) + 
     +      2*ecxb(3)*ecxb_diff(3)
          arg1 = ecxb(1)**2 + ecxb(2)**2 + ecxb(3)**2
          temp = SQRT(arg1)
          IF (arg1 .EQ. 0.D0) THEN
            emag_diff = 0.D0
          ELSE
            emag_diff = arg1_diff/(2.0*temp)
          END IF
          emag = temp
          IF (emag .NE. 0.0) THEN
            temp = ecxb(1)/emag
            env_diff(1, i) = (ecxb_diff(1)-temp*emag_diff)/emag
            env(1, i) = temp
            temp = ecxb(2)/emag
            env_diff(2, i) = (ecxb_diff(2)-temp*emag_diff)/emag
            env(2, i) = temp
            temp = ecxb(3)/emag
            env_diff(3, i) = (ecxb_diff(3)-temp*emag_diff)/emag
            env(3, i) = temp
            DO n=1,ndesign
              CALL CROSS(ec_g(1, n), eb, ecxb_g)
              emag_g = enc(1, i)*ecxb_g(1) + enc(2, i)*ecxb_g(2) + enc(3
     +          , i)*ecxb_g(3)
              env_g(1, i, n) = (ecxb_g(1)-env(1, i)*emag_g)/emag
              env_g(2, i, n) = (ecxb_g(2)-env(2, i)*emag_g)/emag
              env_g(3, i, n) = (ecxb_g(3)-env(3, i)*emag_g)/emag
            ENDDO
          ELSE
            env_diff(1, i) = es_diff(1)
            env(1, i) = es(1)
            env_diff(2, i) = es_diff(2)
            env(2, i) = es(2)
            env_diff(3, i) = es_diff(3)
            env(3, i) = es(3)
          END IF
C
C
Ccc       write(*,*) i, dcontrol(i,1), dcontrol(i,2)
C
C=======================================================
C-------- rotate normal vectors for control surface
          DO n=1,ncontrol
C
C---------- skip everything if this element is unaffected by control variable N
            IF (dcontrol(i, n) .NE. 0.0) THEN
C
              ang = dtr*dcontrol(i, n)*delcon(n)
              ang_ddc_diff = dtr*dcontrol_diff(i, n)
              ang_ddc = dtr*dcontrol(i, n)
C
              cosd = COS(ang)
              sind = SIN(ang)
C
C---------- EP = normal-vector component perpendicular to hinge line
              endot_diff = DOT_D(enc(1, i), enc_diff(1, i), vhinge(1, j
     +          , n), vhinge_diff(1, j, n), endot)
              ep_diff(1) = enc_diff(1, i) - vhinge(1, j, n)*endot_diff -
     +          endot*vhinge_diff(1, j, n)
              ep(1) = enc(1, i) - endot*vhinge(1, j, n)
              ep_diff(2) = enc_diff(2, i) - vhinge(2, j, n)*endot_diff -
     +          endot*vhinge_diff(2, j, n)
              ep(2) = enc(2, i) - endot*vhinge(2, j, n)
              ep_diff(3) = enc_diff(3, i) - vhinge(3, j, n)*endot_diff -
     +          endot*vhinge_diff(3, j, n)
              ep(3) = enc(3, i) - endot*vhinge(3, j, n)
C---------- EQ = unit vector perpendicular to both EP and hinge line
              CALL CROSS_D(vhinge(1, j, n), vhinge_diff(1, j, n), ep, 
     +                     ep_diff, eq, eq_diff)
C
C---------- rotated vector would consist of sin,cos parts from EP and EQ,
C-          with hinge-parallel component ENDOT restored 
Cc          ENC(1,I) = EP(1)*COSD + EQ(1)*SIND + ENDOT*VHINGE(1,J,N)
Cc          ENC(2,I) = EP(2)*COSD + EQ(2)*SIND + ENDOT*VHINGE(2,J,N)
Cc          ENC(3,I) = EP(3)*COSD + EQ(3)*SIND + ENDOT*VHINGE(3,J,N)
C
C---------- linearize about zero deflection (COSD=1, SIND=0)
              enc_d_diff(1, i, n) = enc_d_diff(1, i, n) + ang_ddc*
     +          eq_diff(1) + eq(1)*ang_ddc_diff
              enc_d(1, i, n) = enc_d(1, i, n) + eq(1)*ang_ddc
              enc_d_diff(2, i, n) = enc_d_diff(2, i, n) + ang_ddc*
     +          eq_diff(2) + eq(2)*ang_ddc_diff
              enc_d(2, i, n) = enc_d(2, i, n) + eq(2)*ang_ddc
              enc_d_diff(3, i, n) = enc_d_diff(3, i, n) + ang_ddc*
     +          eq_diff(3) + eq(3)*ang_ddc_diff
              enc_d(3, i, n) = enc_d(3, i, n) + eq(3)*ang_ddc
C
C
C---------- repeat for ENV vector
C
C---------- EP = normal-vector component perpendicular to hinge line
              endot_diff = DOT_D(env(1, i), env_diff(1, i), vhinge(1, j
     +          , n), vhinge_diff(1, j, n), endot)
              ep_diff(1) = env_diff(1, i) - vhinge(1, j, n)*endot_diff -
     +          endot*vhinge_diff(1, j, n)
              ep(1) = env(1, i) - endot*vhinge(1, j, n)
              ep_diff(2) = env_diff(2, i) - vhinge(2, j, n)*endot_diff -
     +          endot*vhinge_diff(2, j, n)
              ep(2) = env(2, i) - endot*vhinge(2, j, n)
              ep_diff(3) = env_diff(3, i) - vhinge(3, j, n)*endot_diff -
     +          endot*vhinge_diff(3, j, n)
              ep(3) = env(3, i) - endot*vhinge(3, j, n)
C---------- EQ = unit vector perpendicular to both EP and hinge line
              CALL CROSS_D(vhinge(1, j, n), vhinge_diff(1, j, n), ep, 
     +                     ep_diff, eq, eq_diff)
C
C---------- rotated vector would consist of sin,cos parts from EP and EQ,
C-          with hinge-parallel component ENDOT restored 
Cc          ENV(1,I) = EP(1)*COSD + EQ(1)*SIND + ENDOT*VHINGE(1,J,N)
Cc          ENV(2,I) = EP(2)*COSD + EQ(2)*SIND + ENDOT*VHINGE(2,J,N)
Cc          ENV(3,I) = EP(3)*COSD + EQ(3)*SIND + ENDOT*VHINGE(3,J,N)
C
C---------- linearize about zero deflection (COSD=1, SIND=0)
              env_d(1, i, n) = env_d(1, i, n) + eq(1)*ang_ddc
              env_d(2, i, n) = env_d(2, i, n) + eq(2)*ang_ddc
              env_d(3, i, n) = env_d(3, i, n) + eq(3)*ang_ddc
            END IF
          ENDDO
        ENDDO
      ENDDO
C
C
      lenc = .true.
C
      RETURN
      END
C ENCALC
C

