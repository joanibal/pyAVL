C        Generated by TAPENADE     (INRIA, Ecuador team)
C  Tapenade 3.16 (develop) - 15 Jan 2021 14:26
C
C  Differentiation of vvor in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: wc_gam
C   with respect to varying inputs: chordv rc rv1 rv2 zsym betm
C                ysym
C***********************************************************************
C    Module:  aic.f
C 
C    Copyright (C) 2002 Mark Drela, Harold Youngren
C 
C    This program is free software; you can redistribute it and/or modify
C    it under the terms of the GNU General Public License as published by
C    the Free Software Foundation; either version 2 of the License, or
C    (at your option) any later version.
C
C    This program is distributed in the hope that it will be useful,
C    but WITHOUT ANY WARRANTY; without even the implied warranty of
C    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
C    GNU General Public License for more details.
C
C    You should have received a copy of the GNU General Public License
C    along with this program; if not, write to the Free Software
C    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
C***********************************************************************
C
C
      SUBROUTINE VVOR_D(betm, betm_diff, iysym, ysym, ysym_diff, izsym, 
     +                  zsym, zsym_diff, vrcore, nv, rv1, rv1_diff, rv2
     +                  , rv2_diff, nsurfv, chordv, chordv_diff, nc, rc
     +                  , rc_diff, nsurfc, lvtest, wc_gam, wc_gam_diff, 
     +                  ncdim)
      INTEGER nv
C--------------------------------------------------------------------
C     Calculates the velocity influence matrix for a collection 
C     of horseshoe vortices and control points
C     
C Input
C -----
C     BETM      SQRT(1-MACH*MACH)
C     IYSYM     Plane of symmetry XZ 
C                = 0 no symmetry
C                = 1 regular symmetry
C                =-1 free-surface symmetry
C     YSYM      Y coordinate of symmetry plane
C     IZSYM     Second plane of symmetry XY 
C                = 0 no second plane
C                = 1 regular symmetry
C                =-1 free-surface symmetry
C     ZSYM      Z coordinate of symmetry plane
C
C     VRCORE    vortex-line core radius / max(semichord,vortex width)
C
C     NV        number of vortices
C     RV1(3,v)  coordinates of endpoint #1 of the vortices
C     RV2(3,v)  coordinates of endpoint #2 of the vortices
C     NSURFV(v) index of surface containing h.v.
C     CHORDV(v) chord of strip containing h.v.
C
C     NC        number of control points
C     RC(3,c)   coordinates of the control points
C     NSURFC(c) index of surface containing c.p.
C     LVTEST    T if core-radius test is to be applied
C
C     NCDIM     declared size of WC_GAM matrix
C     
C Output
C ------
C     WC_GAM(3..)   Induced-velocity/gamma influence matrix
C     
C--------------------------------------------------------------------
      REAL rv1(3, nv), rv2(3, nv), chordv(nv)
      REAL rv1_diff(3, nv), rv2_diff(3, nv), chordv_diff(nv)
      INTEGER nc
      INTEGER ncdim
      REAL rc(3, nc), wc_gam(3, ncdim, ncdim)
      REAL rc_diff(3, nc), wc_gam_diff(3, ncdim, ncdim)
      INTEGER nsurfv(nv), nsurfc(nc)
      LOGICAL lvtest
C     
      LOGICAL lbound
      REAL fysym
      INTRINSIC FLOAT
      REAL fzsym
      INTEGER i
      REAL x
      REAL x_diff
      REAL y
      REAL y_diff
      REAL z
      REAL z_diff
      REAL u
      REAL u_diff
      REAL v
      REAL v_diff
      REAL w
      REAL w_diff
      INTEGER j
      REAL dsyz
      REAL dsyz_diff
      INTRINSIC SQRT
      REAL rcore
      REAL rcore_diff
      INTRINSIC MAX
      REAL ui
      REAL ui_diff
      REAL vi
      REAL vi_diff
      REAL wi
      REAL wi_diff
      REAL yoff
      REAL yoff_diff
      REAL zoff
      REAL zoff_diff
      REAL xave
      REAL yave
      REAL zave
      REAL uii
      REAL uii_diff
      REAL vii
      REAL vii_diff
      REAL wii
      REAL wii_diff
      REAL us
      REAL us_diff
      REAL vs
      REAL vs_diff
      REAL ws
      REAL ws_diff
      REAL arg1
      REAL arg1_diff
      REAL temp
      INTEGER ii3
      INTEGER ii2
      INTEGER ii1
      REAL vrcore
      REAL zsym
      REAL zsym_diff
      INTEGER izsym
      REAL betm
      REAL betm_diff
      REAL ysym
      REAL ysym_diff
      INTEGER iysym
C     
C     
      fysym = FLOAT(iysym)
      fzsym = FLOAT(izsym)
      DO ii1=1,nvor
        DO ii2=1,nvor
          DO ii3=1,3
            wc_gam_diff(ii3, ii2, ii1) = 0.D0
          ENDDO
        ENDDO
      ENDDO
C     
C...  Nested pair of loops to calculate the normalwash influence matrix
C     the outer loop runs over all the control points
C     the inner loop runs over all the vortex elements 
      DO i=1,nc
C...  Control point location
        x_diff = rc_diff(1, i)
        x = rc(1, i)
        y_diff = rc_diff(2, i)
        y = rc(2, i)
        z_diff = rc_diff(3, i)
        z = rc(3, i)
C     
        u = 0.
        v = 0.
        w = 0.
C     
        DO j=1,nv
C--------- set vortex core
          arg1_diff = 2*(rv2(2, j)-rv1(2, j))*(rv2_diff(2, j)-rv1_diff(2
     +      , j)) + 2*(rv2(3, j)-rv1(3, j))*(rv2_diff(3, j)-rv1_diff(3, 
     +      j))
          arg1 = (rv2(2, j)-rv1(2, j))**2 + (rv2(3, j)-rv1(3, j))**2
          temp = SQRT(arg1)
          IF (arg1 .EQ. 0.D0) THEN
            dsyz_diff = 0.D0
          ELSE
            dsyz_diff = arg1_diff/(2.0*temp)
          END IF
          dsyz = temp
          IF (nsurfc(i) .EQ. nsurfv(j)) THEN
            rcore_diff = 0.0001*dsyz_diff
            rcore = 0.0001*dsyz
          ELSE IF (vrcore*chordv(j) .LT. 2.0*vrcore*dsyz) THEN
            rcore_diff = vrcore*2.0*dsyz_diff
            rcore = 2.0*vrcore*dsyz
          ELSE
            rcore_diff = vrcore*chordv_diff(j)
            rcore = vrcore*chordv(j)
          END IF
C     
          ui = 0.0
          vi = 0.0
          wi = 0.0
C     
          yoff_diff = 2.0*ysym_diff
          yoff = 2.0*ysym
          zoff_diff = 2.0*zsym_diff
          zoff = 2.0*zsym
CCC   ZOFF = 2.0*(ZSYM + ALFA*0.5*(RV1(1,J)+RV2(1,J)) )
C     
C...  Calculate the influence of the REAL vortex
C
          lbound = .NOT.(lvtest .AND. i .EQ. j)
          CALL VORVELC_D(x, x_diff, y, y_diff, z, z_diff, lbound, rv1(1
     +                   , j), rv1_diff(1, j), rv1(2, j), rv1_diff(2, j)
     +                   , rv1(3, j), rv1_diff(3, j), rv2(1, j), 
     +                   rv2_diff(1, j), rv2(2, j), rv2_diff(2, j), rv2(
     +                   3, j), rv2_diff(3, j), betm, betm_diff, u, 
     +                   u_diff, v, v_diff, w, w_diff, rcore, rcore_diff
     +                  )
C     
          IF (iysym .NE. 0) THEN
C...  Calculate the influence of the y-IMAGE vortex
            lbound = .true.
C...  For sym/asym matrices check for vortex midpoints of image vortices
            IF (iysym .EQ. 1) THEN
              xave = 0.5*(rv1(1, j)+rv2(1, j))
              yave = yoff - 0.5*(rv1(2, j)+rv2(2, j))
              zave = 0.5*(rv1(3, j)+rv2(3, j))
              IF (x .EQ. xave .AND. y .EQ. yave .AND. z .EQ. zave) 
     +          lbound = .false.
            END IF
Ccc   IF(.NOT.LBOUND) write(*,*) 'POS self vortex i,j ',i,j
C
            CALL VORVELC_D(x, x_diff, y, y_diff, z, z_diff, lbound, rv2(
     +                     1, j), rv2_diff(1, j), yoff - rv2(2, j), 
     +                     yoff_diff - rv2_diff(2, j), rv2(3, j), 
     +                     rv2_diff(3, j), rv1(1, j), rv1_diff(1, j), 
     +                     yoff - rv1(2, j), yoff_diff - rv1_diff(2, j)
     +                     , rv1(3, j), rv1_diff(3, j), betm, betm_diff
     +                     , ui, ui_diff, vi, vi_diff, wi, wi_diff, 
     +                     rcore, rcore_diff)
C
C               CALL VORVEL(X,Y,Z,LBOUND,
C     &              RV2(1,J),YOFF-RV2(2,J),RV2(3,J),
C     &              RV1(1,J),YOFF-RV1(2,J),RV1(3,J),
C     &              BETM,UI,VI,WI)
C
            ui_diff = fysym*ui_diff
            ui = ui*fysym
            vi_diff = fysym*vi_diff
            vi = vi*fysym
            wi_diff = fysym*wi_diff
            wi = wi*fysym
          ELSE
            ui_diff = 0.D0
            vi_diff = 0.D0
            wi_diff = 0.D0
          END IF
C     
          IF (izsym .NE. 0) THEN
C...  Calculate the influence of the z-IMAGE vortex
            lbound = .true.
            CALL VORVELC_D(x, x_diff, y, y_diff, z, z_diff, lbound, rv2(
     +                     1, j), rv2_diff(1, j), rv2(2, j), rv2_diff(2
     +                     , j), zoff - rv2(3, j), zoff_diff - rv2_diff(
     +                     3, j), rv1(1, j), rv1_diff(1, j), rv1(2, j), 
     +                     rv1_diff(2, j), zoff - rv1(3, j), zoff_diff -
     +                     rv1_diff(3, j), betm, betm_diff, uii, 
     +                     uii_diff, vii, vii_diff, wii, wii_diff, rcore
     +                     , rcore_diff)
            u_diff = u_diff + fzsym*uii_diff
            u = u + uii*fzsym
            v_diff = v_diff + fzsym*vii_diff
            v = v + vii*fzsym
            w_diff = w_diff + fzsym*wii_diff
            w = w + wii*fzsym
C     
C...  Calculate the influence of the y,z-IMAGE vortex
            IF (iysym .NE. 0) THEN
              lbound = .true.
              CALL VORVELC_D(x, x_diff, y, y_diff, z, z_diff, lbound, 
     +                       rv1(1, j), rv1_diff(1, j), yoff - rv1(2, j)
     +                       , yoff_diff - rv1_diff(2, j), zoff - rv1(3
     +                       , j), zoff_diff - rv1_diff(3, j), rv2(1, j)
     +                       , rv2_diff(1, j), yoff - rv2(2, j), 
     +                       yoff_diff - rv2_diff(2, j), zoff - rv2(3, j
     +                       ), zoff_diff - rv2_diff(3, j), betm, 
     +                       betm_diff, uii, uii_diff, vii, vii_diff, 
     +                       wii, wii_diff, rcore, rcore_diff)
C     
              ui_diff = ui_diff + fysym*fzsym*uii_diff
              ui = ui + uii*fysym*fzsym
              vi_diff = vi_diff + fysym*fzsym*vii_diff
              vi = vi + vii*fysym*fzsym
              wi_diff = wi_diff + fysym*fzsym*wii_diff
              wi = wi + wii*fysym*fzsym
            END IF
          END IF
C     
          us_diff = u_diff + ui_diff
          us = u + ui
          vs_diff = v_diff + vi_diff
          vs = v + vi
          ws_diff = w_diff + wi_diff
          ws = w + wi
C     
          wc_gam_diff(1, i, j) = us_diff
          wc_gam(1, i, j) = us
          wc_gam_diff(2, i, j) = vs_diff
          wc_gam(2, i, j) = vs
          wc_gam_diff(3, i, j) = ws_diff
          wc_gam(3, i, j) = ws
        ENDDO
      ENDDO
C     
C
C     
      RETURN
      END

C  Differentiation of cross in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: w
C   with respect to varying inputs: u v w
C SRDSET
C
C
C
      SUBROUTINE CROSS_D(u, u_diff, v, v_diff, w, w_diff)
      REAL u(3), v(3), w(3)
      REAL u_diff(3), v_diff(3), w_diff(3)
      w_diff(1) = v(3)*u_diff(2) + u(2)*v_diff(3) - v(2)*u_diff(3) - u(3
     +  )*v_diff(2)
      w(1) = u(2)*v(3) - u(3)*v(2)
      w_diff(2) = v(1)*u_diff(3) + u(3)*v_diff(1) - v(3)*u_diff(1) - u(1
     +  )*v_diff(3)
      w(2) = u(3)*v(1) - u(1)*v(3)
      w_diff(3) = v(2)*u_diff(1) + u(1)*v_diff(2) - v(1)*u_diff(2) - u(2
     +  )*v_diff(1)
      w(3) = u(1)*v(2) - u(2)*v(1)
      RETURN
      END

C  Differentiation of dot in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: dot
C   with respect to varying inputs: u v
C
C
      FUNCTION DOT_D(u, u_diff, v, v_diff, dot)
      REAL u(3), v(3)
      REAL u_diff(3), v_diff(3)
      REAL dot
      REAL dot_d
      dot_d = v(1)*u_diff(1) + u(1)*v_diff(1) + v(2)*u_diff(2) + u(2)*
     +  v_diff(2) + v(3)*u_diff(3) + u(3)*v_diff(3)
      dot = u(1)*v(1) + u(2)*v(2) + u(3)*v(3)
      RETURN
      END

C  Differentiation of vorvelc in forward (tangent) mode (with options i4 dr8 r8):
C   variations   of useful results: u v w
C   with respect to varying inputs: y1 y2 rcore x y z z1 z2 x1
C                x2 beta
C VORVEL
C
C
C
C
      SUBROUTINE VORVELC_D(x, x_diff, y, y_diff, z, z_diff, lbound, x1, 
     +                     x1_diff, y1, y1_diff, z1, z1_diff, x2, 
     +                     x2_diff, y2, y2_diff, z2, z2_diff, beta, 
     +                     beta_diff, u, u_diff, v, v_diff, w, w_diff, 
     +                     rcore, rcore_diff)
C----------------------------------------------------------
C     Same as VORVEL, with finite core radius
C----------------------------------------------------------
      LOGICAL lbound
C
C
      REAL a(3), b(3), axb(3)
      REAL a_diff(3), b_diff(3), axb_diff(3)
      REAL asq
      REAL asq_diff
      REAL bsq
      REAL bsq_diff
      REAL amag
      REAL amag_diff
      INTRINSIC SQRT
      REAL bmag
      REAL bmag_diff
      REAL axbsq
      REAL axbsq_diff
      REAL adb
      REAL adb_diff
      REAL alsq
      REAL alsq_diff
      REAL ab
      REAL t
      REAL t_diff
      REAL axisq
      REAL axisq_diff
      REAL adi
      REAL adi_diff
      REAL rsq
      REAL rsq_diff
      REAL bxisq
      REAL bxisq_diff
      REAL bdi
      REAL bdi_diff
      REAL arg1
      REAL arg1_diff
      REAL result1
      REAL result1_diff
      REAL arg2
      REAL arg2_diff
      REAL result2
      REAL result2_diff
      INTEGER ii1
      REAL temp
      REAL temp0
      REAL temp1
      REAL temp2
      REAL y1
      REAL y1_diff
      REAL y2
      REAL y2_diff
      REAL rcore
      REAL rcore_diff
      REAL u
      REAL u_diff
      REAL v
      REAL v_diff
      REAL w
      REAL w_diff
      REAL x
      REAL x_diff
      REAL y
      REAL y_diff
      REAL z
      REAL z_diff
      REAL z1
      REAL z1_diff
      REAL z2
      REAL z2_diff
      REAL x1
      REAL x1_diff
      REAL x2
      REAL x2_diff
      REAL beta
      REAL beta_diff
      REAL pi4inv
C
      DATA pi4inv /0.079577472/
C
      DO ii1=1,3
        a_diff(ii1) = 0.D0
      ENDDO
      temp = (x1-x)/beta
      a_diff(1) = (x1_diff-x_diff-temp*beta_diff)/beta
      a(1) = temp
      a_diff(2) = y1_diff - y_diff
      a(2) = y1 - y
      a_diff(3) = z1_diff - z_diff
      a(3) = z1 - z
C
      DO ii1=1,3
        b_diff(ii1) = 0.D0
      ENDDO
      temp = (x2-x)/beta
      b_diff(1) = (x2_diff-x_diff-temp*beta_diff)/beta
      b(1) = temp
      b_diff(2) = y2_diff - y_diff
      b(2) = y2 - y
      b_diff(3) = z2_diff - z_diff
      b(3) = z2 - z
C
      asq_diff = 2*a(1)*a_diff(1) + 2*a(2)*a_diff(2) + 2*a(3)*a_diff(3)
      asq = a(1)**2 + a(2)**2 + a(3)**2
      bsq_diff = 2*b(1)*b_diff(1) + 2*b(2)*b_diff(2) + 2*b(3)*b_diff(3)
      bsq = b(1)**2 + b(2)**2 + b(3)**2
C
      temp = SQRT(asq)
      IF (asq .EQ. 0.D0) THEN
        amag_diff = 0.D0
      ELSE
        amag_diff = asq_diff/(2.0*temp)
      END IF
      amag = temp
      temp = SQRT(bsq)
      IF (bsq .EQ. 0.D0) THEN
        bmag_diff = 0.D0
      ELSE
        bmag_diff = bsq_diff/(2.0*temp)
      END IF
      bmag = temp
C
      u = 0.
      v = 0.
      w = 0.
C
C---- contribution from the transverse bound leg
      IF (lbound .AND. amag*bmag .NE. 0.0) THEN
        DO ii1=1,3
          axb_diff(ii1) = 0.D0
        ENDDO
        axb_diff(1) = b(3)*a_diff(2) + a(2)*b_diff(3) - b(2)*a_diff(3) -
     +    a(3)*b_diff(2)
        axb(1) = a(2)*b(3) - a(3)*b(2)
        axb_diff(2) = b(1)*a_diff(3) + a(3)*b_diff(1) - b(3)*a_diff(1) -
     +    a(1)*b_diff(3)
        axb(2) = a(3)*b(1) - a(1)*b(3)
        axb_diff(3) = b(2)*a_diff(1) + a(1)*b_diff(2) - b(1)*a_diff(2) -
     +    a(2)*b_diff(1)
        axb(3) = a(1)*b(2) - a(2)*b(1)
        axbsq_diff = 2*axb(1)*axb_diff(1) + 2*axb(2)*axb_diff(2) + 2*axb
     +    (3)*axb_diff(3)
        axbsq = axb(1)**2 + axb(2)**2 + axb(3)**2
C
        adb_diff = b(1)*a_diff(1) + a(1)*b_diff(1) + b(2)*a_diff(2) + a(
     +    2)*b_diff(2) + b(3)*a_diff(3) + a(3)*b_diff(3)
        adb = a(1)*b(1) + a(2)*b(2) + a(3)*b(3)
        alsq_diff = asq_diff + bsq_diff - 2.0*adb_diff
        alsq = asq + bsq - 2.0*adb
C
Ccc     RSQ = AXBSQ / ALSQ
C
        ab = amag*bmag
C        T = (AMAG+BMAG)*(1.0 - ADB/AB) / (AXBSQ + ALSQ*RCORE**2)
        arg1_diff = bsq_diff + 2*rcore*rcore_diff
        arg1 = bsq + rcore**2
        temp = SQRT(arg1)
        IF (arg1 .EQ. 0.D0) THEN
          result1_diff = 0.D0
        ELSE
          result1_diff = arg1_diff/(2.0*temp)
        END IF
        result1 = temp
        arg2_diff = asq_diff + 2*rcore*rcore_diff
        arg2 = asq + rcore**2
        temp = SQRT(arg2)
        IF (arg2 .EQ. 0.D0) THEN
          result2_diff = 0.D0
        ELSE
          result2_diff = arg2_diff/(2.0*temp)
        END IF
        result2 = temp
        temp = axbsq + alsq*(rcore*rcore)
        temp0 = (bsq-adb)/result1
        temp1 = (asq-adb)/result2
        temp2 = (temp0+temp1)/temp
        t_diff = ((bsq_diff-adb_diff-temp0*result1_diff)/result1+(
     +    asq_diff-adb_diff-temp1*result2_diff)/result2-temp2*(
     +    axbsq_diff+rcore**2*alsq_diff+alsq*2*rcore*rcore_diff))/temp
        t = temp2
C
        u_diff = t*axb_diff(1) + axb(1)*t_diff
        u = axb(1)*t
        v_diff = t*axb_diff(2) + axb(2)*t_diff
        v = axb(2)*t
        w_diff = t*axb_diff(3) + axb(3)*t_diff
        w = axb(3)*t
      ELSE
        u_diff = 0.D0
        v_diff = 0.D0
        w_diff = 0.D0
      END IF
C
C---- trailing leg attached to A
      IF (amag .NE. 0.0) THEN
        axisq_diff = 2*a(3)*a_diff(3) + 2*a(2)*a_diff(2)
        axisq = a(3)**2 + a(2)**2
C
        adi_diff = a_diff(1)
        adi = a(1)
        rsq_diff = axisq_diff
        rsq = axisq
C
        temp2 = (-(adi/amag)+1.0)/(rsq+rcore*rcore)
        t_diff = -((-((adi_diff-adi*amag_diff/amag)/amag)-temp2*(
     +    rsq_diff+2*rcore*rcore_diff))/(rsq+rcore**2))
        t = -temp2
C
        v_diff = v_diff + t*a_diff(3) + a(3)*t_diff
        v = v + a(3)*t
        w_diff = w_diff - t*a_diff(2) - a(2)*t_diff
        w = w - a(2)*t
      END IF
C
C---- trailing leg attached to B
      IF (bmag .NE. 0.0) THEN
        bxisq_diff = 2*b(3)*b_diff(3) + 2*b(2)*b_diff(2)
        bxisq = b(3)**2 + b(2)**2
C
        bdi_diff = b_diff(1)
        bdi = b(1)
        rsq_diff = bxisq_diff
        rsq = bxisq
C
        temp2 = (-(bdi/bmag)+1.0)/(rsq+rcore*rcore)
        t_diff = (-((bdi_diff-bdi*bmag_diff/bmag)/bmag)-temp2*(rsq_diff+
     +    2*rcore*rcore_diff))/(rsq+rcore**2)
        t = temp2
C
        v_diff = v_diff + t*b_diff(3) + b(3)*t_diff
        v = v + b(3)*t
        w_diff = w_diff - t*b_diff(2) - b(2)*t_diff
        w = w - b(2)*t
      END IF
C
      u_diff = pi4inv*(u_diff-u*beta_diff/beta)/beta
      u = u*pi4inv/beta
      v_diff = pi4inv*v_diff
      v = v*pi4inv
      w_diff = pi4inv*w_diff
      w = w*pi4inv
C
      RETURN
      END

